<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>XZ Utils: lzma_coder_s Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">XZ Utils
   &#160;<span id="projectnumber">5.1.0alpha</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">lzma_coder_s Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8da91ec5f0960e9acfe4ed39454491db"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<b>SEQ_PROPERTIES</b>, 
<b>SEQ_DICTIONARY_SIZE</b>, 
<b>SEQ_UNCOMPRESSED_SIZE</b>, 
<b>SEQ_CODER_INIT</b>, 
<br/>
&#160;&#160;<b>SEQ_CODE</b>
<br/>
 }</td></tr>
<tr class="memitem:a019450c3d55640a4b723a2b4684898fc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>SEQ_HEADER</b>, 
<b>SEQ_CODE</b>
 }</td></tr>
<tr class="memitem:ade37ce1d8a5cce9aa988566706e68e55"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>SEQ_INIT</b>, 
<b>SEQ_CODE</b>, 
<b>SEQ_FINISH</b>
 }</td></tr>
<tr class="memitem:a29e1a2bfb4c8dc010cc9da5c593d18ee"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>SEQ_CODE</b>, 
<b>SEQ_PADDING</b>, 
<b>SEQ_CHECK</b>
 }</td></tr>
<tr class="memitem:a28ac90aaab40bd13427b0b819e432e1b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>SEQ_CODE</b>, 
<b>SEQ_PADDING</b>, 
<b>SEQ_CHECK</b>
 }</td></tr>
<tr class="memitem:a07f9072bb630f69e72ba20224787ad30"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<b>SEQ_INDICATOR</b>, 
<b>SEQ_COUNT</b>, 
<b>SEQ_MEMUSAGE</b>, 
<b>SEQ_UNPADDED</b>, 
<br/>
&#160;&#160;<b>SEQ_UNCOMPRESSED</b>, 
<b>SEQ_PADDING_INIT</b>, 
<b>SEQ_PADDING</b>, 
<b>SEQ_CRC32</b>
<br/>
 }</td></tr>
<tr class="memitem:aded1b19adcdcda4edcf924748ed9be06"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<b>SEQ_INDICATOR</b>, 
<b>SEQ_COUNT</b>, 
<b>SEQ_UNPADDED</b>, 
<b>SEQ_UNCOMPRESSED</b>, 
<br/>
&#160;&#160;<b>SEQ_NEXT</b>, 
<b>SEQ_PADDING</b>, 
<b>SEQ_CRC32</b>
<br/>
 }</td></tr>
<tr class="memitem:ab52f5b83a5309b6bd05d8068ac66334f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<b>SEQ_STREAM_HEADER</b>, 
<b>SEQ_BLOCK_HEADER</b>, 
<b>SEQ_BLOCK</b>, 
<b>SEQ_INDEX</b>, 
<br/>
&#160;&#160;<b>SEQ_STREAM_FOOTER</b>, 
<b>SEQ_STREAM_PADDING</b>
<br/>
 }</td></tr>
<tr class="memitem:a8c5e835f9286a66621c19702680a91d4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<b>SEQ_STREAM_HEADER</b>, 
<b>SEQ_BLOCK_INIT</b>, 
<b>SEQ_BLOCK_HEADER</b>, 
<b>SEQ_BLOCK_ENCODE</b>, 
<br/>
&#160;&#160;<b>SEQ_INDEX_ENCODE</b>, 
<b>SEQ_STREAM_FOOTER</b>
<br/>
 }</td></tr>
<tr class="memitem:a004b0f8fb384def1fb8acbd38a5ccb8d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>sequence</b> { <br/>
&#160;&#160;<b>SEQ_CONTROL</b>, 
<b>SEQ_UNCOMPRESSED_1</b>, 
<b>SEQ_UNCOMPRESSED_2</b>, 
<b>SEQ_COMPRESSED_0</b>, 
<br/>
&#160;&#160;<b>SEQ_COMPRESSED_1</b>, 
<b>SEQ_PROPERTIES</b>, 
<b>SEQ_LZMA</b>, 
<b>SEQ_COPY</b>
<br/>
 }</td></tr>
<tr class="memitem:ae488d4451a1d776f9b1cb21a7f9a05d9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<b>SEQ_INIT</b>, 
<b>SEQ_LZMA_ENCODE</b>, 
<b>SEQ_LZMA_COPY</b>, 
<b>SEQ_UNCOMPRESSED_HEADER</b>, 
<br/>
&#160;&#160;<b>SEQ_UNCOMPRESSED_COPY</b>
<br/>
 }</td></tr>
<tr class="memitem:aed31c1b12e38453640a549610f6c5853"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<b>SEQ_NORMALIZE</b>, 
<b>SEQ_IS_MATCH</b>, 
<b>seq_8</b> = (SEQ_LITERAL), 
<b>seq_8</b> = (SEQ_LITERAL), 
<br/>
&#160;&#160;<b>SEQ_LITERAL_WRITE</b>, 
<b>SEQ_IS_REP</b>, 
<b>seq_len</b> = (SEQ_MATCH_LEN), 
<b>seq_6</b> = (SEQ_DIST_SLOT), 
<br/>
&#160;&#160;<b>SEQ_DIST_MODEL</b>, 
<b>SEQ_DIRECT</b>, 
<b>seq_4</b> = (SEQ_ALIGN), 
<b>SEQ_EOPM</b>, 
<br/>
&#160;&#160;<b>SEQ_IS_REP0</b>, 
<b>SEQ_SHORTREP</b>, 
<b>SEQ_IS_REP0_LONG</b>, 
<b>SEQ_IS_REP1</b>, 
<br/>
&#160;&#160;<b>SEQ_IS_REP2</b>, 
<b>seq_len</b> = (SEQ_MATCH_LEN), 
<b>SEQ_COPY</b>
<br/>
 }</td></tr>
<tr class="memdesc:aed31c1b12e38453640a549610f6c5853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position where to continue the decoder loop.  <a href="structlzma__coder__s.html#aed31c1b12e38453640a549610f6c5853">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:ae9544e7991d6e1590af64fe75204f3b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlzma__next__coder__s.html">lzma_next_coder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#ae9544e7991d6e1590af64fe75204f3b1">next</a></td></tr>
<tr class="memdesc:ae9544e7991d6e1590af64fe75204f3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream decoder or LZMA_Alone decoder.  <a href="#ae9544e7991d6e1590af64fe75204f3b1"></a><br/></td></tr>
<tr class="memitem:a22d3dd0da325b58ccdf4691a183e03c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22d3dd0da325b58ccdf4691a183e03c2"></a>
enum lzma_coder_s:: { ... } &#160;</td><td class="memItemRight" valign="bottom"><b>sequence</b></td></tr>
<tr class="memitem:aec9ca2276cf24e0231223979ecb02064"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#aec9ca2276cf24e0231223979ecb02064">pos</a></td></tr>
<tr class="memdesc:aec9ca2276cf24e0231223979ecb02064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position in the header fields.  <a href="#aec9ca2276cf24e0231223979ecb02064"></a><br/></td></tr>
<tr class="memitem:a4ec43f70b3409eac74687c2217fb9a45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a4ec43f70b3409eac74687c2217fb9a45">uncompressed_size</a></td></tr>
<tr class="memdesc:a4ec43f70b3409eac74687c2217fb9a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uncompressed size decoded from the header.  <a href="#a4ec43f70b3409eac74687c2217fb9a45"></a><br/></td></tr>
<tr class="memitem:aece2b0c739bde236851c363c808ca861"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#aece2b0c739bde236851c363c808ca861">memlimit</a></td></tr>
<tr class="memdesc:aece2b0c739bde236851c363c808ca861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory usage limit.  <a href="#aece2b0c739bde236851c363c808ca861"></a><br/></td></tr>
<tr class="memitem:aa01fa7f2b9b16bb65e4b878d3164c460"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#aa01fa7f2b9b16bb65e4b878d3164c460">memusage</a></td></tr>
<tr class="memdesc:aa01fa7f2b9b16bb65e4b878d3164c460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amount of memory actually needed (only an estimate)  <a href="#aa01fa7f2b9b16bb65e4b878d3164c460"></a><br/></td></tr>
<tr class="memitem:a5824c3e4c7569360ed4ab34dc71ad7c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlzma__options__lzma.html">lzma_options_lzma</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a5824c3e4c7569360ed4ab34dc71ad7c1">options</a></td></tr>
<tr class="memitem:aa29d6f0076ad412d57f6f71fad531423"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa29d6f0076ad412d57f6f71fad531423"></a>
enum lzma_coder_s:: { ... } &#160;</td><td class="memItemRight" valign="bottom"><b>sequence</b></td></tr>
<tr class="memitem:a4c910d93d4167a0bc3e93fde5d2aa9ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c910d93d4167a0bc3e93fde5d2aa9ba"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>header_pos</b></td></tr>
<tr class="memitem:a58217b7ef558ce8849a3da2744c9fad5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58217b7ef558ce8849a3da2744c9fad5"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>header</b> [ALONE_HEADER_SIZE]</td></tr>
<tr class="memitem:a177fe66ec576ab3e694f742313165a17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a177fe66ec576ab3e694f742313165a17"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>flags</b></td></tr>
<tr class="memitem:a1665ebb405056fe0d4a49de2e021d980"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1665ebb405056fe0d4a49de2e021d980"></a>
enum lzma_coder_s:: { ... } &#160;</td><td class="memItemRight" valign="bottom"><b>sequence</b></td></tr>
<tr class="memitem:a05119be19eceb10412ad19c0c7d3b457"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05119be19eceb10412ad19c0c7d3b457"></a>
enum lzma_coder_s:: { ... } &#160;</td><td class="memItemRight" valign="bottom"><b>sequence</b></td></tr>
<tr class="memitem:a02301a2a8320cf85c60acac2c0574d59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlzma__block.html">lzma_block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a02301a2a8320cf85c60acac2c0574d59">block</a></td></tr>
<tr class="memitem:ae2a6054d55b0092854c709ba8b0b2424"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#ae2a6054d55b0092854c709ba8b0b2424">compressed_size</a></td></tr>
<tr class="memdesc:ae2a6054d55b0092854c709ba8b0b2424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressed Size calculated while decoding.  <a href="#ae2a6054d55b0092854c709ba8b0b2424"></a><br/></td></tr>
<tr class="memitem:a6c7ea9011022b89ff784a716abfaa87a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a6c7ea9011022b89ff784a716abfaa87a">compressed_limit</a></td></tr>
<tr class="memitem:a77a9a633583ebb40c684f13396859c1d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a77a9a633583ebb40c684f13396859c1d">check_pos</a></td></tr>
<tr class="memdesc:a77a9a633583ebb40c684f13396859c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position when reading the Check field.  <a href="#a77a9a633583ebb40c684f13396859c1d"></a><br/></td></tr>
<tr class="memitem:a3efbd863755bf90f888943d608af3157"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlzma__check__state.html">lzma_check_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a3efbd863755bf90f888943d608af3157">check</a></td></tr>
<tr class="memdesc:a3efbd863755bf90f888943d608af3157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check of the uncompressed data.  <a href="#a3efbd863755bf90f888943d608af3157"></a><br/></td></tr>
<tr class="memitem:a2b840b351e6a07eabe6dc7810be81ef6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b840b351e6a07eabe6dc7810be81ef6"></a>
enum lzma_coder_s:: { ... } &#160;</td><td class="memItemRight" valign="bottom"><b>sequence</b></td></tr>
<tr class="memitem:a35641bf1a270a34b3de3c6a70f71732b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35641bf1a270a34b3de3c6a70f71732b"></a>
enum lzma_coder_s:: { ... } &#160;</td><td class="memItemRight" valign="bottom"><b>sequence</b></td></tr>
<tr class="memitem:a70b88e1a79013879cc05a500da061bf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a70b88e1a79013879cc05a500da061bf5">index</a></td></tr>
<tr class="memdesc:a70b88e1a79013879cc05a500da061bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Target Index.  <a href="#a70b88e1a79013879cc05a500da061bf5"></a><br/></td></tr>
<tr class="memitem:a68e247f90f4aba2793081830ea307ab9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a68e247f90f4aba2793081830ea307ab9">index_ptr</a></td></tr>
<tr class="memitem:af8069bed41aaf41b3c381f12531df065"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#af8069bed41aaf41b3c381f12531df065">count</a></td></tr>
<tr class="memdesc:af8069bed41aaf41b3c381f12531df065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of Records left to decode.  <a href="#af8069bed41aaf41b3c381f12531df065"></a><br/></td></tr>
<tr class="memitem:a28dd15b7981f811996b178a51941878c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a28dd15b7981f811996b178a51941878c">unpadded_size</a></td></tr>
<tr class="memdesc:a28dd15b7981f811996b178a51941878c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The most recent Unpadded Size field.  <a href="#a28dd15b7981f811996b178a51941878c"></a><br/></td></tr>
<tr class="memitem:ab0f4ab0b3744139fa1220b769a2ad5fb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#ab0f4ab0b3744139fa1220b769a2ad5fb">crc32</a></td></tr>
<tr class="memdesc:ab0f4ab0b3744139fa1220b769a2ad5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRC32 of the List of Records field.  <a href="#ab0f4ab0b3744139fa1220b769a2ad5fb"></a><br/></td></tr>
<tr class="memitem:ab56a23b0af0bd0c9cf093058fd5edd8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab56a23b0af0bd0c9cf093058fd5edd8a"></a>
enum lzma_coder_s:: { ... } &#160;</td><td class="memItemRight" valign="bottom"><b>sequence</b></td></tr>
<tr class="memitem:ac5dc102eb9ab22928daf0c8f37f82207"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#ac5dc102eb9ab22928daf0c8f37f82207">index</a></td></tr>
<tr class="memdesc:ac5dc102eb9ab22928daf0c8f37f82207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index being encoded.  <a href="#ac5dc102eb9ab22928daf0c8f37f82207"></a><br/></td></tr>
<tr class="memitem:a8803a22884c6ebaeb3fbad1a0dcf2a47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlzma__index__iter.html">lzma_index_iter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a8803a22884c6ebaeb3fbad1a0dcf2a47">iter</a></td></tr>
<tr class="memdesc:a8803a22884c6ebaeb3fbad1a0dcf2a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator for the Index being encoded.  <a href="#a8803a22884c6ebaeb3fbad1a0dcf2a47"></a><br/></td></tr>
<tr class="memitem:a5cd20d64c3b87b098d7490bada065b37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5cd20d64c3b87b098d7490bada065b37"></a>
enum lzma_coder_s:: { ... } &#160;</td><td class="memItemRight" valign="bottom"><b>sequence</b></td></tr>
<tr class="memitem:aa1b846202b09a8d858e76f203428ec67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlzma__next__coder__s.html">lzma_next_coder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#aa1b846202b09a8d858e76f203428ec67">block_decoder</a></td></tr>
<tr class="memitem:ad0077e1c466920b2a49f290d9990f2ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlzma__block.html">lzma_block</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#ad0077e1c466920b2a49f290d9990f2ea">block_options</a></td></tr>
<tr class="memdesc:ad0077e1c466920b2a49f290d9990f2ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for the Block encoder.  <a href="#ad0077e1c466920b2a49f290d9990f2ea"></a><br/></td></tr>
<tr class="memitem:ac10ff5340efdab9d370461317f68743a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlzma__stream__flags.html">lzma_stream_flags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#ac10ff5340efdab9d370461317f68743a">stream_flags</a></td></tr>
<tr class="memdesc:ac10ff5340efdab9d370461317f68743a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream Flags from Stream Header.  <a href="#ac10ff5340efdab9d370461317f68743a"></a><br/></td></tr>
<tr class="memitem:ac96693c2a66b7c9c91effefcf110a8f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="index__hash_8h.html#a2db9f438838c8ff72a8a6fd3fc856f8c">lzma_index_hash</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#ac96693c2a66b7c9c91effefcf110a8f5">index_hash</a></td></tr>
<tr class="memitem:a557568bd8fcd864c1a56931d1a3a4762"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a557568bd8fcd864c1a56931d1a3a4762">tell_no_check</a></td></tr>
<tr class="memitem:a221ffca0016e98814e82651f68ef2457"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a221ffca0016e98814e82651f68ef2457">tell_unsupported_check</a></td></tr>
<tr class="memitem:a2c778cf6a565d259c39b624800f194b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a2c778cf6a565d259c39b624800f194b5">tell_any_check</a></td></tr>
<tr class="memdesc:a2c778cf6a565d259c39b624800f194b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, LZMA_GET_CHECK is returned after decoding Stream Header.  <a href="#a2c778cf6a565d259c39b624800f194b5"></a><br/></td></tr>
<tr class="memitem:af313ddb8d30a629ec36e51ec17316656"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#af313ddb8d30a629ec36e51ec17316656">concatenated</a></td></tr>
<tr class="memitem:a0411b09812fe70b2357f847e511ff647"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a0411b09812fe70b2357f847e511ff647">first_stream</a></td></tr>
<tr class="memitem:a3ba792c4c58656a437eef0f033ac978d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a3ba792c4c58656a437eef0f033ac978d">buffer</a> [LZMA_BLOCK_HEADER_SIZE_MAX]</td></tr>
<tr class="memdesc:a3ba792c4c58656a437eef0f033ac978d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary buffer.  <a href="#a3ba792c4c58656a437eef0f033ac978d"></a><br/></td></tr>
<tr class="memitem:ad596128a7093253b76d85425bc29ef83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad596128a7093253b76d85425bc29ef83"></a>
enum lzma_coder_s:: { ... } &#160;</td><td class="memItemRight" valign="bottom"><b>sequence</b></td></tr>
<tr class="memitem:a24b6da6211ff048e1c8e7f904d2a8f05"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a24b6da6211ff048e1c8e7f904d2a8f05">block_encoder_is_initialized</a></td></tr>
<tr class="memitem:a70e4a95d65a71165d3bd3598554db8d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlzma__next__coder__s.html">lzma_next_coder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a70e4a95d65a71165d3bd3598554db8d1">block_encoder</a></td></tr>
<tr class="memdesc:a70e4a95d65a71165d3bd3598554db8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block.  <a href="#a70e4a95d65a71165d3bd3598554db8d1"></a><br/></td></tr>
<tr class="memitem:ab71b022f5ba22481ccc34250a3281d0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlzma__filter.html">lzma_filter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#ab71b022f5ba22481ccc34250a3281d0e">filters</a> [<a class="el" href="filter_8h.html#ab33c0cc1728bf390e5b84f8bce1928ba">LZMA_FILTERS_MAX</a>+1]</td></tr>
<tr class="memdesc:ab71b022f5ba22481ccc34250a3281d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The filter chain currently in use.  <a href="#ab71b022f5ba22481ccc34250a3281d0e"></a><br/></td></tr>
<tr class="memitem:a4f3ac34d1963e5b1e1649475a2f94c96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlzma__next__coder__s.html">lzma_next_coder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a4f3ac34d1963e5b1e1649475a2f94c96">index_encoder</a></td></tr>
<tr class="memitem:a899a8d70db41e08212df4360a629478d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a899a8d70db41e08212df4360a629478d">buffer_pos</a></td></tr>
<tr class="memdesc:a899a8d70db41e08212df4360a629478d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read position in buffer[].  <a href="#a899a8d70db41e08212df4360a629478d"></a><br/></td></tr>
<tr class="memitem:a4f36384e796ff910b875225f4e06f468"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a4f36384e796ff910b875225f4e06f468">buffer_size</a></td></tr>
<tr class="memdesc:a4f36384e796ff910b875225f4e06f468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of bytes in buffer[].  <a href="#a4f36384e796ff910b875225f4e06f468"></a><br/></td></tr>
<tr class="memitem:ad8c78039a925debdd1fee69a5ef6b8e3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#ad8c78039a925debdd1fee69a5ef6b8e3">distance</a></td></tr>
<tr class="memdesc:ad8c78039a925debdd1fee69a5ef6b8e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delta distance.  <a href="#ad8c78039a925debdd1fee69a5ef6b8e3"></a><br/></td></tr>
<tr class="memitem:a45c761ab2c046e1e369a7ed1363833b6"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a45c761ab2c046e1e369a7ed1363833b6">pos</a></td></tr>
<tr class="memdesc:a45c761ab2c046e1e369a7ed1363833b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position in history[].  <a href="#a45c761ab2c046e1e369a7ed1363833b6"></a><br/></td></tr>
<tr class="memitem:ae9d3b08e8800b6f7ed073966fc006d28"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#ae9d3b08e8800b6f7ed073966fc006d28">history</a> [LZMA_DELTA_DIST_MAX]</td></tr>
<tr class="memdesc:ae9d3b08e8800b6f7ed073966fc006d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer to hold history of the original data.  <a href="#ae9d3b08e8800b6f7ed073966fc006d28"></a><br/></td></tr>
<tr class="memitem:a86de52a7653672af6741252ac8615917"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlzma__dict.html">lzma_dict</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a86de52a7653672af6741252ac8615917">dict</a></td></tr>
<tr class="memdesc:a86de52a7653672af6741252ac8615917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dictionary (history buffer)  <a href="#a86de52a7653672af6741252ac8615917"></a><br/></td></tr>
<tr class="memitem:a4d97cdf05c6a7c42b4810d374901b3bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlzma__lz__decoder.html">lzma_lz_decoder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a4d97cdf05c6a7c42b4810d374901b3bf">lz</a></td></tr>
<tr class="memdesc:a4d97cdf05c6a7c42b4810d374901b3bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual LZ-based decoder e.g. LZMA.  <a href="#a4d97cdf05c6a7c42b4810d374901b3bf"></a><br/></td></tr>
<tr class="memitem:a70b93b5b1ff16901ac7003a9f4dd4984"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a70b93b5b1ff16901ac7003a9f4dd4984">next_finished</a></td></tr>
<tr class="memdesc:a70b93b5b1ff16901ac7003a9f4dd4984"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the next filter in the chain has returned LZMA_STREAM_END.  <a href="#a70b93b5b1ff16901ac7003a9f4dd4984"></a><br/></td></tr>
<tr class="memitem:a8461ba5b3185a2e8ec690e9757a27596"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a8461ba5b3185a2e8ec690e9757a27596">this_finished</a></td></tr>
<tr class="memitem:a4a9c3e7e4d7c4345615e3d61ce853f6c"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a17304eec13a1a4a7338d31e1748d736c"><td class="memItemLeft" >&#160;&#160;&#160;size_t&#160;&#160;&#160;<b>pos</b></td></tr>
<tr class="memitem:abb0d4f42df1d04c745055fa6a6a15508"><td class="memItemLeft" >&#160;&#160;&#160;size_t&#160;&#160;&#160;<b>size</b></td></tr>
<tr class="memitem:ae41894947a2e7a8b11f42efd7850c11b"><td class="memItemLeft" >&#160;&#160;&#160;uint8_t&#160;&#160;&#160;<b>buffer</b> [<a class="el" href="common_8h.html#a1b621fc6aec40a92c6bcef56a7994ae7">LZMA_BUFFER_SIZE</a>]</td></tr>
<tr class="memitem:a4a9c3e7e4d7c4345615e3d61ce853f6c"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a4a9c3e7e4d7c4345615e3d61ce853f6c">temp</a></td></tr>
<tr class="memitem:a753801a4c45709d99be38c2cefbeb050"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlzma__lz__encoder.html">lzma_lz_encoder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a753801a4c45709d99be38c2cefbeb050">lz</a></td></tr>
<tr class="memdesc:a753801a4c45709d99be38c2cefbeb050"><td class="mdescLeft">&#160;</td><td class="mdescRight">LZ-based encoder e.g. LZMA.  <a href="#a753801a4c45709d99be38c2cefbeb050"></a><br/></td></tr>
<tr class="memitem:abee9d87f9f7f48ac6dc7a92ec9d1b5f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlzma__mf__s.html">lzma_mf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#abee9d87f9f7f48ac6dc7a92ec9d1b5f6">mf</a></td></tr>
<tr class="memdesc:abee9d87f9f7f48ac6dc7a92ec9d1b5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">History buffer and match finder.  <a href="#abee9d87f9f7f48ac6dc7a92ec9d1b5f6"></a><br/></td></tr>
<tr class="memitem:a727abe5eea431079d14a7ab6d38e0e37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a727abe5eea431079d14a7ab6d38e0e37"></a>
enum lzma_coder_s::sequence&#160;</td><td class="memItemRight" valign="bottom"><b>sequence</b></td></tr>
<tr class="memitem:a22663a90ad71eae76e08bda9c785c403"><td class="memItemLeft" align="right" valign="top">enum sequence&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a22663a90ad71eae76e08bda9c785c403">next_sequence</a></td></tr>
<tr class="memdesc:a22663a90ad71eae76e08bda9c785c403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence after the size fields have been decoded.  <a href="#a22663a90ad71eae76e08bda9c785c403"></a><br/></td></tr>
<tr class="memitem:a3592a93a5348d71ff1cdf3fa651dad05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlzma__lz__decoder.html">lzma_lz_decoder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a3592a93a5348d71ff1cdf3fa651dad05">lzma</a></td></tr>
<tr class="memdesc:a3592a93a5348d71ff1cdf3fa651dad05"><td class="mdescLeft">&#160;</td><td class="mdescRight">LZMA decoder.  <a href="#a3592a93a5348d71ff1cdf3fa651dad05"></a><br/></td></tr>
<tr class="memitem:a587b26315cf6f13c4e1bbc637e9877a5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a587b26315cf6f13c4e1bbc637e9877a5">uncompressed_size</a></td></tr>
<tr class="memdesc:a587b26315cf6f13c4e1bbc637e9877a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uncompressed size of LZMA chunk.  <a href="#a587b26315cf6f13c4e1bbc637e9877a5"></a><br/></td></tr>
<tr class="memitem:ae2a6054d55b0092854c709ba8b0b2424"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#ae2a6054d55b0092854c709ba8b0b2424">compressed_size</a></td></tr>
<tr class="memitem:aab7515f03f47a8eb8b41c829ec70e2c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#aab7515f03f47a8eb8b41c829ec70e2c6">need_properties</a></td></tr>
<tr class="memitem:a6e1a0c91aa57a84e98751fbd6bc2d4d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a6e1a0c91aa57a84e98751fbd6bc2d4d4">need_dictionary_reset</a></td></tr>
<tr class="memitem:ae6044832ae6f926c336766490bde7c1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6044832ae6f926c336766490bde7c1a"></a>
enum lzma_coder_s:: { ... } &#160;</td><td class="memItemRight" valign="bottom"><b>sequence</b></td></tr>
<tr class="memitem:afa7b642d3c9c7a14c6a13634ba87df9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="common_8h.html#a4fd16c96358c705abab5da65940aa1b1">lzma_coder</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#afa7b642d3c9c7a14c6a13634ba87df9a">lzma</a></td></tr>
<tr class="memdesc:afa7b642d3c9c7a14c6a13634ba87df9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">LZMA encoder.  <a href="#afa7b642d3c9c7a14c6a13634ba87df9a"></a><br/></td></tr>
<tr class="memitem:a1afb73d3819108b11db2cf4fe2e07e6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlzma__options__lzma.html">lzma_options_lzma</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a1afb73d3819108b11db2cf4fe2e07e6e">opt_cur</a></td></tr>
<tr class="memdesc:a1afb73d3819108b11db2cf4fe2e07e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">LZMA options currently in use.  <a href="#a1afb73d3819108b11db2cf4fe2e07e6e"></a><br/></td></tr>
<tr class="memitem:ac9494db1386f574574ff963a2063149e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9494db1386f574574ff963a2063149e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>need_state_reset</b></td></tr>
<tr class="memitem:a6d9272084cbf6cbbf174d7e5e00014c3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a6d9272084cbf6cbbf174d7e5e00014c3">buf_pos</a></td></tr>
<tr class="memdesc:a6d9272084cbf6cbbf174d7e5e00014c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read position in buf[].  <a href="#a6d9272084cbf6cbbf174d7e5e00014c3"></a><br/></td></tr>
<tr class="memitem:a47adf0819be2571d4ba213f383d6e069"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a47adf0819be2571d4ba213f383d6e069">buf</a> [<a class="el" href="lzma2__encoder_8h.html#aa7d048c2e2c38d280bf80f26ce435fab">LZMA2_HEADER_MAX</a>+<a class="el" href="lzma2__encoder_8h.html#a8d74c156d01559e0282d9af9c6279e03">LZMA2_CHUNK_MAX</a>]</td></tr>
<tr class="memdesc:a47adf0819be2571d4ba213f383d6e069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer to hold the chunk header and LZMA compressed data.  <a href="#a47adf0819be2571d4ba213f383d6e069"></a><br/></td></tr>
<tr class="memitem:a6a0c931b33086466dd19e9bd6a729ad4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="range__common_8h.html#a34c0f9a451832941a8aa04aa8e085efa">probability</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a6a0c931b33086466dd19e9bd6a729ad4">literal</a> [<a class="el" href="lzma__common_8h.html#aec4bc6b32a64f98d6ff9c04034a42cb9">LITERAL_CODERS_MAX</a>][<a class="el" href="lzma__common_8h.html#a10b5f469b05969cb31c55a66e0de8803">LITERAL_CODER_SIZE</a>]</td></tr>
<tr class="memdesc:a6a0c931b33086466dd19e9bd6a729ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Literals; see comments in <a class="el" href="lzma__common_8h.html" title="Private definitions common to LZMA encoder and decoder.">lzma_common.h</a>.  <a href="#a6a0c931b33086466dd19e9bd6a729ad4"></a><br/></td></tr>
<tr class="memitem:a184d4af9fac283548fbc4ce4431ca579"><td class="memItemLeft" align="right" valign="top"><a class="el" href="range__common_8h.html#a34c0f9a451832941a8aa04aa8e085efa">probability</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a184d4af9fac283548fbc4ce4431ca579">is_match</a> [<a class="el" href="lzma__common_8h.html#ab09b5cfbb756f1b30c59bf321716fd2e">STATES</a>][<a class="el" href="lzma__common_8h.html#a745eda4922193007c4b894dd75330549">POS_STATES_MAX</a>]</td></tr>
<tr class="memdesc:a184d4af9fac283548fbc4ce4431ca579"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, it's a match. Otherwise it's a single 8-bit literal.  <a href="#a184d4af9fac283548fbc4ce4431ca579"></a><br/></td></tr>
<tr class="memitem:a0469b77e72efb1a4a11b48c386583d9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="range__common_8h.html#a34c0f9a451832941a8aa04aa8e085efa">probability</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a0469b77e72efb1a4a11b48c386583d9b">is_rep</a> [<a class="el" href="lzma__common_8h.html#ab09b5cfbb756f1b30c59bf321716fd2e">STATES</a>]</td></tr>
<tr class="memdesc:a0469b77e72efb1a4a11b48c386583d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1, it's a repeated match. The distance is one of rep0 .. rep3.  <a href="#a0469b77e72efb1a4a11b48c386583d9b"></a><br/></td></tr>
<tr class="memitem:a58177656d331e045cd17b2f5afa4ed9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="range__common_8h.html#a34c0f9a451832941a8aa04aa8e085efa">probability</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a58177656d331e045cd17b2f5afa4ed9a">is_rep0</a> [<a class="el" href="lzma__common_8h.html#ab09b5cfbb756f1b30c59bf321716fd2e">STATES</a>]</td></tr>
<tr class="memitem:a0b1b734b0764abc9c3b6d2659f246d0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="range__common_8h.html#a34c0f9a451832941a8aa04aa8e085efa">probability</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a0b1b734b0764abc9c3b6d2659f246d0c">is_rep1</a> [<a class="el" href="lzma__common_8h.html#ab09b5cfbb756f1b30c59bf321716fd2e">STATES</a>]</td></tr>
<tr class="memitem:ab1b118075da11b4a15b3724dbcdef5bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="range__common_8h.html#a34c0f9a451832941a8aa04aa8e085efa">probability</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#ab1b118075da11b4a15b3724dbcdef5bd">is_rep2</a> [<a class="el" href="lzma__common_8h.html#ab09b5cfbb756f1b30c59bf321716fd2e">STATES</a>]</td></tr>
<tr class="memdesc:ab1b118075da11b4a15b3724dbcdef5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 0, distance of a repeated match is rep2. Otherwise it is rep3.  <a href="#ab1b118075da11b4a15b3724dbcdef5bd"></a><br/></td></tr>
<tr class="memitem:a390784e28645a87051478edb0362c352"><td class="memItemLeft" align="right" valign="top"><a class="el" href="range__common_8h.html#a34c0f9a451832941a8aa04aa8e085efa">probability</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a390784e28645a87051478edb0362c352">is_rep0_long</a> [<a class="el" href="lzma__common_8h.html#ab09b5cfbb756f1b30c59bf321716fd2e">STATES</a>][<a class="el" href="lzma__common_8h.html#a745eda4922193007c4b894dd75330549">POS_STATES_MAX</a>]</td></tr>
<tr class="memitem:a4f1dd6d5616ab3dad3a26df7df79a277"><td class="memItemLeft" align="right" valign="top"><a class="el" href="range__common_8h.html#a34c0f9a451832941a8aa04aa8e085efa">probability</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a4f1dd6d5616ab3dad3a26df7df79a277">dist_slot</a> [DIST_STATES][DIST_SLOTS]</td></tr>
<tr class="memitem:a74d7758336f4d55630ddebdb69b13790"><td class="memItemLeft" align="right" valign="top"><a class="el" href="range__common_8h.html#a34c0f9a451832941a8aa04aa8e085efa">probability</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a74d7758336f4d55630ddebdb69b13790">pos_special</a> [FULL_DISTANCES-DIST_MODEL_END]</td></tr>
<tr class="memitem:a80d6f5b49ac3140daaaa70b947654f51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="range__common_8h.html#a34c0f9a451832941a8aa04aa8e085efa">probability</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a80d6f5b49ac3140daaaa70b947654f51">pos_align</a> [ALIGN_SIZE]</td></tr>
<tr class="memitem:a679158ae73ca790d8db8cc5a44b3885c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlzma__length__decoder.html">lzma_length_decoder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a679158ae73ca790d8db8cc5a44b3885c">match_len_decoder</a></td></tr>
<tr class="memdesc:a679158ae73ca790d8db8cc5a44b3885c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of a normal match.  <a href="#a679158ae73ca790d8db8cc5a44b3885c"></a><br/></td></tr>
<tr class="memitem:a26ddee0c9ae3e8eef25646159d7990f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlzma__length__decoder.html">lzma_length_decoder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a26ddee0c9ae3e8eef25646159d7990f4">rep_len_decoder</a></td></tr>
<tr class="memdesc:a26ddee0c9ae3e8eef25646159d7990f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of a repeated match.  <a href="#a26ddee0c9ae3e8eef25646159d7990f4"></a><br/></td></tr>
<tr class="memitem:ac26ef7796f355ff72b83fbb2e3660f94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac26ef7796f355ff72b83fbb2e3660f94"></a>
<a class="el" href="structlzma__range__decoder.html">lzma_range_decoder</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rc</b></td></tr>
<tr class="memitem:a2957b4ed6e3bd1c9be3d2f628c0700a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lzma__common_8h.html#a0898e5dfe84ee35425db2d9f6fbfa3d2">lzma_lzma_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a2957b4ed6e3bd1c9be3d2f628c0700a9">state</a></td></tr>
<tr class="memdesc:a2957b4ed6e3bd1c9be3d2f628c0700a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">State.  <a href="#a2957b4ed6e3bd1c9be3d2f628c0700a9"></a><br/></td></tr>
<tr class="memitem:a9c0a9f85816802c950186fb343d70cdb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a9c0a9f85816802c950186fb343d70cdb">rep0</a></td></tr>
<tr class="memdesc:a9c0a9f85816802c950186fb343d70cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distance of the latest match.  <a href="#a9c0a9f85816802c950186fb343d70cdb"></a><br/></td></tr>
<tr class="memitem:ae9da01f75fbfb40081ce5acb1c5a69af"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#ae9da01f75fbfb40081ce5acb1c5a69af">rep1</a></td></tr>
<tr class="memdesc:ae9da01f75fbfb40081ce5acb1c5a69af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distance of second latest match.  <a href="#ae9da01f75fbfb40081ce5acb1c5a69af"></a><br/></td></tr>
<tr class="memitem:a4712801a6be47ed45904c08e4e877f3e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a4712801a6be47ed45904c08e4e877f3e">rep2</a></td></tr>
<tr class="memdesc:a4712801a6be47ed45904c08e4e877f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distance of third latest match.  <a href="#a4712801a6be47ed45904c08e4e877f3e"></a><br/></td></tr>
<tr class="memitem:ac9d68e7ada144cd530f0a3c6086ebc91"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#ac9d68e7ada144cd530f0a3c6086ebc91">rep3</a></td></tr>
<tr class="memdesc:ac9d68e7ada144cd530f0a3c6086ebc91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distance of fourth latest match.  <a href="#ac9d68e7ada144cd530f0a3c6086ebc91"></a><br/></td></tr>
<tr class="memitem:a03948f88fcae8d6dc0a299f886477322"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a03948f88fcae8d6dc0a299f886477322">pos_mask</a></td></tr>
<tr class="memdesc:a03948f88fcae8d6dc0a299f886477322"><td class="mdescLeft">&#160;</td><td class="mdescRight">(1 &lt;&lt; pos_bits) - 1  <a href="#a03948f88fcae8d6dc0a299f886477322"></a><br/></td></tr>
<tr class="memitem:a8d44f4f2351063bb5b4c71b18c5426c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d44f4f2351063bb5b4c71b18c5426c3"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>literal_context_bits</b></td></tr>
<tr class="memitem:ac6a05854afed901923a35e24c4198a39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6a05854afed901923a35e24c4198a39"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>literal_pos_mask</b></td></tr>
<tr class="memitem:ad50b8f652a5cf62a48665a9d0789d6b1"><td class="memItemLeft" align="right" valign="top">enum lzma_coder_s:: { ... } &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#ad50b8f652a5cf62a48665a9d0789d6b1">sequence</a></td></tr>
<tr class="memdesc:ad50b8f652a5cf62a48665a9d0789d6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position where to continue the decoder loop.  <a href="#ad50b8f652a5cf62a48665a9d0789d6b1"></a><br/></td></tr>
<tr class="memitem:a15647483964b948297a86eb3a93a8a52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="range__common_8h.html#a34c0f9a451832941a8aa04aa8e085efa">probability</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a15647483964b948297a86eb3a93a8a52">probs</a></td></tr>
<tr class="memdesc:a15647483964b948297a86eb3a93a8a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base of the current probability tree.  <a href="#a15647483964b948297a86eb3a93a8a52"></a><br/></td></tr>
<tr class="memitem:a66565c64666a4e7daadc63f386574eff"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a66565c64666a4e7daadc63f386574eff">symbol</a></td></tr>
<tr class="memitem:acad4c2f9bfed9c4ae2ea3e589446ff12"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#acad4c2f9bfed9c4ae2ea3e589446ff12">limit</a></td></tr>
<tr class="memitem:a3db460ca277ffd83e94a33294db8f63c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a3db460ca277ffd83e94a33294db8f63c">offset</a></td></tr>
<tr class="memitem:ab365e3867c5ffc0afa3280810ff4d1b7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#ab365e3867c5ffc0afa3280810ff4d1b7">len</a></td></tr>
<tr class="memitem:af23821e50fe38646e20e847224b59a75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlzma__range__encoder.html">lzma_range_encoder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#af23821e50fe38646e20e847224b59a75">rc</a></td></tr>
<tr class="memdesc:af23821e50fe38646e20e847224b59a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range encoder.  <a href="#af23821e50fe38646e20e847224b59a75"></a><br/></td></tr>
<tr class="memitem:aa94ce09441b42844e6f38c7a83016b5d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#aa94ce09441b42844e6f38c7a83016b5d">reps</a> [REPS]</td></tr>
<tr class="memdesc:aa94ce09441b42844e6f38c7a83016b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The four most recent match distances.  <a href="#aa94ce09441b42844e6f38c7a83016b5d"></a><br/></td></tr>
<tr class="memitem:acb6e2908223c6b435807551fdf670d17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlzma__match.html">lzma_match</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#acb6e2908223c6b435807551fdf670d17">matches</a> [MATCH_LEN_MAX+1]</td></tr>
<tr class="memdesc:acb6e2908223c6b435807551fdf670d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of match candidates.  <a href="#acb6e2908223c6b435807551fdf670d17"></a><br/></td></tr>
<tr class="memitem:a8d4d5463450b911ba521c2295e8a4291"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a8d4d5463450b911ba521c2295e8a4291">matches_count</a></td></tr>
<tr class="memdesc:a8d4d5463450b911ba521c2295e8a4291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of match candidates in matches[].  <a href="#a8d4d5463450b911ba521c2295e8a4291"></a><br/></td></tr>
<tr class="memitem:a58925d2337ee667763a6aa89337b0f07"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a58925d2337ee667763a6aa89337b0f07">longest_match_length</a></td></tr>
<tr class="memitem:a19610bc6e0dfb3437cd1f64e05bceec7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a19610bc6e0dfb3437cd1f64e05bceec7">fast_mode</a></td></tr>
<tr class="memdesc:a19610bc6e0dfb3437cd1f64e05bceec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if using getoptimumfast.  <a href="#a19610bc6e0dfb3437cd1f64e05bceec7"></a><br/></td></tr>
<tr class="memitem:a368f812050b7e760a849bab0059efae9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a368f812050b7e760a849bab0059efae9">is_initialized</a></td></tr>
<tr class="memitem:a7a53779f0567d10794cbfc072b55dabe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a7a53779f0567d10794cbfc072b55dabe">is_flushed</a></td></tr>
<tr class="memitem:a390bbcaf23ea0fbcea77bb557e2367ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a390bbcaf23ea0fbcea77bb557e2367ac"></a>
<a class="el" href="range__common_8h.html#a34c0f9a451832941a8aa04aa8e085efa">probability</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dist_special</b> [FULL_DISTANCES-DIST_MODEL_END]</td></tr>
<tr class="memitem:ad91051994b96c5bc035e6b8fc40acb8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad91051994b96c5bc035e6b8fc40acb8d"></a>
<a class="el" href="range__common_8h.html#a34c0f9a451832941a8aa04aa8e085efa">probability</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dist_align</b> [ALIGN_SIZE]</td></tr>
<tr class="memitem:aaf726d7aaa991be4bd3ae4ffa3f83b43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf726d7aaa991be4bd3ae4ffa3f83b43"></a>
<a class="el" href="structlzma__length__encoder.html">lzma_length_encoder</a>&#160;</td><td class="memItemRight" valign="bottom"><b>match_len_encoder</b></td></tr>
<tr class="memitem:a482680e5c9cc0354077bf5d8993a371a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a482680e5c9cc0354077bf5d8993a371a"></a>
<a class="el" href="structlzma__length__encoder.html">lzma_length_encoder</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rep_len_encoder</b></td></tr>
<tr class="memitem:af2a4efe180abf62198c546fdaca0b671"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2a4efe180abf62198c546fdaca0b671"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>dist_slot_prices</b> [DIST_STATES][DIST_SLOTS]</td></tr>
<tr class="memitem:a5549dba9c976905bd0e1c334c160f8f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5549dba9c976905bd0e1c334c160f8f5"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>dist_prices</b> [DIST_STATES][FULL_DISTANCES]</td></tr>
<tr class="memitem:a9a476ce324f83368e28f5cf5c6dc5174"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a476ce324f83368e28f5cf5c6dc5174"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>dist_table_size</b></td></tr>
<tr class="memitem:a3c69d79ebfd8ae7d94e507b0e97e80d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c69d79ebfd8ae7d94e507b0e97e80d0"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>match_price_count</b></td></tr>
<tr class="memitem:a78e7c12bcfe857ab7e30d061227b88de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78e7c12bcfe857ab7e30d061227b88de"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>align_prices</b> [ALIGN_SIZE]</td></tr>
<tr class="memitem:a8867ec5e368b2a0cb498c15e55bc327f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8867ec5e368b2a0cb498c15e55bc327f"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>align_price_count</b></td></tr>
<tr class="memitem:a20eea53eab557925d21b84959b49a2a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20eea53eab557925d21b84959b49a2a4"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>opts_end_index</b></td></tr>
<tr class="memitem:a6cf3101b65567cd76997252ceb70d822"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cf3101b65567cd76997252ceb70d822"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>opts_current_index</b></td></tr>
<tr class="memitem:a714c0aa55721572ce2e3f8a6b6e4c990"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a714c0aa55721572ce2e3f8a6b6e4c990"></a>
<a class="el" href="structlzma__optimal.html">lzma_optimal</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opts</b> [OPTS]</td></tr>
<tr class="memitem:a9c1d30c7d03ffb503a8766ac4ac9d72a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a9c1d30c7d03ffb503a8766ac4ac9d72a">end_was_reached</a></td></tr>
<tr class="memdesc:a9c1d30c7d03ffb503a8766ac4ac9d72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the next coder in the chain has returned LZMA_STREAM_END.  <a href="#a9c1d30c7d03ffb503a8766ac4ac9d72a"></a><br/></td></tr>
<tr class="memitem:a748eb6120e98fb6aa47f0979c71bc94c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a748eb6120e98fb6aa47f0979c71bc94c">is_encoder</a></td></tr>
<tr class="memitem:a9443efa9dfa47e91ad05d38a81f4500d"><td class="memItemLeft" align="right" valign="top">size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a9443efa9dfa47e91ad05d38a81f4500d">filter</a> )(<a class="el" href="structlzma__simple__s.html">lzma_simple</a> *<a class="el" href="structlzma__coder__s.html#af9dd0c28506e7e23658e367096db4580">simple</a>, uint32_t <a class="el" href="structlzma__coder__s.html#ac61ba39b745f68ad028bc894e22ba440">now_pos</a>, bool <a class="el" href="structlzma__coder__s.html#a748eb6120e98fb6aa47f0979c71bc94c">is_encoder</a>, uint8_t *<a class="el" href="structlzma__coder__s.html#a3ba792c4c58656a437eef0f033ac978d">buffer</a>, size_t <a class="el" href="structlzma__coder__s.html#a923143d90bee77848265a7e8caaaeea7">size</a>)</td></tr>
<tr class="memitem:af9dd0c28506e7e23658e367096db4580"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlzma__simple__s.html">lzma_simple</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#af9dd0c28506e7e23658e367096db4580">simple</a></td></tr>
<tr class="memitem:ac61ba39b745f68ad028bc894e22ba440"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#ac61ba39b745f68ad028bc894e22ba440">now_pos</a></td></tr>
<tr class="memitem:ae6b47602e153ab62f38f5663681ba5fe"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#ae6b47602e153ab62f38f5663681ba5fe">allocated</a></td></tr>
<tr class="memdesc:ae6b47602e153ab62f38f5663681ba5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the memory allocated for the buffer.  <a href="#ae6b47602e153ab62f38f5663681ba5fe"></a><br/></td></tr>
<tr class="memitem:a6dfa9ec23fd5f1bcb8581bfedc9ff367"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__coder__s.html#a6dfa9ec23fd5f1bcb8581bfedc9ff367">filtered</a></td></tr>
</table>
<h2>Member Enumeration Documentation</h2>
<a class="anchor" id="aed31c1b12e38453640a549610f6c5853"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position where to continue the decoder loop. </p>

</div>
</div>
<h2>Field Documentation</h2>
<a class="anchor" id="ae9544e7991d6e1590af64fe75204f3b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlzma__next__coder__s.html">lzma_next_coder</a> lzma_coder_s::next</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream decoder or LZMA_Alone decoder. </p>
<p>Next filter in the chain.</p>
<p>Next coder in the chain.</p>
<p>The filters in the chain; initialized with lzma_raw_decoder_init().</p>
<p>Next filter in the chain, if any. Note that LZMA and LZMA2 are only allowed as the last filter, but the long-range filter in future can be in the middle of the chain. </p>

<p>Referenced by <a class="el" href="simple__coder_8c.html#a0584bf6928a67ce6463d625b8255fcca">copy_or_code()</a>, and <a class="el" href="lz__encoder_8c.html#af8e273502e2493eae8441a836715213e">fill_window()</a>.</p>

</div>
</div>
<a class="anchor" id="aec9ca2276cf24e0231223979ecb02064"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t lzma_coder_s::pos</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position in the header fields. </p>
<p>Write position in buffer[] and position in Stream Padding.</p>
<p>Position in integers.</p>
<p>Position in the Check field.</p>
<p>Flushing position in the temporary buffer. buffer[pos] is the next byte to be copied to out[]. </p>

<p>Referenced by <a class="el" href="delta__encoder_8c.html#abb766eff4602079aa7113baa0e07614e">copy_and_encode()</a>, and <a class="el" href="delta__encoder_8c.html#a3e7782e0ed0c38d5d1e84ccc5b9f58c2">encode_in_place()</a>.</p>

</div>
</div>
<a class="anchor" id="a4ec43f70b3409eac74687c2217fb9a45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> lzma_coder_s::uncompressed_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uncompressed size decoded from the header. </p>
<p>Uncompressed size of a chunk.</p>
<p>The most recent Uncompressed Size field.</p>
<p>Uncompressed Size calculated while encoding.</p>
<p>Uncompressed Size calculated while decoding.</p>
<p>Uncompressed size as bytes, or LZMA_VLI_UNKNOWN if end of payload marker is expected. </p>

</div>
</div>
<a class="anchor" id="aece2b0c739bde236851c363c808ca861"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lzma_coder_s::memlimit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memory usage limit. </p>

</div>
</div>
<a class="anchor" id="aa01fa7f2b9b16bb65e4b878d3164c460"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lzma_coder_s::memusage</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Amount of memory actually needed (only an estimate) </p>

</div>
</div>
<a class="anchor" id="a5824c3e4c7569360ed4ab34dc71ad7c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlzma__options__lzma.html">lzma_options_lzma</a> lzma_coder_s::options</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Options decoded from the header needed to initialize the LZMA decoder </p>

</div>
</div>
<a class="anchor" id="a02301a2a8320cf85c60acac2c0574d59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlzma__block.html">lzma_block</a> * lzma_coder_s::block</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decoding options; we also write Compressed Size and Uncompressed Size back to this structure when the decoding has been finished.</p>
<p>Encoding options; we also write Unpadded Size, Compressed Size, and Uncompressed Size back to this structure when the encoding has been finished. </p>

</div>
</div>
<a class="anchor" id="ae2a6054d55b0092854c709ba8b0b2424"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t lzma_coder_s::compressed_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compressed Size calculated while decoding. </p>
<p>Compressed Size calculated while encoding.</p>
<p>Compressed size of a chunk (excluding headers); this is also used to indicate the end of buf[] in SEQ_LZMA_COPY. </p>

</div>
</div>
<a class="anchor" id="a6c7ea9011022b89ff784a716abfaa87a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> lzma_coder_s::compressed_limit</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum allowed Compressed Size; this takes into account the size of the Block Header and Check fields when Compressed Size is unknown. </p>

</div>
</div>
<a class="anchor" id="a77a9a633583ebb40c684f13396859c1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t lzma_coder_s::check_pos</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position when reading the Check field. </p>

</div>
</div>
<a class="anchor" id="a3efbd863755bf90f888943d608af3157"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlzma__check__state.html">lzma_check_state</a> lzma_coder_s::check</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check of the uncompressed data. </p>

</div>
</div>
<a class="anchor" id="a70b88e1a79013879cc05a500da061bf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> * lzma_coder_s::index</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Target Index. </p>
<p>Index to hold sizes of the Blocks. </p>

<p>Referenced by <a class="el" href="index__decoder_8c.html#a81533a8f0a676b67380e6bd0a255f9df">lzma_index_buffer_decode()</a>.</p>

</div>
</div>
<a class="anchor" id="a68e247f90f4aba2793081830ea307ab9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a>** lzma_coder_s::index_ptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer give by the application, which is set after successful decoding. </p>

</div>
</div>
<a class="anchor" id="af8069bed41aaf41b3c381f12531df065"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> lzma_coder_s::count</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of Records left to decode. </p>

<p>Referenced by <a class="el" href="index__decoder_8c.html#a81533a8f0a676b67380e6bd0a255f9df">lzma_index_buffer_decode()</a>.</p>

</div>
</div>
<a class="anchor" id="a28dd15b7981f811996b178a51941878c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> lzma_coder_s::unpadded_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The most recent Unpadded Size field. </p>

</div>
</div>
<a class="anchor" id="ab0f4ab0b3744139fa1220b769a2ad5fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lzma_coder_s::crc32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CRC32 of the List of Records field. </p>

</div>
</div>
<a class="anchor" id="ac5dc102eb9ab22928daf0c8f37f82207"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a>* lzma_coder_s::index</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index being encoded. </p>

</div>
</div>
<a class="anchor" id="a8803a22884c6ebaeb3fbad1a0dcf2a47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlzma__index__iter.html">lzma_index_iter</a> lzma_coder_s::iter</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator for the Index being encoded. </p>

</div>
</div>
<a class="anchor" id="aa1b846202b09a8d858e76f203428ec67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlzma__next__coder__s.html">lzma_next_coder</a> lzma_coder_s::block_decoder</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Block or Metadata decoder. This takes little memory and the same data structure can be used to decode every Block Header, so it's a good idea to have a separate lzma_next_coder structure for it. </p>

</div>
</div>
<a class="anchor" id="ad0077e1c466920b2a49f290d9990f2ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlzma__block.html">lzma_block</a> lzma_coder_s::block_options</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Options for the Block encoder. </p>
<p>Block options decoded by the Block Header decoder and used by the Block decoder. </p>

</div>
</div>
<a class="anchor" id="ac10ff5340efdab9d370461317f68743a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlzma__stream__flags.html">lzma_stream_flags</a> lzma_coder_s::stream_flags</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream Flags from Stream Header. </p>

</div>
</div>
<a class="anchor" id="ac96693c2a66b7c9c91effefcf110a8f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="index__hash_8h.html#a2db9f438838c8ff72a8a6fd3fc856f8c">lzma_index_hash</a>* lzma_coder_s::index_hash</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Index is hashed so that it can be compared to the sizes of Blocks with O(1) memory usage. </p>

</div>
</div>
<a class="anchor" id="a557568bd8fcd864c1a56931d1a3a4762"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lzma_coder_s::tell_no_check</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If true, LZMA_NO_CHECK is returned if the Stream has no integrity check. </p>

</div>
</div>
<a class="anchor" id="a221ffca0016e98814e82651f68ef2457"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lzma_coder_s::tell_unsupported_check</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If true, LZMA_UNSUPPORTED_CHECK is returned if the Stream has an integrity check that isn't supported by this liblzma build. </p>

</div>
</div>
<a class="anchor" id="a2c778cf6a565d259c39b624800f194b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lzma_coder_s::tell_any_check</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If true, LZMA_GET_CHECK is returned after decoding Stream Header. </p>

</div>
</div>
<a class="anchor" id="af313ddb8d30a629ec36e51ec17316656"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lzma_coder_s::concatenated</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If true, we will decode concatenated Streams that possibly have Stream Padding between or after them. LZMA_STREAM_END is returned once the application isn't giving us any new input, and we aren't in the middle of a Stream, and possible Stream Padding is a multiple of four bytes. </p>

</div>
</div>
<a class="anchor" id="a0411b09812fe70b2357f847e511ff647"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lzma_coder_s::first_stream</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When decoding concatenated Streams, this is true as long as we are decoding the first Stream. This is needed to avoid misleading LZMA_FORMAT_ERROR in case the later Streams don't have valid magic bytes. </p>

</div>
</div>
<a class="anchor" id="a3ba792c4c58656a437eef0f033ac978d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t lzma_coder_s::buffer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Temporary buffer. </p>
<p>Buffer to hold Stream Header, Block Header, and Stream Footer. Block Header has biggest maximum size. </p>

</div>
</div>
<a class="anchor" id="a24b6da6211ff048e1c8e7f904d2a8f05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lzma_coder_s::block_encoder_is_initialized</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>True if Block encoder has been initialized by stream_encoder_init() or stream_encoder_update() and thus doesn't need to be initialized in stream_encode(). </p>

</div>
</div>
<a class="anchor" id="a70e4a95d65a71165d3bd3598554db8d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlzma__next__coder__s.html">lzma_next_coder</a> lzma_coder_s::block_encoder</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block. </p>

</div>
</div>
<a class="anchor" id="ab71b022f5ba22481ccc34250a3281d0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlzma__filter.html">lzma_filter</a> lzma_coder_s::filters[<a class="el" href="filter_8h.html#ab33c0cc1728bf390e5b84f8bce1928ba">LZMA_FILTERS_MAX</a>+1]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The filter chain currently in use. </p>

</div>
</div>
<a class="anchor" id="a4f3ac34d1963e5b1e1649475a2f94c96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlzma__next__coder__s.html">lzma_next_coder</a> lzma_coder_s::index_encoder</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Index encoder. This is separate from Block encoder, because this doesn't take much memory, and when encoding multiple Streams with the same encoding options we avoid reallocating memory. </p>

</div>
</div>
<a class="anchor" id="a899a8d70db41e08212df4360a629478d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t lzma_coder_s::buffer_pos</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read position in buffer[]. </p>

</div>
</div>
<a class="anchor" id="a4f36384e796ff910b875225f4e06f468"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t lzma_coder_s::buffer_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total number of bytes in buffer[]. </p>

</div>
</div>
<a class="anchor" id="ad8c78039a925debdd1fee69a5ef6b8e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t lzma_coder_s::distance</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delta distance. </p>

<p>Referenced by <a class="el" href="delta__encoder_8c.html#abb766eff4602079aa7113baa0e07614e">copy_and_encode()</a>, and <a class="el" href="delta__encoder_8c.html#a3e7782e0ed0c38d5d1e84ccc5b9f58c2">encode_in_place()</a>.</p>

</div>
</div>
<a class="anchor" id="a45c761ab2c046e1e369a7ed1363833b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t lzma_coder_s::pos</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position in history[]. </p>

</div>
</div>
<a class="anchor" id="ae9d3b08e8800b6f7ed073966fc006d28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t lzma_coder_s::history[LZMA_DELTA_DIST_MAX]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Buffer to hold history of the original data. </p>

<p>Referenced by <a class="el" href="delta__encoder_8c.html#abb766eff4602079aa7113baa0e07614e">copy_and_encode()</a>, and <a class="el" href="delta__encoder_8c.html#a3e7782e0ed0c38d5d1e84ccc5b9f58c2">encode_in_place()</a>.</p>

</div>
</div>
<a class="anchor" id="a86de52a7653672af6741252ac8615917"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlzma__dict.html">lzma_dict</a> lzma_coder_s::dict</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dictionary (history buffer) </p>

</div>
</div>
<a class="anchor" id="a4d97cdf05c6a7c42b4810d374901b3bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlzma__lz__decoder.html">lzma_lz_decoder</a> lzma_coder_s::lz</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The actual LZ-based decoder e.g. LZMA. </p>

</div>
</div>
<a class="anchor" id="a70b93b5b1ff16901ac7003a9f4dd4984"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lzma_coder_s::next_finished</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True if the next filter in the chain has returned LZMA_STREAM_END. </p>

</div>
</div>
<a class="anchor" id="a8461ba5b3185a2e8ec690e9757a27596"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lzma_coder_s::this_finished</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>True if the LZ decoder (e.g. LZMA) has detected end of payload marker. This may become true before next_finished becomes true. </p>

</div>
</div>
<a class="anchor" id="a923143d90bee77848265a7e8caaaeea7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t lzma_coder_s::size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Total number of bytes (both filtered and unfiltered) currently in the temporary buffer. </p>

</div>
</div>
<a class="anchor" id="a4a9c3e7e4d7c4345615e3d61ce853f6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   lzma_coder_s::temp</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Temporary buffer needed when the LZ-based filter is not the last filter in the chain. The output of the next filter is first decoded into buffer[], which is then used as input for the actual LZ-based decoder. </p>

</div>
</div>
<a class="anchor" id="a753801a4c45709d99be38c2cefbeb050"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlzma__lz__encoder.html">lzma_lz_encoder</a> lzma_coder_s::lz</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LZ-based encoder e.g. LZMA. </p>

</div>
</div>
<a class="anchor" id="abee9d87f9f7f48ac6dc7a92ec9d1b5f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlzma__mf__s.html">lzma_mf</a> lzma_coder_s::mf</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>History buffer and match finder. </p>

<p>Referenced by <a class="el" href="lz__encoder_8c.html#af8e273502e2493eae8441a836715213e">fill_window()</a>.</p>

</div>
</div>
<a class="anchor" id="a22663a90ad71eae76e08bda9c785c403"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum sequence lzma_coder_s::next_sequence</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sequence after the size fields have been decoded. </p>

</div>
</div>
<a class="anchor" id="a3592a93a5348d71ff1cdf3fa651dad05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlzma__lz__decoder.html">lzma_lz_decoder</a> lzma_coder_s::lzma</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LZMA decoder. </p>

</div>
</div>
<a class="anchor" id="a587b26315cf6f13c4e1bbc637e9877a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t lzma_coder_s::uncompressed_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uncompressed size of LZMA chunk. </p>
<p>Uncompressed size of a chunk. </p>

</div>
</div>
<a class="anchor" id="ae2a6054d55b0092854c709ba8b0b2424"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t lzma_coder_s::compressed_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compressed size of the chunk (naturally equals to uncompressed size of uncompressed chunk)</p>
<p>Compressed size of a chunk (excluding headers); this is also used to indicate the end of buf[] in SEQ_LZMA_COPY. </p>

</div>
</div>
<a class="anchor" id="aab7515f03f47a8eb8b41c829ec70e2c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lzma_coder_s::need_properties</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>True if properties are needed. This is false before the first LZMA chunk. </p>

</div>
</div>
<a class="anchor" id="a6e1a0c91aa57a84e98751fbd6bc2d4d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lzma_coder_s::need_dictionary_reset</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>True if dictionary reset is needed. This is false before the first chunk (LZMA or uncompressed). </p>

</div>
</div>
<a class="anchor" id="afa7b642d3c9c7a14c6a13634ba87df9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_8h.html#a4fd16c96358c705abab5da65940aa1b1">lzma_coder</a>* lzma_coder_s::lzma</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LZMA encoder. </p>

</div>
</div>
<a class="anchor" id="a1afb73d3819108b11db2cf4fe2e07e6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlzma__options__lzma.html">lzma_options_lzma</a> lzma_coder_s::opt_cur</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LZMA options currently in use. </p>

</div>
</div>
<a class="anchor" id="a6d9272084cbf6cbbf174d7e5e00014c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t lzma_coder_s::buf_pos</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read position in buf[]. </p>

</div>
</div>
<a class="anchor" id="a47adf0819be2571d4ba213f383d6e069"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t lzma_coder_s::buf[<a class="el" href="lzma2__encoder_8h.html#aa7d048c2e2c38d280bf80f26ce435fab">LZMA2_HEADER_MAX</a>+<a class="el" href="lzma2__encoder_8h.html#a8d74c156d01559e0282d9af9c6279e03">LZMA2_CHUNK_MAX</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Buffer to hold the chunk header and LZMA compressed data. </p>

</div>
</div>
<a class="anchor" id="a6a0c931b33086466dd19e9bd6a729ad4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="range__common_8h.html#a34c0f9a451832941a8aa04aa8e085efa">probability</a> lzma_coder_s::literal</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Literals; see comments in <a class="el" href="lzma__common_8h.html" title="Private definitions common to LZMA encoder and decoder.">lzma_common.h</a>. </p>

</div>
</div>
<a class="anchor" id="a184d4af9fac283548fbc4ce4431ca579"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="range__common_8h.html#a34c0f9a451832941a8aa04aa8e085efa">probability</a> lzma_coder_s::is_match</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If 1, it's a match. Otherwise it's a single 8-bit literal. </p>

</div>
</div>
<a class="anchor" id="a0469b77e72efb1a4a11b48c386583d9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="range__common_8h.html#a34c0f9a451832941a8aa04aa8e085efa">probability</a> lzma_coder_s::is_rep</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If 1, it's a repeated match. The distance is one of rep0 .. rep3. </p>

</div>
</div>
<a class="anchor" id="a58177656d331e045cd17b2f5afa4ed9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="range__common_8h.html#a34c0f9a451832941a8aa04aa8e085efa">probability</a> lzma_coder_s::is_rep0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If 0, distance of a repeated match is rep0. Otherwise check is_rep1. </p>

</div>
</div>
<a class="anchor" id="a0b1b734b0764abc9c3b6d2659f246d0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="range__common_8h.html#a34c0f9a451832941a8aa04aa8e085efa">probability</a> lzma_coder_s::is_rep1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If 0, distance of a repeated match is rep1. Otherwise check is_rep2. </p>

</div>
</div>
<a class="anchor" id="ab1b118075da11b4a15b3724dbcdef5bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="range__common_8h.html#a34c0f9a451832941a8aa04aa8e085efa">probability</a> lzma_coder_s::is_rep2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If 0, distance of a repeated match is rep2. Otherwise it is rep3. </p>

</div>
</div>
<a class="anchor" id="a390784e28645a87051478edb0362c352"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="range__common_8h.html#a34c0f9a451832941a8aa04aa8e085efa">probability</a> lzma_coder_s::is_rep0_long</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If 1, the repeated match has length of one byte. Otherwise the length is decoded from rep_len_decoder. </p>

</div>
</div>
<a class="anchor" id="a4f1dd6d5616ab3dad3a26df7df79a277"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="range__common_8h.html#a34c0f9a451832941a8aa04aa8e085efa">probability</a> lzma_coder_s::dist_slot</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Probability tree for the highest two bits of the match distance. There is a separate probability tree for match lengths of 2 (i.e. MATCH_LEN_MIN), 3, 4, and [5, 273]. </p>

</div>
</div>
<a class="anchor" id="a74d7758336f4d55630ddebdb69b13790"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="range__common_8h.html#a34c0f9a451832941a8aa04aa8e085efa">probability</a> lzma_coder_s::pos_special[FULL_DISTANCES-DIST_MODEL_END]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Probability trees for additional bits for match distance when the distance is in the range [4, 127]. </p>

</div>
</div>
<a class="anchor" id="a80d6f5b49ac3140daaaa70b947654f51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="range__common_8h.html#a34c0f9a451832941a8aa04aa8e085efa">probability</a> lzma_coder_s::pos_align[ALIGN_SIZE]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Probability tree for the lowest four bits of a match distance that is equal to or greater than 128. </p>

</div>
</div>
<a class="anchor" id="a679158ae73ca790d8db8cc5a44b3885c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlzma__length__decoder.html">lzma_length_decoder</a> lzma_coder_s::match_len_decoder</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Length of a normal match. </p>

</div>
</div>
<a class="anchor" id="a26ddee0c9ae3e8eef25646159d7990f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlzma__length__decoder.html">lzma_length_decoder</a> lzma_coder_s::rep_len_decoder</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Length of a repeated match. </p>

</div>
</div>
<a class="anchor" id="a2957b4ed6e3bd1c9be3d2f628c0700a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lzma__common_8h.html#a0898e5dfe84ee35425db2d9f6fbfa3d2">lzma_lzma_state</a> lzma_coder_s::state</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>State. </p>

</div>
</div>
<a class="anchor" id="a9c0a9f85816802c950186fb343d70cdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lzma_coder_s::rep0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Distance of the latest match. </p>

</div>
</div>
<a class="anchor" id="ae9da01f75fbfb40081ce5acb1c5a69af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lzma_coder_s::rep1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Distance of second latest match. </p>

</div>
</div>
<a class="anchor" id="a4712801a6be47ed45904c08e4e877f3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lzma_coder_s::rep2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Distance of third latest match. </p>

</div>
</div>
<a class="anchor" id="ac9d68e7ada144cd530f0a3c6086ebc91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lzma_coder_s::rep3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Distance of fourth latest match. </p>

</div>
</div>
<a class="anchor" id="a03948f88fcae8d6dc0a299f886477322"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lzma_coder_s::pos_mask</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(1 &lt;&lt; pos_bits) - 1 </p>

</div>
</div>
<a class="anchor" id="ad50b8f652a5cf62a48665a9d0789d6b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum { ... }   lzma_coder_s::sequence</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position where to continue the decoder loop. </p>

</div>
</div>
<a class="anchor" id="a15647483964b948297a86eb3a93a8a52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="range__common_8h.html#a34c0f9a451832941a8aa04aa8e085efa">probability</a>* lzma_coder_s::probs</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base of the current probability tree. </p>

</div>
</div>
<a class="anchor" id="a66565c64666a4e7daadc63f386574eff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lzma_coder_s::symbol</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Symbol being decoded. This is also used as an index variable in bittree decoders: probs[symbol] </p>

</div>
</div>
<a class="anchor" id="acad4c2f9bfed9c4ae2ea3e589446ff12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lzma_coder_s::limit</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used as a loop termination condition on bittree decoders and direct bits decoder. </p>

</div>
</div>
<a class="anchor" id="a3db460ca277ffd83e94a33294db8f63c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lzma_coder_s::offset</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matched literal decoder: 0x100 or 0 to help avoiding branches. Bittree reverse decoders: Offset of the next bit: 1 &lt;&lt; offset </p>

</div>
</div>
<a class="anchor" id="ab365e3867c5ffc0afa3280810ff4d1b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lzma_coder_s::len</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If decoding a literal: match byte. If decoding a match: length of the match. </p>

</div>
</div>
<a class="anchor" id="af23821e50fe38646e20e847224b59a75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlzma__range__encoder.html">lzma_range_encoder</a> lzma_coder_s::rc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Range encoder. </p>

</div>
</div>
<a class="anchor" id="aa94ce09441b42844e6f38c7a83016b5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lzma_coder_s::reps[REPS]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The four most recent match distances. </p>

</div>
</div>
<a class="anchor" id="acb6e2908223c6b435807551fdf670d17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlzma__match.html">lzma_match</a> lzma_coder_s::matches[MATCH_LEN_MAX+1]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of match candidates. </p>

</div>
</div>
<a class="anchor" id="a8d4d5463450b911ba521c2295e8a4291"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lzma_coder_s::matches_count</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of match candidates in matches[]. </p>

</div>
</div>
<a class="anchor" id="a58925d2337ee667763a6aa89337b0f07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lzma_coder_s::longest_match_length</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variable to hold the length of the longest match between calls to lzma_lzma_optimum_*(). </p>

</div>
</div>
<a class="anchor" id="a19610bc6e0dfb3437cd1f64e05bceec7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lzma_coder_s::fast_mode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True if using getoptimumfast. </p>

</div>
</div>
<a class="anchor" id="a368f812050b7e760a849bab0059efae9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lzma_coder_s::is_initialized</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>True if the encoder has been initialized by encoding the first byte as a literal. </p>

</div>
</div>
<a class="anchor" id="a7a53779f0567d10794cbfc072b55dabe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lzma_coder_s::is_flushed</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>True if the range encoder has been flushed, but not all bytes have been written to the output buffer yet. </p>

</div>
</div>
<a class="anchor" id="a9c1d30c7d03ffb503a8766ac4ac9d72a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lzma_coder_s::end_was_reached</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True if the next coder in the chain has returned LZMA_STREAM_END. </p>

<p>Referenced by <a class="el" href="simple__coder_8c.html#a0584bf6928a67ce6463d625b8255fcca">copy_or_code()</a>.</p>

</div>
</div>
<a class="anchor" id="a748eb6120e98fb6aa47f0979c71bc94c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lzma_coder_s::is_encoder</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>True if <a class="el" href="structlzma__coder__s.html#a9443efa9dfa47e91ad05d38a81f4500d">filter()</a> should encode the data; false to decode. Currently all simple filters use the same function for encoding and decoding, because the difference between encoders and decoders is very small. </p>

<p>Referenced by <a class="el" href="simple__coder_8c.html#a0584bf6928a67ce6463d625b8255fcca">copy_or_code()</a>.</p>

</div>
</div>
<a class="anchor" id="a9443efa9dfa47e91ad05d38a81f4500d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t(* lzma_coder_s::filter)(<a class="el" href="structlzma__simple__s.html">lzma_simple</a> *<a class="el" href="structlzma__coder__s.html#af9dd0c28506e7e23658e367096db4580">simple</a>, uint32_t <a class="el" href="structlzma__coder__s.html#ac61ba39b745f68ad028bc894e22ba440">now_pos</a>, bool <a class="el" href="structlzma__coder__s.html#a748eb6120e98fb6aa47f0979c71bc94c">is_encoder</a>, uint8_t *<a class="el" href="structlzma__coder__s.html#a3ba792c4c58656a437eef0f033ac978d">buffer</a>, size_t <a class="el" href="structlzma__coder__s.html#a923143d90bee77848265a7e8caaaeea7">size</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to filter-specific function, which does the actual filtering. </p>

</div>
</div>
<a class="anchor" id="af9dd0c28506e7e23658e367096db4580"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlzma__simple__s.html">lzma_simple</a>* lzma_coder_s::simple</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to filter-specific data, or NULL if filter doesn't need any extra data. </p>

</div>
</div>
<a class="anchor" id="ac61ba39b745f68ad028bc894e22ba440"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lzma_coder_s::now_pos</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The lowest 32 bits of the current position in the data. Most filters need this to do conversions between absolute and relative addresses. </p>

</div>
</div>
<a class="anchor" id="ae6b47602e153ab62f38f5663681ba5fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t lzma_coder_s::allocated</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of the memory allocated for the buffer. </p>

</div>
</div>
<a class="anchor" id="a6dfa9ec23fd5f1bcb8581bfedc9ff367"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t lzma_coder_s::filtered</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>buffer[filtered] is the first unfiltered byte. When pos is smaller than filtered, there is unflushed filtered data in the buffer. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>liblzma/common/<a class="el" href="alone__decoder_8c.html">alone_decoder.c</a></li>
<li>liblzma/common/alone_encoder.c</li>
<li>liblzma/common/<a class="el" href="auto__decoder_8c.html">auto_decoder.c</a></li>
<li>liblzma/common/<a class="el" href="block__decoder_8c.html">block_decoder.c</a></li>
<li>liblzma/common/<a class="el" href="block__encoder_8c.html">block_encoder.c</a></li>
<li>liblzma/common/<a class="el" href="index__decoder_8c.html">index_decoder.c</a></li>
<li>liblzma/common/<a class="el" href="index__encoder_8c.html">index_encoder.c</a></li>
<li>liblzma/common/<a class="el" href="stream__decoder_8c.html">stream_decoder.c</a></li>
<li>liblzma/common/<a class="el" href="stream__encoder_8c.html">stream_encoder.c</a></li>
<li>liblzma/lzma/<a class="el" href="lzma2__decoder_8c.html">lzma2_decoder.c</a></li>
<li>liblzma/lzma/<a class="el" href="lzma2__encoder_8c.html">lzma2_encoder.c</a></li>
<li>liblzma/lzma/<a class="el" href="lzma__decoder_8c.html">lzma_decoder.c</a></li>
<li>liblzma/delta/<a class="el" href="delta__private_8h.html">delta_private.h</a></li>
<li>liblzma/lz/<a class="el" href="lz__decoder_8c.html">lz_decoder.c</a></li>
<li>liblzma/lz/<a class="el" href="lz__encoder_8c.html">lz_encoder.c</a></li>
<li>liblzma/lzma/<a class="el" href="lzma__encoder__private_8h.html">lzma_encoder_private.h</a></li>
<li>liblzma/simple/<a class="el" href="simple__private_8h.html">simple_private.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jun 5 2014 14:51:01 for XZ Utils by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
