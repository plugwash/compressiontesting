<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>XZ Utils: liblzma/api/lzma/container.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">XZ Utils
   &#160;<span id="projectnumber">5.1.0alpha</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2e0898c272e1f0f93c8ef15f5da2a912.html">liblzma</a></li><li class="navelem"><a class="el" href="dir_3c7592c36b11e0fd373edb6a27c72b1d.html">api</a></li><li class="navelem"><a class="el" href="dir_48cf7e51417fe935412ca5117cfff3c4.html">lzma</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">container.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>File formats.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:af3ca20ff228b363a82515c1aee9e27bc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#af3ca20ff228b363a82515c1aee9e27bc">LZMA_PRESET_DEFAULT</a>&#160;&#160;&#160;UINT32_C(6)</td></tr>
<tr class="memdesc:af3ca20ff228b363a82515c1aee9e27bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default compression preset.  <a href="#af3ca20ff228b363a82515c1aee9e27bc"></a><br/></td></tr>
<tr class="memitem:a97e40265e355a21bd2465aaa5b85f03d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a97e40265e355a21bd2465aaa5b85f03d">LZMA_PRESET_LEVEL_MASK</a>&#160;&#160;&#160;UINT32_C(0x1F)</td></tr>
<tr class="memdesc:a97e40265e355a21bd2465aaa5b85f03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask for preset level.  <a href="#a97e40265e355a21bd2465aaa5b85f03d"></a><br/></td></tr>
<tr class="memitem:af524fe9af5737820fdadcd40a2c26deb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#af524fe9af5737820fdadcd40a2c26deb">LZMA_PRESET_EXTREME</a>&#160;&#160;&#160;(UINT32_C(1) &lt;&lt; 31)</td></tr>
<tr class="memdesc:af524fe9af5737820fdadcd40a2c26deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extreme compression preset.  <a href="#af524fe9af5737820fdadcd40a2c26deb"></a><br/></td></tr>
<tr class="memitem:ada9cd20febb28b5ed6656de9184a86e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#ada9cd20febb28b5ed6656de9184a86e9">LZMA_TELL_NO_CHECK</a>&#160;&#160;&#160;UINT32_C(0x01)</td></tr>
<tr class="memitem:ae21fb746037c82735d40d428c462e078"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#ae21fb746037c82735d40d428c462e078">LZMA_TELL_UNSUPPORTED_CHECK</a>&#160;&#160;&#160;UINT32_C(0x02)</td></tr>
<tr class="memitem:a0bdde702a77ff42b90a99c0bf4147b6b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a0bdde702a77ff42b90a99c0bf4147b6b">LZMA_TELL_ANY_CHECK</a>&#160;&#160;&#160;UINT32_C(0x04)</td></tr>
<tr class="memitem:a563c84b5f368b3dd00d92ea903c5c33d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a563c84b5f368b3dd00d92ea903c5c33d">LZMA_CONCATENATED</a>&#160;&#160;&#160;UINT32_C(0x08)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a62c853cf7dbf008bdbd97b2685c3eabf"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a62c853cf7dbf008bdbd97b2685c3eabf">lzma_easy_encoder_memusage</a> (uint32_t preset) lzma_nothrow lzma_attr_pure</td></tr>
<tr class="memdesc:a62c853cf7dbf008bdbd97b2685c3eabf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate approximate memory usage of easy encoder.  <a href="#a62c853cf7dbf008bdbd97b2685c3eabf"></a><br/></td></tr>
<tr class="memitem:a3562055d26c18fad067a7c7516eaddf5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a3562055d26c18fad067a7c7516eaddf5">lzma_easy_decoder_memusage</a> (uint32_t preset) lzma_nothrow lzma_attr_pure</td></tr>
<tr class="memdesc:a3562055d26c18fad067a7c7516eaddf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate approximate decoder memory usage of a preset.  <a href="#a3562055d26c18fad067a7c7516eaddf5"></a><br/></td></tr>
<tr class="memitem:acbdad999c544872f0f5d242f0d1a4ed4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#acbdad999c544872f0f5d242f0d1a4ed4">lzma_easy_encoder</a> (<a class="el" href="structlzma__stream.html">lzma_stream</a> *<a class="el" href="coder_8c.html#a048a6ae6a7da50de565b15d52ea9fafe">strm</a>, uint32_t preset, <a class="el" href="api_2lzma_2check_8h.html#a0a6100c719ac9aa49be3fdf7519e8c3f">lzma_check</a> <a class="el" href="coder_8c.html#a5c94b0defea7996f245faec2693056cb">check</a>) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:acbdad999c544872f0f5d242f0d1a4ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize .xz Stream encoder using a preset number.  <a href="#acbdad999c544872f0f5d242f0d1a4ed4"></a><br/></td></tr>
<tr class="memitem:a8cd00c448b2cce31398cec01ee30c2f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a8cd00c448b2cce31398cec01ee30c2f3">lzma_easy_buffer_encode</a> (uint32_t preset, <a class="el" href="api_2lzma_2check_8h.html#a0a6100c719ac9aa49be3fdf7519e8c3f">lzma_check</a> <a class="el" href="coder_8c.html#a5c94b0defea7996f245faec2693056cb">check</a>, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator, const uint8_t *in, size_t in_size, uint8_t *out, size_t *out_pos, size_t out_size) lzma_nothrow</td></tr>
<tr class="memdesc:a8cd00c448b2cce31398cec01ee30c2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-call .xz Stream encoding using a preset number.  <a href="#a8cd00c448b2cce31398cec01ee30c2f3"></a><br/></td></tr>
<tr class="memitem:a1a97aec94c9fedd7646cfa51c4f4cd52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a1a97aec94c9fedd7646cfa51c4f4cd52">lzma_stream_encoder</a> (<a class="el" href="structlzma__stream.html">lzma_stream</a> *<a class="el" href="coder_8c.html#a048a6ae6a7da50de565b15d52ea9fafe">strm</a>, const <a class="el" href="structlzma__filter.html">lzma_filter</a> *<a class="el" href="coder_8c.html#a9325236d5759d4eaadcba08a6bb5c96f">filters</a>, <a class="el" href="api_2lzma_2check_8h.html#a0a6100c719ac9aa49be3fdf7519e8c3f">lzma_check</a> <a class="el" href="coder_8c.html#a5c94b0defea7996f245faec2693056cb">check</a>) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:a1a97aec94c9fedd7646cfa51c4f4cd52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize .xz Stream encoder using a custom filter chain.  <a href="#a1a97aec94c9fedd7646cfa51c4f4cd52"></a><br/></td></tr>
<tr class="memitem:a26fcc5bccdf3f862caa4c992d01e1a72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a26fcc5bccdf3f862caa4c992d01e1a72">lzma_alone_encoder</a> (<a class="el" href="structlzma__stream.html">lzma_stream</a> *<a class="el" href="coder_8c.html#a048a6ae6a7da50de565b15d52ea9fafe">strm</a>, const <a class="el" href="structlzma__options__lzma.html">lzma_options_lzma</a> *options) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:a26fcc5bccdf3f862caa4c992d01e1a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize .lzma encoder (legacy file format)  <a href="#a26fcc5bccdf3f862caa4c992d01e1a72"></a><br/></td></tr>
<tr class="memitem:a66d4366a47b8332bff2a512f44f5c45e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a66d4366a47b8332bff2a512f44f5c45e">lzma_stream_buffer_bound</a> (size_t uncompressed_size) lzma_nothrow</td></tr>
<tr class="memdesc:a66d4366a47b8332bff2a512f44f5c45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate output buffer size for single-call Stream encoder.  <a href="#a66d4366a47b8332bff2a512f44f5c45e"></a><br/></td></tr>
<tr class="memitem:a558683e06e092cb3b9e7edb226d6a1b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a558683e06e092cb3b9e7edb226d6a1b8">lzma_stream_buffer_encode</a> (<a class="el" href="structlzma__filter.html">lzma_filter</a> *<a class="el" href="coder_8c.html#a9325236d5759d4eaadcba08a6bb5c96f">filters</a>, <a class="el" href="api_2lzma_2check_8h.html#a0a6100c719ac9aa49be3fdf7519e8c3f">lzma_check</a> <a class="el" href="coder_8c.html#a5c94b0defea7996f245faec2693056cb">check</a>, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator, const uint8_t *in, size_t in_size, uint8_t *out, size_t *out_pos, size_t out_size) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:a558683e06e092cb3b9e7edb226d6a1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-call .xz Stream encoder.  <a href="#a558683e06e092cb3b9e7edb226d6a1b8"></a><br/></td></tr>
<tr class="memitem:a02b7683ef98d8049788961370a8b28c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a02b7683ef98d8049788961370a8b28c0">lzma_stream_decoder</a> (<a class="el" href="structlzma__stream.html">lzma_stream</a> *<a class="el" href="coder_8c.html#a048a6ae6a7da50de565b15d52ea9fafe">strm</a>, uint64_t memlimit, uint32_t flags) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:a02b7683ef98d8049788961370a8b28c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize .xz Stream decoder.  <a href="#a02b7683ef98d8049788961370a8b28c0"></a><br/></td></tr>
<tr class="memitem:a21cbebf2771617bb1e956385cfb353e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a21cbebf2771617bb1e956385cfb353e3">lzma_auto_decoder</a> (<a class="el" href="structlzma__stream.html">lzma_stream</a> *<a class="el" href="coder_8c.html#a048a6ae6a7da50de565b15d52ea9fafe">strm</a>, uint64_t memlimit, uint32_t flags) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:a21cbebf2771617bb1e956385cfb353e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode .xz Streams and .lzma files with autodetection.  <a href="#a21cbebf2771617bb1e956385cfb353e3"></a><br/></td></tr>
<tr class="memitem:a5f43c3a1035e5a226dcd298f4162b861"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a5f43c3a1035e5a226dcd298f4162b861">lzma_alone_decoder</a> (<a class="el" href="structlzma__stream.html">lzma_stream</a> *<a class="el" href="coder_8c.html#a048a6ae6a7da50de565b15d52ea9fafe">strm</a>, uint64_t memlimit) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:a5f43c3a1035e5a226dcd298f4162b861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize .lzma decoder (legacy file format)  <a href="#a5f43c3a1035e5a226dcd298f4162b861"></a><br/></td></tr>
<tr class="memitem:adf823f70e6344e1e393e61b74818a1b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#adf823f70e6344e1e393e61b74818a1b5">lzma_stream_buffer_decode</a> (uint64_t *memlimit, uint32_t flags, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator, const uint8_t *in, size_t *in_pos, size_t in_size, uint8_t *out, size_t *out_pos, size_t out_size) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:adf823f70e6344e1e393e61b74818a1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-call .xz Stream decoder.  <a href="#adf823f70e6344e1e393e61b74818a1b5"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>File formats. </p>
</div><h2>Macro Definition Documentation</h2>
<a class="anchor" id="af3ca20ff228b363a82515c1aee9e27bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_PRESET_DEFAULT&#160;&#160;&#160;UINT32_C(6)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default compression preset. </p>
<p>It's not straightforward to recommend a default preset, because in some cases keeping the resource usage relatively low is more important that getting the maximum compression ratio. </p>

<p>Referenced by <a class="el" href="options_8h.html#a80e4a9dd89d3f2fab00c48c4feb75126">options_lzma()</a>.</p>

</div>
</div>
<a class="anchor" id="a97e40265e355a21bd2465aaa5b85f03d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_PRESET_LEVEL_MASK&#160;&#160;&#160;UINT32_C(0x1F)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask for preset level. </p>
<p>This is useful only if you need to extract the level from the preset variable. That should be rare. </p>

<p>Referenced by <a class="el" href="lzma__encoder__presets_8c.html#a44811d2b250a5eb662eec2d0456a89f8">lzma_lzma_preset()</a>.</p>

</div>
</div>
<a class="anchor" id="af524fe9af5737820fdadcd40a2c26deb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_PRESET_EXTREME&#160;&#160;&#160;(UINT32_C(1) &lt;&lt; 31)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extreme compression preset. </p>
<p>This flag modifies the preset to make the encoding significantly slower while improving the compression ratio only marginally. This is useful when you don't mind wasting time to get as small result as possible.</p>
<p>This flag doesn't affect the memory usage requirements of the decoder (at least not significantly). The memory usage of the encoder may be increased a little but only at the lowest preset levels (0-3). </p>

<p>Referenced by <a class="el" href="lzma__encoder__presets_8c.html#a44811d2b250a5eb662eec2d0456a89f8">lzma_lzma_preset()</a>.</p>

</div>
</div>
<a class="anchor" id="ada9cd20febb28b5ed6656de9184a86e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_TELL_NO_CHECK&#160;&#160;&#160;UINT32_C(0x01)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This flag makes <a class="el" href="base_8h.html#a28cc09bc422d5ba1e0187c9f2af5d957" title="Encode or decode data.">lzma_code()</a> return LZMA_NO_CHECK if the input stream being decoded has no integrity check. Note that when used with <a class="el" href="container_8h.html#a21cbebf2771617bb1e956385cfb353e3" title="Decode .xz Streams and .lzma files with autodetection.">lzma_auto_decoder()</a>, all .lzma files will trigger LZMA_NO_CHECK if LZMA_TELL_NO_CHECK is used. </p>

</div>
</div>
<a class="anchor" id="ae21fb746037c82735d40d428c462e078"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_TELL_UNSUPPORTED_CHECK&#160;&#160;&#160;UINT32_C(0x02)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This flag makes <a class="el" href="base_8h.html#a28cc09bc422d5ba1e0187c9f2af5d957" title="Encode or decode data.">lzma_code()</a> return LZMA_UNSUPPORTED_CHECK if the input stream has an integrity check, but the type of the integrity check is not supported by this liblzma version or build. Such files can still be decoded, but the integrity check cannot be verified. </p>

<p>Referenced by <a class="el" href="coder_8c.html#a6848d01092ac252b6270f739af63e202">coder_init()</a>.</p>

</div>
</div>
<a class="anchor" id="a0bdde702a77ff42b90a99c0bf4147b6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_TELL_ANY_CHECK&#160;&#160;&#160;UINT32_C(0x04)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This flag makes <a class="el" href="base_8h.html#a28cc09bc422d5ba1e0187c9f2af5d957" title="Encode or decode data.">lzma_code()</a> return LZMA_GET_CHECK as soon as the type of the integrity check is known. The type can then be got with <a class="el" href="api_2lzma_2check_8h.html#a8d7c3ffabfd024485f03fa209536c746" title="Get the type of the integrity check.">lzma_get_check()</a>. </p>

<p>Referenced by <a class="el" href="stream__buffer__decoder_8c.html#a9182bc9549f9d1d93c5ac6e546149ca5">lzma_stream_buffer_decode()</a>.</p>

</div>
</div>
<a class="anchor" id="a563c84b5f368b3dd00d92ea903c5c33d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_CONCATENATED&#160;&#160;&#160;UINT32_C(0x08)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This flag enables decoding of concatenated files with file formats that allow concatenating compressed files as is. From the formats currently supported by liblzma, only the .xz format allows concatenated files. Concatenated files are not allowed with the legacy .lzma format.</p>
<p>This flag also affects the usage of the `action' argument for <a class="el" href="base_8h.html#a28cc09bc422d5ba1e0187c9f2af5d957" title="Encode or decode data.">lzma_code()</a>. When LZMA_CONCATENATED is used, <a class="el" href="base_8h.html#a28cc09bc422d5ba1e0187c9f2af5d957" title="Encode or decode data.">lzma_code()</a> won't return LZMA_STREAM_END unless LZMA_FINISH is used as `action'. Thus, the application has to set LZMA_FINISH in the same way as it does when encoding.</p>
<p>If LZMA_CONCATENATED is not used, the decoders still accept LZMA_FINISH as `action' for <a class="el" href="base_8h.html#a28cc09bc422d5ba1e0187c9f2af5d957" title="Encode or decode data.">lzma_code()</a>, but the usage of LZMA_FINISH isn't required. </p>

<p>Referenced by <a class="el" href="coder_8c.html#a6848d01092ac252b6270f739af63e202">coder_init()</a>.</p>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="a62c853cf7dbf008bdbd97b2685c3eabf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lzma_easy_encoder_memusage </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>preset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate approximate memory usage of easy encoder. </p>
<p>This function is a wrapper for <a class="el" href="filter_8h.html#a730f9391e85a5979bcd1b32643ae7176" title="Calculate approximate memory requirements for raw encoder.">lzma_raw_encoder_memusage()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preset</td><td>Compression preset (level and possible flags)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes of memory required for the given preset when encoding. If an error occurs, for example due to unsupported preset, UINT64_MAX is returned. </dd></dl>

<p>References <a class="el" href="structlzma__options__easy.html#adb657fb0fb484aea2d4a5bc02d1edd00">lzma_options_easy::filters</a>, <a class="el" href="easy__preset_8c.html#a995811b30166c539268d4c30d1e60b74">lzma_easy_preset()</a>, and <a class="el" href="filter_8h.html#a730f9391e85a5979bcd1b32643ae7176">lzma_raw_encoder_memusage()</a>.</p>

</div>
</div>
<a class="anchor" id="a3562055d26c18fad067a7c7516eaddf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lzma_easy_decoder_memusage </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>preset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate approximate decoder memory usage of a preset. </p>
<p>This function is a wrapper for <a class="el" href="filter_8h.html#a58511249ae9206d7de7c5d1f05842297" title="Calculate approximate memory requirements for raw decoder.">lzma_raw_decoder_memusage()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preset</td><td>Compression preset (level and possible flags)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes of memory required to decompress a file that was compressed using the given preset. If an error occurs, for example due to unsupported preset, UINT64_MAX is returned. </dd></dl>

<p>References <a class="el" href="structlzma__options__easy.html#adb657fb0fb484aea2d4a5bc02d1edd00">lzma_options_easy::filters</a>, <a class="el" href="easy__preset_8c.html#a995811b30166c539268d4c30d1e60b74">lzma_easy_preset()</a>, and <a class="el" href="filter_8h.html#a58511249ae9206d7de7c5d1f05842297">lzma_raw_decoder_memusage()</a>.</p>

</div>
</div>
<a class="anchor" id="acbdad999c544872f0f5d242f0d1a4ed4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_easy_encoder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__stream.html">lzma_stream</a> *&#160;</td>
          <td class="paramname"><em>strm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>preset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2lzma_2check_8h.html#a0a6100c719ac9aa49be3fdf7519e8c3f">lzma_check</a>&#160;</td>
          <td class="paramname"><em>check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize .xz Stream encoder using a preset number. </p>
<p>This function is intended for those who just want to use the basic features if liblzma (that is, most developers out there).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">preset</td><td>Compression preset to use. A preset consist of level number and zero or more flags. Usually flags aren't used, so preset is simply a number [0, 9] which match the options -0 ... -9 of the xz command line tool. Additional flags can be be set using bitwise-or with the preset level number, e.g. 6 | LZMA_PRESET_EXTREME. </td></tr>
    <tr><td class="paramname">check</td><td>Integrity check type to use. See check.h for available checks. The xz command line tool defaults to LZMA_CHECK_CRC64, which is a good choice if you are unsure. LZMA_CHECK_CRC32 is good too as long as the uncompressed file is not many gigabytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK: Initialization succeeded. Use <a class="el" href="base_8h.html#a28cc09bc422d5ba1e0187c9f2af5d957" title="Encode or decode data.">lzma_code()</a> to encode your data.<ul>
<li>LZMA_MEM_ERROR: Memory allocation failed.</li>
<li>LZMA_OPTIONS_ERROR: The given compression preset is not supported by this build of liblzma.</li>
<li>LZMA_UNSUPPORTED_CHECK: The given check type is not supported by this liblzma build.</li>
<li>LZMA_PROG_ERROR: One or more of the parameters have values that will never be valid. For example, strm == NULL.</li>
</ul>
</dd></dl>
<p>If initialization fails (return value is not LZMA_OK), all the memory allocated for *strm by liblzma is always freed. Thus, there is no need to call <a class="el" href="base_8h.html#a854ff37464ae1225febf14db1af43308" title="Free memory allocated for the coder data structures.">lzma_end()</a> after failed initialization.</p>
<p>If initialization succeeds, use <a class="el" href="base_8h.html#a28cc09bc422d5ba1e0187c9f2af5d957" title="Encode or decode data.">lzma_code()</a> to do the actual encoding. Valid values for `action' (the second argument of <a class="el" href="base_8h.html#a28cc09bc422d5ba1e0187c9f2af5d957" title="Encode or decode data.">lzma_code()</a>) are LZMA_RUN, LZMA_SYNC_FLUSH, LZMA_FULL_FLUSH, and LZMA_FINISH. In future, there may be compression levels or flags that don't support LZMA_SYNC_FLUSH. </p>

<p>References <a class="el" href="structlzma__options__easy.html#adb657fb0fb484aea2d4a5bc02d1edd00">lzma_options_easy::filters</a>, <a class="el" href="easy__preset_8c.html#a995811b30166c539268d4c30d1e60b74">lzma_easy_preset()</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eaa9ff6dfee36b7aba4fae60706d37425f">LZMA_OPTIONS_ERROR</a>, and <a class="el" href="container_8h.html#a1a97aec94c9fedd7646cfa51c4f4cd52">lzma_stream_encoder()</a>.</p>

</div>
</div>
<a class="anchor" id="a8cd00c448b2cce31398cec01ee30c2f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_easy_buffer_encode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>preset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2lzma_2check_8h.html#a0a6100c719ac9aa49be3fdf7519e8c3f">lzma_check</a>&#160;</td>
          <td class="paramname"><em>check</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>in_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>out_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>out_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-call .xz Stream encoding using a preset number. </p>
<p>The maximum required output buffer size can be calculated with <a class="el" href="container_8h.html#a66d4366a47b8332bff2a512f44f5c45e" title="Calculate output buffer size for single-call Stream encoder.">lzma_stream_buffer_bound()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preset</td><td>Compression preset to use. See the description in <a class="el" href="container_8h.html#acbdad999c544872f0f5d242f0d1a4ed4" title="Initialize .xz Stream encoder using a preset number.">lzma_easy_encoder()</a>. </td></tr>
    <tr><td class="paramname">check</td><td>Type of the integrity check to calculate from uncompressed data. </td></tr>
    <tr><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). </td></tr>
    <tr><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramname">in_size</td><td>Size of the input buffer </td></tr>
    <tr><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramname">out_pos</td><td>The next byte will be written to out[*out_pos]. *out_pos is updated only if encoding succeeds. </td></tr>
    <tr><td class="paramname">out_size</td><td>Size of the out buffer; the first byte into which no data is written to is out[out_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK: Encoding was successful.<ul>
<li>LZMA_BUF_ERROR: Not enough output buffer space.</li>
<li>LZMA_UNSUPPORTED_CHECK</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_DATA_ERROR</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

<p>References <a class="el" href="structlzma__options__easy.html#adb657fb0fb484aea2d4a5bc02d1edd00">lzma_options_easy::filters</a>, <a class="el" href="easy__preset_8c.html#a995811b30166c539268d4c30d1e60b74">lzma_easy_preset()</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eaa9ff6dfee36b7aba4fae60706d37425f">LZMA_OPTIONS_ERROR</a>, and <a class="el" href="container_8h.html#a558683e06e092cb3b9e7edb226d6a1b8">lzma_stream_buffer_encode()</a>.</p>

</div>
</div>
<a class="anchor" id="a1a97aec94c9fedd7646cfa51c4f4cd52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_stream_encoder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__stream.html">lzma_stream</a> *&#160;</td>
          <td class="paramname"><em>strm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlzma__filter.html">lzma_filter</a> *&#160;</td>
          <td class="paramname"><em>filters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2lzma_2check_8h.html#a0a6100c719ac9aa49be3fdf7519e8c3f">lzma_check</a>&#160;</td>
          <td class="paramname"><em>check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize .xz Stream encoder using a custom filter chain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to properly prepared <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> </td></tr>
    <tr><td class="paramname">filters</td><td>Array of filters. This must be terminated with filters[n].id = LZMA_VLI_UNKNOWN. See <a class="el" href="filter_8h.html" title="Common filter related types and functions.">filter.h</a> for more information. </td></tr>
    <tr><td class="paramname">check</td><td>Type of the integrity check to calculate from uncompressed data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK: Initialization was successful.<ul>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_UNSUPPORTED_CHECK</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

<p>References <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea7d24fb3c6c144d13bcb091195b8ebec1">LZMA_FINISH</a>, <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77eaab46f0d7c721f1ec377e9575eab2586f">LZMA_FULL_FLUSH</a>, <a class="el" href="common_8h.html#a844da62faaaf4c19a9a297129bc30a8c">lzma_next_strm_init</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea868472b76492afcaef54020a481890b1">LZMA_RUN</a>, and <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea14d75152afcda85d215e877fdd9c4170">LZMA_SYNC_FLUSH</a>.</p>

<p>Referenced by <a class="el" href="coder_8c.html#a6848d01092ac252b6270f739af63e202">coder_init()</a>, and <a class="el" href="easy__encoder_8c.html#a0cb362a067eb6612c44a8e03d6c50855">lzma_easy_encoder()</a>.</p>

</div>
</div>
<a class="anchor" id="a26fcc5bccdf3f862caa4c992d01e1a72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_alone_encoder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__stream.html">lzma_stream</a> *&#160;</td>
          <td class="paramname"><em>strm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlzma__options__lzma.html">lzma_options_lzma</a> *&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize .lzma encoder (legacy file format) </p>
<p>The .lzma format is sometimes called the LZMA_Alone format, which is the reason for the name of this function. The .lzma format supports only the LZMA1 filter. There is no support for integrity checks like CRC32.</p>
<p>Use this function if and only if you need to create files readable by legacy LZMA tools such as LZMA Utils 4.32.x. Moving to the .xz format is strongly recommended.</p>
<p>The valid action values for <a class="el" href="base_8h.html#a28cc09bc422d5ba1e0187c9f2af5d957" title="Encode or decode data.">lzma_code()</a> are LZMA_RUN and LZMA_FINISH. No kind of flushing is supported, because the file format doesn't make it possible.</p>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK<ul>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

<p>References <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea7d24fb3c6c144d13bcb091195b8ebec1">LZMA_FINISH</a>, <a class="el" href="common_8h.html#a844da62faaaf4c19a9a297129bc30a8c">lzma_next_strm_init</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, and <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea868472b76492afcaef54020a481890b1">LZMA_RUN</a>.</p>

<p>Referenced by <a class="el" href="coder_8c.html#a6848d01092ac252b6270f739af63e202">coder_init()</a>.</p>

</div>
</div>
<a class="anchor" id="a66d4366a47b8332bff2a512f44f5c45e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t lzma_stream_buffer_bound </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uncompressed_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate output buffer size for single-call Stream encoder. </p>
<p>When trying to compress uncompressible data, the encoded size will be slightly bigger than the input data. This function calculates how much output buffer space is required to be sure that <a class="el" href="container_8h.html#a558683e06e092cb3b9e7edb226d6a1b8" title="Single-call .xz Stream encoder.">lzma_stream_buffer_encode()</a> doesn't return LZMA_BUF_ERROR.</p>
<p>The calculated value is not exact, but it is guaranteed to be big enough. The actual maximum output space required may be slightly smaller (up to about 100 bytes). This should not be a problem in practice.</p>
<p>If the calculated maximum size doesn't fit into size_t or would make the Stream grow past LZMA_VLI_MAX (which should never happen in practice), zero is returned to indicate the error.</p>
<dl class="section note"><dt>Note</dt><dd>The limit calculated by this function applies only to single-call encoding. Multi-call encoding may (and probably will) have larger maximum expansion when encoding uncompressible data. Currently there is no function to calculate the maximum expansion of multi-call encoding. </dd></dl>

<p>References <a class="el" href="stream__buffer__encoder_8c.html#a6cf3bc89aed406bb48c785dca58ae9da">HEADERS_BOUND</a>, <a class="el" href="block_8h.html#a58ff73e2572b529f48cc590bfffe5b4f">lzma_block_buffer_bound()</a>, and <a class="el" href="vli_8h.html#a7b782528bd1934db7c020adbedb20ec9">LZMA_VLI_MAX</a>.</p>

</div>
</div>
<a class="anchor" id="a558683e06e092cb3b9e7edb226d6a1b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_stream_buffer_encode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__filter.html">lzma_filter</a> *&#160;</td>
          <td class="paramname"><em>filters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2lzma_2check_8h.html#a0a6100c719ac9aa49be3fdf7519e8c3f">lzma_check</a>&#160;</td>
          <td class="paramname"><em>check</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>in_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>out_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>out_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-call .xz Stream encoder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filters</td><td>Array of filters. This must be terminated with filters[n].id = LZMA_VLI_UNKNOWN. See <a class="el" href="filter_8h.html" title="Common filter related types and functions.">filter.h</a> for more information. </td></tr>
    <tr><td class="paramname">check</td><td>Type of the integrity check to calculate from uncompressed data. </td></tr>
    <tr><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). </td></tr>
    <tr><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramname">in_size</td><td>Size of the input buffer </td></tr>
    <tr><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramname">out_pos</td><td>The next byte will be written to out[*out_pos]. *out_pos is updated only if encoding succeeds. </td></tr>
    <tr><td class="paramname">out_size</td><td>Size of the out buffer; the first byte into which no data is written to is out[out_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK: Encoding was successful.<ul>
<li>LZMA_BUF_ERROR: Not enough output buffer space.</li>
<li>LZMA_UNSUPPORTED_CHECK</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_DATA_ERROR</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

<p>References <a class="el" href="structlzma__stream__flags.html#aaa65ed7a55a098f829f04dba25d0f212">lzma_stream_flags::backward_size</a>, <a class="el" href="coder_8c.html#a5c94b0defea7996f245faec2693056cb">check</a>, <a class="el" href="coder_8c.html#a9325236d5759d4eaadcba08a6bb5c96f">filters</a>, <a class="el" href="block_8h.html#a41e080db33169819f985595d48a157bc">lzma_block_buffer_encode()</a>, <a class="el" href="block_8h.html#a412d5605280fa29befae1b89e344bf30">lzma_block_unpadded_size()</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea9ca0ecb62459bdc84d6af47d16b23ae5">LZMA_BUF_ERROR</a>, <a class="el" href="api_2lzma_2check_8h.html#acd221ababe30230d9647aab469ad80cb">LZMA_CHECK_ID_MAX</a>, <a class="el" href="api_2lzma_2check_8h.html#ae9391ed2acfad0ce9357b68c608f07d8">lzma_check_is_supported()</a>, <a class="el" href="api_2lzma_2index_8h.html#aad24f1d4784b7c665b27ae91b52d3bd1">lzma_index_append()</a>, <a class="el" href="api_2lzma_2index_8h.html#add1ef06dec8a26d08ae8651cff0fd8d6">lzma_index_buffer_encode()</a>, <a class="el" href="api_2lzma_2index_8h.html#a469f89689529ea250969bb64f80ab874">lzma_index_end()</a>, <a class="el" href="api_2lzma_2index_8h.html#ad17c5c45cd2692cc296261a91a4690f1">lzma_index_init()</a>, <a class="el" href="api_2lzma_2index_8h.html#a669ed1a82b1941217cfbb07e7826afc2">lzma_index_size()</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea567e1464feca03900a5425fb45b2f5b6">LZMA_MEM_ERROR</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea2dac8d451cb38da8550653d0d7be4ec2">LZMA_PROG_ERROR</a>, <a class="el" href="stream__flags_8h.html#a438249a75ea8da952a7474b92bfe7b7a">lzma_stream_footer_encode()</a>, <a class="el" href="stream__flags_8h.html#a2ebb8d6dff23daeb3de398913b845eff">lzma_stream_header_encode()</a>, <a class="el" href="stream__flags_8h.html#ada7e0a4f5e7146f547962cb9e9ef08ee">LZMA_STREAM_HEADER_SIZE</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea989f393a1772d85bf545a9da48fc7ac2">LZMA_UNSUPPORTED_CHECK</a>, <a class="el" href="common_8h.html#a3e1bf9f33b917e883b886b8a10458d66">return_if_error</a>, <a class="el" href="structlzma__block.html#a17362d38d1946dd16a9686557ec19a94">lzma_block::uncompressed_size</a>, <a class="el" href="structlzma__block.html#ac3936a5b0ec3f9b8f9c7ad68e7d149a5">lzma_block::version</a>, and <a class="el" href="structlzma__stream__flags.html#a61e9151869d5b77c868aaa4958e74d10">lzma_stream_flags::version</a>.</p>

<p>Referenced by <a class="el" href="easy__buffer__encoder_8c.html#a802ea8c78e3fe12308c79b3ea385f643">lzma_easy_buffer_encode()</a>.</p>

</div>
</div>
<a class="anchor" id="a02b7683ef98d8049788961370a8b28c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_stream_decoder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__stream.html">lzma_stream</a> *&#160;</td>
          <td class="paramname"><em>strm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>memlimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize .xz Stream decoder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to properly prepared <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> </td></tr>
    <tr><td class="paramname">memlimit</td><td>Memory usage limit as bytes. Use UINT64_MAX to effectively disable the limiter. </td></tr>
    <tr><td class="paramname">flags</td><td>Bitwise-or of zero or more of the decoder flags: LZMA_TELL_NO_CHECK, LZMA_TELL_UNSUPPORTED_CHECK, LZMA_TELL_ANY_CHECK, LZMA_CONCATENATED</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK: Initialization was successful.<ul>
<li>LZMA_MEM_ERROR: Cannot allocate memory.</li>
<li>LZMA_OPTIONS_ERROR: Unsupported flags</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

<p>References <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea7d24fb3c6c144d13bcb091195b8ebec1">LZMA_FINISH</a>, <a class="el" href="common_8h.html#a844da62faaaf4c19a9a297129bc30a8c">lzma_next_strm_init</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, and <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea868472b76492afcaef54020a481890b1">LZMA_RUN</a>.</p>

<p>Referenced by <a class="el" href="coder_8c.html#a6848d01092ac252b6270f739af63e202">coder_init()</a>.</p>

</div>
</div>
<a class="anchor" id="a21cbebf2771617bb1e956385cfb353e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_auto_decoder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__stream.html">lzma_stream</a> *&#160;</td>
          <td class="paramname"><em>strm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>memlimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode .xz Streams and .lzma files with autodetection. </p>
<p>This decoder autodetects between the .xz and .lzma file formats, and calls <a class="el" href="container_8h.html#a02b7683ef98d8049788961370a8b28c0" title="Initialize .xz Stream decoder.">lzma_stream_decoder()</a> or <a class="el" href="container_8h.html#a5f43c3a1035e5a226dcd298f4162b861" title="Initialize .lzma decoder (legacy file format)">lzma_alone_decoder()</a> once the type of the input file has been detected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to properly prepared <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> </td></tr>
    <tr><td class="paramname">memlimit</td><td>Memory usage limit as bytes. Use UINT64_MAX to effectively disable the limiter. </td></tr>
    <tr><td class="paramname">flags</td><td>Bitwise-or of flags, or zero for no flags.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK: Initialization was successful.<ul>
<li>LZMA_MEM_ERROR: Cannot allocate memory.</li>
<li>LZMA_OPTIONS_ERROR: Unsupported flags</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

<p>References <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea7d24fb3c6c144d13bcb091195b8ebec1">LZMA_FINISH</a>, <a class="el" href="common_8h.html#a844da62faaaf4c19a9a297129bc30a8c">lzma_next_strm_init</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, and <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea868472b76492afcaef54020a481890b1">LZMA_RUN</a>.</p>

</div>
</div>
<a class="anchor" id="a5f43c3a1035e5a226dcd298f4162b861"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_alone_decoder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__stream.html">lzma_stream</a> *&#160;</td>
          <td class="paramname"><em>strm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>memlimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize .lzma decoder (legacy file format) </p>
<p>Valid `action' arguments to <a class="el" href="base_8h.html#a28cc09bc422d5ba1e0187c9f2af5d957" title="Encode or decode data.">lzma_code()</a> are LZMA_RUN and LZMA_FINISH. There is no need to use LZMA_FINISH, but allowing it may simplify certain types of applications.</p>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK<ul>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

<p>References <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea7d24fb3c6c144d13bcb091195b8ebec1">LZMA_FINISH</a>, <a class="el" href="common_8h.html#a844da62faaaf4c19a9a297129bc30a8c">lzma_next_strm_init</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, and <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea868472b76492afcaef54020a481890b1">LZMA_RUN</a>.</p>

<p>Referenced by <a class="el" href="coder_8c.html#a6848d01092ac252b6270f739af63e202">coder_init()</a>.</p>

</div>
</div>
<a class="anchor" id="adf823f70e6344e1e393e61b74818a1b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_stream_buffer_decode </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>memlimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>in_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>in_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>out_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>out_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-call .xz Stream decoder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memlimit</td><td>Pointer to how much memory the decoder is allowed to allocate. The value pointed by this pointer is modified if and only if LZMA_MEMLIMIT_ERROR is returned. </td></tr>
    <tr><td class="paramname">flags</td><td>Bitwise-or of zero or more of the decoder flags: LZMA_TELL_NO_CHECK, LZMA_TELL_UNSUPPORTED_CHECK, LZMA_CONCATENATED. Note that LZMA_TELL_ANY_CHECK is not allowed and will return LZMA_PROG_ERROR. </td></tr>
    <tr><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). </td></tr>
    <tr><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramname">in_pos</td><td>The next byte will be read from in[*in_pos]. *in_pos is updated only if decoding succeeds. </td></tr>
    <tr><td class="paramname">in_size</td><td>Size of the input buffer; the first byte that won't be read is in[in_size]. </td></tr>
    <tr><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramname">out_pos</td><td>The next byte will be written to out[*out_pos]. *out_pos is updated only if decoding succeeds. </td></tr>
    <tr><td class="paramname">out_size</td><td>Size of the out buffer; the first byte into which no data is written to is out[out_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK: Decoding was successful.<ul>
<li>LZMA_FORMAT_ERROR</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_DATA_ERROR</li>
<li>LZMA_NO_CHECK: This can be returned only if using the LZMA_TELL_NO_CHECK flag.</li>
<li>LZMA_UNSUPPORTED_CHECK: This can be returned only if using the LZMA_TELL_UNSUPPORTED_CHECK flag.</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_MEMLIMIT_ERROR: Memory usage limit was reached. The minimum required memlimit value was stored to *memlimit.</li>
<li>LZMA_BUF_ERROR: Output buffer was too small.</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

<p>References <a class="el" href="structlzma__next__coder__s.html#a0d736e310d786b85d83f151f26b85440">lzma_next_coder_s::code</a>, <a class="el" href="structlzma__next__coder__s.html#ac2064cebf4a0f2f9abb2e090348dae4a">lzma_next_coder_s::coder</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea9ca0ecb62459bdc84d6af47d16b23ae5">LZMA_BUF_ERROR</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea3aa72729a844790e39b4e1101a731dfb">LZMA_DATA_ERROR</a>, <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea7d24fb3c6c144d13bcb091195b8ebec1">LZMA_FINISH</a>, <a class="el" href="common_8h.html#a1fca27f3d292f89fffbf7162d34a5bc3">LZMA_NEXT_CODER_INIT</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea2dac8d451cb38da8550653d0d7be4ec2">LZMA_PROG_ERROR</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea91ecc6fab14c13ad36224afbcb4e55c4">LZMA_STREAM_END</a>, <a class="el" href="container_8h.html#a0bdde702a77ff42b90a99c0bf4147b6b">LZMA_TELL_ANY_CHECK</a>, and <a class="el" href="structlzma__next__coder__s.html#a64f0d17359f6cf41d5a187e43dac9fb3">lzma_next_coder_s::memconfig</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jun 5 2014 14:24:08 for XZ Utils by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
