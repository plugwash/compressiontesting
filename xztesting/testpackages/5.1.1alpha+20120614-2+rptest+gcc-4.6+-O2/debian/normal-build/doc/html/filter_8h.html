<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>XZ Utils: liblzma/api/lzma/filter.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">XZ Utils
   &#160;<span id="projectnumber">5.1.0alpha</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2e0898c272e1f0f93c8ef15f5da2a912.html">liblzma</a></li><li class="navelem"><a class="el" href="dir_3c7592c36b11e0fd373edb6a27c72b1d.html">api</a></li><li class="navelem"><a class="el" href="dir_48cf7e51417fe935412ca5117cfff3c4.html">lzma</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">filter.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Common filter related types and functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__filter.html">lzma_filter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter options.  <a href="structlzma__filter.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab33c0cc1728bf390e5b84f8bce1928ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#ab33c0cc1728bf390e5b84f8bce1928ba">LZMA_FILTERS_MAX</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:ab33c0cc1728bf390e5b84f8bce1928ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of filters in a chain.  <a href="#ab33c0cc1728bf390e5b84f8bce1928ba"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3db3c36cd6e57658a74c53e4daa2bef6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#abbc819c74b484c846825ae1388a50a59">lzma_bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#a3db3c36cd6e57658a74c53e4daa2bef6">lzma_filter_encoder_is_supported</a> (<a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> <a class="el" href="filter__common_8c.html#a3ee597b96b2ff619e515fac79a1ba1c5">id</a>) lzma_nothrow lzma_attr_const</td></tr>
<tr class="memdesc:a3db3c36cd6e57658a74c53e4daa2bef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the given Filter ID is supported for encoding.  <a href="#a3db3c36cd6e57658a74c53e4daa2bef6"></a><br/></td></tr>
<tr class="memitem:acab0c67bf5b3a76f2b474c8e1da98938"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#abbc819c74b484c846825ae1388a50a59">lzma_bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#acab0c67bf5b3a76f2b474c8e1da98938">lzma_filter_decoder_is_supported</a> (<a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> <a class="el" href="filter__common_8c.html#a3ee597b96b2ff619e515fac79a1ba1c5">id</a>) lzma_nothrow lzma_attr_const</td></tr>
<tr class="memdesc:acab0c67bf5b3a76f2b474c8e1da98938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the given Filter ID is supported for decoding.  <a href="#acab0c67bf5b3a76f2b474c8e1da98938"></a><br/></td></tr>
<tr class="memitem:a46c86072a2fcb5dd7ef17247c6fbacb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#a46c86072a2fcb5dd7ef17247c6fbacb9">lzma_filters_copy</a> (const <a class="el" href="structlzma__filter.html">lzma_filter</a> *src, <a class="el" href="structlzma__filter.html">lzma_filter</a> *dest, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator) lzma_nothrow</td></tr>
<tr class="memdesc:a46c86072a2fcb5dd7ef17247c6fbacb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the filters array.  <a href="#a46c86072a2fcb5dd7ef17247c6fbacb9"></a><br/></td></tr>
<tr class="memitem:a730f9391e85a5979bcd1b32643ae7176"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#a730f9391e85a5979bcd1b32643ae7176">lzma_raw_encoder_memusage</a> (const <a class="el" href="structlzma__filter.html">lzma_filter</a> *<a class="el" href="coder_8c.html#a9325236d5759d4eaadcba08a6bb5c96f">filters</a>) lzma_nothrow lzma_attr_pure</td></tr>
<tr class="memdesc:a730f9391e85a5979bcd1b32643ae7176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate approximate memory requirements for raw encoder.  <a href="#a730f9391e85a5979bcd1b32643ae7176"></a><br/></td></tr>
<tr class="memitem:a58511249ae9206d7de7c5d1f05842297"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#a58511249ae9206d7de7c5d1f05842297">lzma_raw_decoder_memusage</a> (const <a class="el" href="structlzma__filter.html">lzma_filter</a> *<a class="el" href="coder_8c.html#a9325236d5759d4eaadcba08a6bb5c96f">filters</a>) lzma_nothrow lzma_attr_pure</td></tr>
<tr class="memdesc:a58511249ae9206d7de7c5d1f05842297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate approximate memory requirements for raw decoder.  <a href="#a58511249ae9206d7de7c5d1f05842297"></a><br/></td></tr>
<tr class="memitem:a2368e4129032345eb0738b0c6e085703"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#a2368e4129032345eb0738b0c6e085703">lzma_raw_encoder</a> (<a class="el" href="structlzma__stream.html">lzma_stream</a> *<a class="el" href="coder_8c.html#a048a6ae6a7da50de565b15d52ea9fafe">strm</a>, const <a class="el" href="structlzma__filter.html">lzma_filter</a> *<a class="el" href="coder_8c.html#a9325236d5759d4eaadcba08a6bb5c96f">filters</a>) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:a2368e4129032345eb0738b0c6e085703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize raw encoder.  <a href="#a2368e4129032345eb0738b0c6e085703"></a><br/></td></tr>
<tr class="memitem:ae77b3b6c5eccd9d77bbafef0a8a203c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#ae77b3b6c5eccd9d77bbafef0a8a203c1">lzma_raw_decoder</a> (<a class="el" href="structlzma__stream.html">lzma_stream</a> *<a class="el" href="coder_8c.html#a048a6ae6a7da50de565b15d52ea9fafe">strm</a>, const <a class="el" href="structlzma__filter.html">lzma_filter</a> *<a class="el" href="coder_8c.html#a9325236d5759d4eaadcba08a6bb5c96f">filters</a>) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:ae77b3b6c5eccd9d77bbafef0a8a203c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize raw decoder.  <a href="#ae77b3b6c5eccd9d77bbafef0a8a203c1"></a><br/></td></tr>
<tr class="memitem:a4a8fd969df001e449ebe4421ab33bba5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#a4a8fd969df001e449ebe4421ab33bba5">lzma_filters_update</a> (<a class="el" href="structlzma__stream.html">lzma_stream</a> *<a class="el" href="coder_8c.html#a048a6ae6a7da50de565b15d52ea9fafe">strm</a>, const <a class="el" href="structlzma__filter.html">lzma_filter</a> *<a class="el" href="coder_8c.html#a9325236d5759d4eaadcba08a6bb5c96f">filters</a>) lzma_nothrow</td></tr>
<tr class="memdesc:a4a8fd969df001e449ebe4421ab33bba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the filter chain in the encoder.  <a href="#a4a8fd969df001e449ebe4421ab33bba5"></a><br/></td></tr>
<tr class="memitem:ab02d27c3596ff19ae2560d26eb43f370"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#ab02d27c3596ff19ae2560d26eb43f370">lzma_raw_buffer_encode</a> (const <a class="el" href="structlzma__filter.html">lzma_filter</a> *<a class="el" href="coder_8c.html#a9325236d5759d4eaadcba08a6bb5c96f">filters</a>, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator, const uint8_t *in, size_t in_size, uint8_t *out, size_t *out_pos, size_t out_size) lzma_nothrow</td></tr>
<tr class="memdesc:ab02d27c3596ff19ae2560d26eb43f370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-call raw encoder.  <a href="#ab02d27c3596ff19ae2560d26eb43f370"></a><br/></td></tr>
<tr class="memitem:aaab93745c73189ce4dd5afcdb78c80ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#aaab93745c73189ce4dd5afcdb78c80ce">lzma_raw_buffer_decode</a> (const <a class="el" href="structlzma__filter.html">lzma_filter</a> *<a class="el" href="coder_8c.html#a9325236d5759d4eaadcba08a6bb5c96f">filters</a>, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator, const uint8_t *in, size_t *in_pos, size_t in_size, uint8_t *out, size_t *out_pos, size_t out_size) lzma_nothrow</td></tr>
<tr class="memdesc:aaab93745c73189ce4dd5afcdb78c80ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-call raw decoder.  <a href="#aaab93745c73189ce4dd5afcdb78c80ce"></a><br/></td></tr>
<tr class="memitem:aee038818cf7bbe044c3f7a7c86998c1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#aee038818cf7bbe044c3f7a7c86998c1b">lzma_properties_size</a> (uint32_t *size, const <a class="el" href="structlzma__filter.html">lzma_filter</a> *filter) lzma_nothrow</td></tr>
<tr class="memdesc:aee038818cf7bbe044c3f7a7c86998c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the Filter Properties field.  <a href="#aee038818cf7bbe044c3f7a7c86998c1b"></a><br/></td></tr>
<tr class="memitem:a8e00887086df5a44084ac22e48415de3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#a8e00887086df5a44084ac22e48415de3">lzma_properties_encode</a> (const <a class="el" href="structlzma__filter.html">lzma_filter</a> *filter, uint8_t *props) lzma_nothrow</td></tr>
<tr class="memdesc:a8e00887086df5a44084ac22e48415de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode the Filter Properties field.  <a href="#a8e00887086df5a44084ac22e48415de3"></a><br/></td></tr>
<tr class="memitem:acec30e78c7cbe56b00f7671b6fcf2afc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#acec30e78c7cbe56b00f7671b6fcf2afc">lzma_properties_decode</a> (<a class="el" href="structlzma__filter.html">lzma_filter</a> *filter, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator, const uint8_t *props, size_t props_size) lzma_nothrow</td></tr>
<tr class="memdesc:acec30e78c7cbe56b00f7671b6fcf2afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the Filter Properties field.  <a href="#acec30e78c7cbe56b00f7671b6fcf2afc"></a><br/></td></tr>
<tr class="memitem:a996c9c21840ed54e37bd1f664a79d940"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#a996c9c21840ed54e37bd1f664a79d940">lzma_filter_flags_size</a> (uint32_t *size, const <a class="el" href="structlzma__filter.html">lzma_filter</a> *filter) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:a996c9c21840ed54e37bd1f664a79d940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate encoded size of a Filter Flags field.  <a href="#a996c9c21840ed54e37bd1f664a79d940"></a><br/></td></tr>
<tr class="memitem:a96f23309bc21398fece18c00ebe7db98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#a96f23309bc21398fece18c00ebe7db98">lzma_filter_flags_encode</a> (const <a class="el" href="structlzma__filter.html">lzma_filter</a> *filter, uint8_t *out, size_t *out_pos, size_t out_size) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:a96f23309bc21398fece18c00ebe7db98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode Filter Flags into given buffer.  <a href="#a96f23309bc21398fece18c00ebe7db98"></a><br/></td></tr>
<tr class="memitem:aadadfde2b6fd2d4b247a277423a67d32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#aadadfde2b6fd2d4b247a277423a67d32">lzma_filter_flags_decode</a> (<a class="el" href="structlzma__filter.html">lzma_filter</a> *filter, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator, const uint8_t *in, size_t *in_pos, size_t in_size) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:aadadfde2b6fd2d4b247a277423a67d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode Filter Flags from given buffer.  <a href="#aadadfde2b6fd2d4b247a277423a67d32"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Common filter related types and functions. </p>
</div><h2>Macro Definition Documentation</h2>
<a class="anchor" id="ab33c0cc1728bf390e5b84f8bce1928ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_FILTERS_MAX&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of filters in a chain. </p>
<p>A filter chain can have 1-4 filters, of which three are allowed to change the size of the data. Usually only one or two filters are needed. </p>

<p>Referenced by <a class="el" href="coder_8h.html#a8884012fc28d467d3429070f270f7171">coder_add_filter()</a>, <a class="el" href="block__header__decoder_8c.html#ac85bbf9df6709081a8112c8826b4997b">lzma_block_header_decode()</a>, <a class="el" href="block__header__encoder_8c.html#a01a1e06f40b56d8ca61ac577e77a4fec">lzma_block_header_encode()</a>, <a class="el" href="block__header__encoder_8c.html#a7d60c35cba687af87e3c3a83639b2f6d">lzma_block_header_size()</a>, <a class="el" href="filter__common_8c.html#a81cd5593eb33e5e62a0fd5112e87d831">lzma_filters_copy()</a>, <a class="el" href="filter__encoder_8c.html#adcde5a9917d1ca033f6c1cc35c9be4fc">lzma_filters_update()</a>, and <a class="el" href="list_8c.html#ae8bf55be793e1ad58bc179ac19168c90">parse_block_header()</a>.</p>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="a3db3c36cd6e57658a74c53e4daa2bef6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#abbc819c74b484c846825ae1388a50a59">lzma_bool</a> lzma_filter_encoder_is_supported </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the given Filter ID is supported for encoding. </p>
<p>Return true if the give Filter ID is supported for encoding by this liblzma build. Otherwise false is returned.</p>
<p>There is no way to list which filters are available in this particular liblzma version and build. It would be useless, because the application couldn't know what kind of options the filter would need. </p>

</div>
</div>
<a class="anchor" id="acab0c67bf5b3a76f2b474c8e1da98938"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#abbc819c74b484c846825ae1388a50a59">lzma_bool</a> lzma_filter_decoder_is_supported </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the given Filter ID is supported for decoding. </p>
<p>Return true if the give Filter ID is supported for decoding by this liblzma build. Otherwise false is returned. </p>

</div>
</div>
<a class="anchor" id="a46c86072a2fcb5dd7ef17247c6fbacb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_filters_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlzma__filter.html">lzma_filter</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__filter.html">lzma_filter</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the filters array. </p>
<p>Copy the Filter IDs and filter-specific options from src to dest. Up to LZMA_FILTERS_MAX filters are copied, plus the terminating .id == LZMA_VLI_UNKNOWN. Thus, dest should have at least LZMA_FILTERS_MAX + 1 elements space unless the caller knows that src is smaller than that.</p>
<p>Unless the filter-specific options is NULL, the Filter ID has to be supported by liblzma, because liblzma needs to know the size of every filter-specific options structure. The filter-specific options are not validated. If options is NULL, any unsupported Filter IDs are copied without returning an error.</p>
<p>Old filter-specific options in dest are not freed, so dest doesn't need to be initialized by the caller in any way.</p>
<p>If an error occurs, memory possibly already allocated by this function is always freed.</p>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK<ul>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_OPTIONS_ERROR: Unsupported Filter ID and its options is not NULL.</li>
<li>LZMA_PROG_ERROR: src or dest is NULL. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="common_8h.html#ac58f96267a4f66bb15db736968b98008">lzma_alloc()</a>, <a class="el" href="filter_8h.html#ab33c0cc1728bf390e5b84f8bce1928ba">LZMA_FILTERS_MAX</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea567e1464feca03900a5425fb45b2f5b6">LZMA_MEM_ERROR</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eaa9ff6dfee36b7aba4fae60706d37425f">LZMA_OPTIONS_ERROR</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea2dac8d451cb38da8550653d0d7be4ec2">LZMA_PROG_ERROR</a>, <a class="el" href="vli_8h.html#a5a4b28254a30c859018b896ed371d69a">LZMA_VLI_UNKNOWN</a>, and <a class="el" href="filter__common_8c.html#ae3be9ce6129a435b24496c57bc8141a6">options_size</a>.</p>

</div>
</div>
<a class="anchor" id="a730f9391e85a5979bcd1b32643ae7176"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lzma_raw_encoder_memusage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlzma__filter.html">lzma_filter</a> *&#160;</td>
          <td class="paramname"><em>filters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate approximate memory requirements for raw encoder. </p>
<p>This function can be used to calculate the memory requirements for Block and Stream encoders too because Block and Stream encoders don't need significantly more memory than raw encoder.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filters</td><td>Array of filters terminated with .id == LZMA_VLI_UNKNOWN.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes of memory required for the given filter chain when encoding. If an error occurs, for example due to unsupported filter chain, UINT64_MAX is returned. </dd></dl>

<p>Referenced by <a class="el" href="easy__encoder__memusage_8c.html#a48e0943898f0b9b83f3070b101620df5">lzma_easy_encoder_memusage()</a>, and <a class="el" href="filter__encoder_8c.html#adcde5a9917d1ca033f6c1cc35c9be4fc">lzma_filters_update()</a>.</p>

</div>
</div>
<a class="anchor" id="a58511249ae9206d7de7c5d1f05842297"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lzma_raw_decoder_memusage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlzma__filter.html">lzma_filter</a> *&#160;</td>
          <td class="paramname"><em>filters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate approximate memory requirements for raw decoder. </p>
<p>This function can be used to calculate the memory requirements for Block and Stream decoders too because Block and Stream decoders don't need significantly more memory than raw decoder.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filters</td><td>Array of filters terminated with .id == LZMA_VLI_UNKNOWN.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes of memory required for the given filter chain when decoding. If an error occurs, for example due to unsupported filter chain, UINT64_MAX is returned. </dd></dl>

<p>Referenced by <a class="el" href="easy__decoder__memusage_8c.html#a729d0e470e873745f54a02d7fc4451f3">lzma_easy_decoder_memusage()</a>, and <a class="el" href="list_8c.html#ae8bf55be793e1ad58bc179ac19168c90">parse_block_header()</a>.</p>

</div>
</div>
<a class="anchor" id="a2368e4129032345eb0738b0c6e085703"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_raw_encoder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__stream.html">lzma_stream</a> *&#160;</td>
          <td class="paramname"><em>strm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlzma__filter.html">lzma_filter</a> *&#160;</td>
          <td class="paramname"><em>filters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize raw encoder. </p>
<p>This function may be useful when implementing custom file formats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to properly prepared <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> </td></tr>
    <tr><td class="paramname">filters</td><td>Array of <a class="el" href="structlzma__filter.html" title="Filter options.">lzma_filter</a> structures. The end of the array must be marked with .id = LZMA_VLI_UNKNOWN.</td></tr>
  </table>
  </dd>
</dl>
<p>The `action' with <a class="el" href="base_8h.html#a28cc09bc422d5ba1e0187c9f2af5d957" title="Encode or decode data.">lzma_code()</a> can be LZMA_RUN, LZMA_SYNC_FLUSH (if the filter chain supports it), or LZMA_FINISH.</p>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK<ul>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

<p>References <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea7d24fb3c6c144d13bcb091195b8ebec1">LZMA_FINISH</a>, <a class="el" href="common_8h.html#a844da62faaaf4c19a9a297129bc30a8c">lzma_next_strm_init</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea868472b76492afcaef54020a481890b1">LZMA_RUN</a>, and <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea14d75152afcda85d215e877fdd9c4170">LZMA_SYNC_FLUSH</a>.</p>

<p>Referenced by <a class="el" href="coder_8c.html#a6848d01092ac252b6270f739af63e202">coder_init()</a>.</p>

</div>
</div>
<a class="anchor" id="ae77b3b6c5eccd9d77bbafef0a8a203c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_raw_decoder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__stream.html">lzma_stream</a> *&#160;</td>
          <td class="paramname"><em>strm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlzma__filter.html">lzma_filter</a> *&#160;</td>
          <td class="paramname"><em>filters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize raw decoder. </p>
<p>The initialization of raw decoder goes similarly to raw encoder.</p>
<p>The `action' with <a class="el" href="base_8h.html#a28cc09bc422d5ba1e0187c9f2af5d957" title="Encode or decode data.">lzma_code()</a> can be LZMA_RUN or LZMA_FINISH. Using LZMA_FINISH is not required, it is supported just for convenience.</p>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK<ul>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

<p>References <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea7d24fb3c6c144d13bcb091195b8ebec1">LZMA_FINISH</a>, <a class="el" href="common_8h.html#a844da62faaaf4c19a9a297129bc30a8c">lzma_next_strm_init</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, and <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea868472b76492afcaef54020a481890b1">LZMA_RUN</a>.</p>

<p>Referenced by <a class="el" href="coder_8c.html#a6848d01092ac252b6270f739af63e202">coder_init()</a>.</p>

</div>
</div>
<a class="anchor" id="a4a8fd969df001e449ebe4421ab33bba5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_filters_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__stream.html">lzma_stream</a> *&#160;</td>
          <td class="paramname"><em>strm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlzma__filter.html">lzma_filter</a> *&#160;</td>
          <td class="paramname"><em>filters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the filter chain in the encoder. </p>
<p>This function is for advanced users only. This function has two slightly different purposes:</p>
<ul>
<li>After LZMA_FULL_FLUSH when using Stream encoder: Set a new filter chain, which will be used starting from the next Block.</li>
</ul>
<ul>
<li>After LZMA_SYNC_FLUSH using Raw, Block, or Stream encoder: Change the filter-specific options in the middle of encoding. The actual filters in the chain (Filter IDs) cannot be changed. In the future, it might become possible to change the filter options without using LZMA_SYNC_FLUSH.</li>
</ul>
<p>While rarely useful, this function may be called also when no data has been compressed yet. In that case, this function will behave as if LZMA_FULL_FLUSH (Stream encoder) or LZMA_SYNC_FLUSH (Raw or Block encoder) had been used right before calling this function.</p>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK<ul>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_MEMLIMIT_ERROR</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

<p>References <a class="el" href="structlzma__filter.html#aef1d9709759f39e61db77547b2326929">lzma_filter::id</a>, <a class="el" href="filter_8h.html#ab33c0cc1728bf390e5b84f8bce1928ba">LZMA_FILTERS_MAX</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eaa9ff6dfee36b7aba4fae60706d37425f">LZMA_OPTIONS_ERROR</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea2dac8d451cb38da8550653d0d7be4ec2">LZMA_PROG_ERROR</a>, <a class="el" href="filter_8h.html#a730f9391e85a5979bcd1b32643ae7176">lzma_raw_encoder_memusage()</a>, and <a class="el" href="vli_8h.html#a5a4b28254a30c859018b896ed371d69a">LZMA_VLI_UNKNOWN</a>.</p>

</div>
</div>
<a class="anchor" id="ab02d27c3596ff19ae2560d26eb43f370"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_raw_buffer_encode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlzma__filter.html">lzma_filter</a> *&#160;</td>
          <td class="paramname"><em>filters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>in_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>out_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>out_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-call raw encoder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filters</td><td>Array of <a class="el" href="structlzma__filter.html" title="Filter options.">lzma_filter</a> structures. The end of the array must be marked with .id = LZMA_VLI_UNKNOWN. </td></tr>
    <tr><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). </td></tr>
    <tr><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramname">in_size</td><td>Size of the input buffer </td></tr>
    <tr><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramname">out_pos</td><td>The next byte will be written to out[*out_pos]. *out_pos is updated only if encoding succeeds. </td></tr>
    <tr><td class="paramname">out_size</td><td>Size of the out buffer; the first byte into which no data is written to is out[out_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK: Encoding was successful.<ul>
<li>LZMA_BUF_ERROR: Not enough output buffer space.</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_DATA_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>There is no function to calculate how big output buffer would surely be big enough. (<a class="el" href="container_8h.html#a66d4366a47b8332bff2a512f44f5c45e" title="Calculate output buffer size for single-call Stream encoder.">lzma_stream_buffer_bound()</a> works only for <a class="el" href="container_8h.html#a558683e06e092cb3b9e7edb226d6a1b8" title="Single-call .xz Stream encoder.">lzma_stream_buffer_encode()</a>; raw encoder won't necessarily meet that bound.) </dd></dl>

<p>References <a class="el" href="structlzma__next__coder__s.html#a0d736e310d786b85d83f151f26b85440">lzma_next_coder_s::code</a>, <a class="el" href="structlzma__next__coder__s.html#ac2064cebf4a0f2f9abb2e090348dae4a">lzma_next_coder_s::coder</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea9ca0ecb62459bdc84d6af47d16b23ae5">LZMA_BUF_ERROR</a>, <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea7d24fb3c6c144d13bcb091195b8ebec1">LZMA_FINISH</a>, <a class="el" href="common_8h.html#a1fca27f3d292f89fffbf7162d34a5bc3">LZMA_NEXT_CODER_INIT</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea2dac8d451cb38da8550653d0d7be4ec2">LZMA_PROG_ERROR</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea91ecc6fab14c13ad36224afbcb4e55c4">LZMA_STREAM_END</a>, and <a class="el" href="common_8h.html#a3e1bf9f33b917e883b886b8a10458d66">return_if_error</a>.</p>

</div>
</div>
<a class="anchor" id="aaab93745c73189ce4dd5afcdb78c80ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_raw_buffer_decode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlzma__filter.html">lzma_filter</a> *&#160;</td>
          <td class="paramname"><em>filters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>in_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>in_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>out_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>out_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-call raw decoder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filters</td><td>Array of <a class="el" href="structlzma__filter.html" title="Filter options.">lzma_filter</a> structures. The end of the array must be marked with .id = LZMA_VLI_UNKNOWN. </td></tr>
    <tr><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). </td></tr>
    <tr><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramname">in_pos</td><td>The next byte will be read from in[*in_pos]. *in_pos is updated only if decoding succeeds. </td></tr>
    <tr><td class="paramname">in_size</td><td>Size of the input buffer; the first byte that won't be read is in[in_size]. </td></tr>
    <tr><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramname">out_pos</td><td>The next byte will be written to out[*out_pos]. *out_pos is updated only if encoding succeeds. </td></tr>
    <tr><td class="paramname">out_size</td><td>Size of the out buffer; the first byte into which no data is written to is out[out_size]. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structlzma__next__coder__s.html#a0d736e310d786b85d83f151f26b85440">lzma_next_coder_s::code</a>, <a class="el" href="structlzma__next__coder__s.html#ac2064cebf4a0f2f9abb2e090348dae4a">lzma_next_coder_s::coder</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea9ca0ecb62459bdc84d6af47d16b23ae5">LZMA_BUF_ERROR</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea3aa72729a844790e39b4e1101a731dfb">LZMA_DATA_ERROR</a>, <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea7d24fb3c6c144d13bcb091195b8ebec1">LZMA_FINISH</a>, <a class="el" href="common_8h.html#a1fca27f3d292f89fffbf7162d34a5bc3">LZMA_NEXT_CODER_INIT</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea2dac8d451cb38da8550653d0d7be4ec2">LZMA_PROG_ERROR</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea91ecc6fab14c13ad36224afbcb4e55c4">LZMA_STREAM_END</a>, and <a class="el" href="common_8h.html#a3e1bf9f33b917e883b886b8a10458d66">return_if_error</a>.</p>

</div>
</div>
<a class="anchor" id="aee038818cf7bbe044c3f7a7c86998c1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_properties_size </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlzma__filter.html">lzma_filter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of the Filter Properties field. </p>
<p>This function may be useful when implementing custom file formats using the raw encoder and decoder.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Pointer to uint32_t to hold the size of the properties </td></tr>
    <tr><td class="paramname">filter</td><td>Filter ID and options (the size of the properties may vary depending on the options)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK<ul>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function validates the Filter ID, but does not necessarily validate the options. Thus, it is possible that this returns LZMA_OK while the following call to <a class="el" href="filter_8h.html#a8e00887086df5a44084ac22e48415de3" title="Encode the Filter Properties field.">lzma_properties_encode()</a> returns LZMA_OPTIONS_ERROR. </dd></dl>

<p>References <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eaa9ff6dfee36b7aba4fae60706d37425f">LZMA_OPTIONS_ERROR</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea2dac8d451cb38da8550653d0d7be4ec2">LZMA_PROG_ERROR</a>, <a class="el" href="vli_8h.html#a7b782528bd1934db7c020adbedb20ec9">LZMA_VLI_MAX</a>, and <a class="el" href="structlzma__filter__encoder.html#a1546dc01c7ed513a1e62fc0b807214fc">lzma_filter_encoder::props_size_get</a>.</p>

<p>Referenced by <a class="el" href="filter__flags__encoder_8c.html#a7015967aa324750a66c788b1987aa6a5">lzma_filter_flags_encode()</a>, and <a class="el" href="filter__flags__encoder_8c.html#a23a84602614b62ba2c9241149fd89087">lzma_filter_flags_size()</a>.</p>

</div>
</div>
<a class="anchor" id="a8e00887086df5a44084ac22e48415de3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_properties_encode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlzma__filter.html">lzma_filter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>props</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode the Filter Properties field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>Filter ID and options </td></tr>
    <tr><td class="paramname">props</td><td>Buffer to hold the encoded options. The size of buffer must have been already determined with <a class="el" href="filter_8h.html#aee038818cf7bbe044c3f7a7c86998c1b" title="Get the size of the Filter Properties field.">lzma_properties_size()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK<ul>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Even this function won't validate more options than actually necessary. Thus, it is possible that encoding the properties succeeds but using the same options to initialize the encoder will fail.</dd>
<dd>
If <a class="el" href="filter_8h.html#aee038818cf7bbe044c3f7a7c86998c1b" title="Get the size of the Filter Properties field.">lzma_properties_size()</a> indicated that the size of the Filter Properties field is zero, calling <a class="el" href="filter_8h.html#a8e00887086df5a44084ac22e48415de3" title="Encode the Filter Properties field.">lzma_properties_encode()</a> is not required, but it won't do any harm either. </dd></dl>

<p>References <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea2dac8d451cb38da8550653d0d7be4ec2">LZMA_PROG_ERROR</a>, and <a class="el" href="structlzma__filter__encoder.html#adbaaf406e12224aab5430d857ba2655e">lzma_filter_encoder::props_encode</a>.</p>

<p>Referenced by <a class="el" href="filter__flags__encoder_8c.html#a7015967aa324750a66c788b1987aa6a5">lzma_filter_flags_encode()</a>.</p>

</div>
</div>
<a class="anchor" id="acec30e78c7cbe56b00f7671b6fcf2afc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_properties_decode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__filter.html">lzma_filter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>props_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode the Filter Properties field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>filter-&gt;id must have been set to the correct Filter ID. filter-&gt;options doesn't need to be initialized (it's not freed by this function). The decoded options will be stored to filter-&gt;options. filter-&gt;options is set to NULL if there are no properties or if an error occurs. </td></tr>
    <tr><td class="paramname">allocator</td><td>Custom memory allocator used to allocate the options. Set to NULL to use the default malloc(), and in case of an error, also free(). </td></tr>
    <tr><td class="paramname">props</td><td>Input buffer containing the properties. </td></tr>
    <tr><td class="paramname">props_size</td><td>Size of the properties. This must be the exact size; giving too much or too little input will return LZMA_OPTIONS_ERROR.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK<ul>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_MEM_ERROR </li>
</ul>
</dd></dl>

<p>References <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eaa9ff6dfee36b7aba4fae60706d37425f">LZMA_OPTIONS_ERROR</a>, and <a class="el" href="structlzma__filter__decoder.html#a0f93e7f50a6e6b017d9634d157274e4b">lzma_filter_decoder::props_decode</a>.</p>

<p>Referenced by <a class="el" href="coder_8c.html#a15b6ce144220e53107c642b3baefe9bc">is_format_lzma()</a>, <a class="el" href="filter__flags__decoder_8c.html#a9a1158f867c66ffa35a9b38c830c083c">lzma_filter_flags_decode()</a>, and <a class="el" href="lzmainfo_8c.html#a76cfa2b4fc44ede3c371981dd4e66e11">lzmainfo()</a>.</p>

</div>
</div>
<a class="anchor" id="a996c9c21840ed54e37bd1f664a79d940"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_filter_flags_size </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlzma__filter.html">lzma_filter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate encoded size of a Filter Flags field. </p>
<p>Knowing the size of Filter Flags is useful to know when allocating memory to hold the encoded Filter Flags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Pointer to integer to hold the calculated size </td></tr>
    <tr><td class="paramname">filter</td><td>Filter ID and associated options whose encoded size is to be calculated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK: *size set successfully. Note that this doesn't guarantee that filter-&gt;options is valid, thus <a class="el" href="filter_8h.html#a96f23309bc21398fece18c00ebe7db98" title="Encode Filter Flags into given buffer.">lzma_filter_flags_encode()</a> may still fail.<ul>
<li>LZMA_OPTIONS_ERROR: Unknown Filter ID or unsupported options.</li>
<li>LZMA_PROG_ERROR: Invalid options</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you need to calculate size of List of Filter Flags, you need to loop over every <a class="el" href="structlzma__filter.html" title="Filter options.">lzma_filter</a> entry. </dd></dl>

<p>References <a class="el" href="common_8h.html#a50d12a2d492921171aab3404ca56a55c">LZMA_FILTER_RESERVED_START</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea2dac8d451cb38da8550653d0d7be4ec2">LZMA_PROG_ERROR</a>, <a class="el" href="filter_8h.html#aee038818cf7bbe044c3f7a7c86998c1b">lzma_properties_size()</a>, <a class="el" href="vli_8h.html#a8d53e0b69934b43da8721fa6f1e8cc4f">lzma_vli_size()</a>, and <a class="el" href="common_8h.html#a3e1bf9f33b917e883b886b8a10458d66">return_if_error</a>.</p>

<p>Referenced by <a class="el" href="block__header__encoder_8c.html#a7d60c35cba687af87e3c3a83639b2f6d">lzma_block_header_size()</a>.</p>

</div>
</div>
<a class="anchor" id="a96f23309bc21398fece18c00ebe7db98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_filter_flags_encode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlzma__filter.html">lzma_filter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>out_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>out_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode Filter Flags into given buffer. </p>
<p>In contrast to some functions, this doesn't allocate the needed buffer. This is due to how this function is used internally by liblzma.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>Filter ID and options to be encoded </td></tr>
    <tr><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramname">out_pos</td><td>out[*out_pos] is the next write position. This is updated by the encoder. </td></tr>
    <tr><td class="paramname">out_size</td><td>out[out_size] is the first byte to not write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK: Encoding was successful.<ul>
<li>LZMA_OPTIONS_ERROR: Invalid or unsupported options.</li>
<li>LZMA_PROG_ERROR: Invalid options or not enough output buffer space (you should have checked it with <a class="el" href="filter_8h.html#a996c9c21840ed54e37bd1f664a79d940" title="Calculate encoded size of a Filter Flags field.">lzma_filter_flags_size()</a>). </li>
</ul>
</dd></dl>

<p>References <a class="el" href="common_8h.html#a50d12a2d492921171aab3404ca56a55c">LZMA_FILTER_RESERVED_START</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea2dac8d451cb38da8550653d0d7be4ec2">LZMA_PROG_ERROR</a>, <a class="el" href="filter_8h.html#a8e00887086df5a44084ac22e48415de3">lzma_properties_encode()</a>, <a class="el" href="filter_8h.html#aee038818cf7bbe044c3f7a7c86998c1b">lzma_properties_size()</a>, <a class="el" href="vli_8h.html#a50bbb77e9ec3b72c25586aa700c20970">lzma_vli_encode()</a>, and <a class="el" href="common_8h.html#a3e1bf9f33b917e883b886b8a10458d66">return_if_error</a>.</p>

<p>Referenced by <a class="el" href="block__header__encoder_8c.html#a01a1e06f40b56d8ca61ac577e77a4fec">lzma_block_header_encode()</a>.</p>

</div>
</div>
<a class="anchor" id="aadadfde2b6fd2d4b247a277423a67d32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_filter_flags_decode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__filter.html">lzma_filter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>in_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>in_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode Filter Flags from given buffer. </p>
<p>The decoded result is stored into *filter. The old value of filter-&gt;options is not free()d.</p>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK<ul>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

<p>References <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea3aa72729a844790e39b4e1101a731dfb">LZMA_DATA_ERROR</a>, <a class="el" href="common_8h.html#a50d12a2d492921171aab3404ca56a55c">LZMA_FILTER_RESERVED_START</a>, <a class="el" href="filter_8h.html#acec30e78c7cbe56b00f7671b6fcf2afc">lzma_properties_decode()</a>, <a class="el" href="vli_8h.html#a7b7d50e1074e0e2bcd81c29a5f7461c7">lzma_vli_decode()</a>, and <a class="el" href="common_8h.html#a3e1bf9f33b917e883b886b8a10458d66">return_if_error</a>.</p>

<p>Referenced by <a class="el" href="block__header__decoder_8c.html#ac85bbf9df6709081a8112c8826b4997b">lzma_block_header_decode()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jun 5 2014 14:24:08 for XZ Utils by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
