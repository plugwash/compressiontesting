<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>XZ Utils: liblzma/lz/lz_encoder_mf.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">XZ Utils
   &#160;<span id="projectnumber">5.1.0alpha</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2e0898c272e1f0f93c8ef15f5da2a912.html">liblzma</a></li><li class="navelem"><a class="el" href="dir_50b86e5c919915733207984a4aa1052b.html">lz</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">lz_encoder_mf.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Match finders.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="lz__encoder_8h.html">lz_encoder.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="lz__encoder__hash_8h.html">lz_encoder_hash.h</a>&quot;</code><br/>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aa84dd0b4f5690a4f890f7be99792feeb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lz__encoder__mf_8c.html#aa84dd0b4f5690a4f890f7be99792feeb">EMPTY_HASH_VALUE</a>&#160;&#160;&#160;0</td></tr>
<tr class="memitem:a73a2d7ca0b7c574a5043d0236fec29c8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lz__encoder__mf_8c.html#a73a2d7ca0b7c574a5043d0236fec29c8">MUST_NORMALIZE_POS</a>&#160;&#160;&#160;UINT32_MAX</td></tr>
<tr class="memitem:aafda9f47948ddd2342f44150a3489908"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lz__encoder__mf_8c.html#aafda9f47948ddd2342f44150a3489908">header</a>(is_bt, len_min, ret_op)</td></tr>
<tr class="memitem:a8b1ccc141b3c8be0a63b15fec7f9c8b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lz__encoder__mf_8c.html#a8b1ccc141b3c8be0a63b15fec7f9c8b2">header_find</a>(is_bt, len_min)</td></tr>
<tr class="memitem:acbaeadaaa3485eaebf078fb5ed712a36"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lz__encoder__mf_8c.html#acbaeadaaa3485eaebf078fb5ed712a36">header_skip</a>(is_bt, len_min)&#160;&#160;&#160;<a class="el" href="lz__encoder__mf_8c.html#aafda9f47948ddd2342f44150a3489908">header</a>(is_bt, len_min, continue)</td></tr>
<tr class="memitem:a0e7fce36bf4da7e7bd9651901d22eddb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lz__encoder__mf_8c.html#a0e7fce36bf4da7e7bd9651901d22eddb">call_find</a>(func, len_best)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a47b5a3f51e46b7ba5908fbf7150d3343"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lz__encoder__mf_8c.html#a47b5a3f51e46b7ba5908fbf7150d3343">lzma_mf_find</a> (<a class="el" href="structlzma__mf__s.html">lzma_mf</a> *mf, uint32_t *count_ptr, <a class="el" href="structlzma__match.html">lzma_match</a> *matches)</td></tr>
<tr class="memdesc:a47b5a3f51e46b7ba5908fbf7150d3343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find matches starting from the current byte.  <a href="#a47b5a3f51e46b7ba5908fbf7150d3343"></a><br/></td></tr>
<tr class="memitem:a648138094aea5aa00a259061633ab848"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lz__encoder__mf_8c.html#a648138094aea5aa00a259061633ab848">normalize</a> (<a class="el" href="structlzma__mf__s.html">lzma_mf</a> *mf)</td></tr>
<tr class="memdesc:a648138094aea5aa00a259061633ab848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes hash values.  <a href="#a648138094aea5aa00a259061633ab848"></a><br/></td></tr>
<tr class="memitem:a664d6298d1e02fb4817f416382953f20"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lz__encoder__mf_8c.html#a664d6298d1e02fb4817f416382953f20">move_pos</a> (<a class="el" href="structlzma__mf__s.html">lzma_mf</a> *mf)</td></tr>
<tr class="memdesc:a664d6298d1e02fb4817f416382953f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the current byte as processed from point of view of the match finder.  <a href="#a664d6298d1e02fb4817f416382953f20"></a><br/></td></tr>
<tr class="memitem:a38834174a29ae811fbd2ee848f069866"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lz__encoder__mf_8c.html#a38834174a29ae811fbd2ee848f069866">move_pending</a> (<a class="el" href="structlzma__mf__s.html">lzma_mf</a> *mf)</td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Match finders. </p>
</div><h2>Macro Definition Documentation</h2>
<a class="anchor" id="aa84dd0b4f5690a4f890f7be99792feeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EMPTY_HASH_VALUE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Hash value to indicate unused element in the hash. Since we start the positions from dict_size + 1, zero is always too far to qualify as usable match position. </p>

<p>Referenced by <a class="el" href="lz__encoder__mf_8c.html#a648138094aea5aa00a259061633ab848">normalize()</a>.</p>

</div>
</div>
<a class="anchor" id="a73a2d7ca0b7c574a5043d0236fec29c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MUST_NORMALIZE_POS&#160;&#160;&#160;UINT32_MAX</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Normalization must be done when <a class="el" href="structlzma__mf__s.html#a2f61158f799c0c4e77e6316038757fee">lzma_mf.offset</a> + <a class="el" href="structlzma__mf__s.html#a2d75d309fc59e61e468fcd9e3a38c150">lzma_mf.read_pos</a> reaches MUST_NORMALIZE_POS. </p>

<p>Referenced by <a class="el" href="lz__encoder__mf_8c.html#a648138094aea5aa00a259061633ab848">normalize()</a>.</p>

</div>
</div>
<a class="anchor" id="aafda9f47948ddd2342f44150a3489908"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define header</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">is_bt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len_min, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ret_op&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">uint32_t len_limit = <a class="code" href="lz__encoder_8h.html#a448bea3aca15ae451c69e197bb6720f9" title="Get the number of bytes that haven&#39;t been ran through the match finder yet.">mf_avail</a>(mf); \</div>
<div class="line">        if (mf-&gt;nice_len &lt;= len_limit) { \</div>
<div class="line">                len_limit = mf-&gt;nice_len; \</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (len_limit &lt; (len_min) \</div>
<div class="line">                        || (is_bt &amp;&amp; mf-&gt;action == <a class="code" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea14d75152afcda85d215e877fdd9c4170" title="Make all the input available at output.">LZMA_SYNC_FLUSH</a>)) { \</div>
<div class="line">                assert(mf-&gt;action != <a class="code" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea868472b76492afcaef54020a481890b1" title="Continue coding.">LZMA_RUN</a>); \</div>
<div class="line">                move_pending(mf); \</div>
<div class="line">                ret_op; \</div>
<div class="line">        } \</div>
<div class="line">        const uint8_t *cur = <a class="code" href="lz__encoder_8h.html#a6e013d2ce6aa381e26fb6579cbd9ddae" title="Get pointer to the first byte not ran through the match finder.">mf_ptr</a>(mf); \</div>
<div class="line">        const uint32_t pos = mf-&gt;read_pos + mf-&gt;offset</div>
</div><!-- fragment --><p>Calculate len_limit and determine if there is enough input to run the actual match finder code. Sets up "cur" and "pos". This macro is used by all find functions and binary tree skip functions. Hash chain skip function doesn't need len_limit so a simpler code is used in them. </p>

</div>
</div>
<a class="anchor" id="a8b1ccc141b3c8be0a63b15fec7f9c8b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define header_find</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">is_bt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len_min&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="lz__encoder__mf_8c.html#aafda9f47948ddd2342f44150a3489908">header</a>(is_bt, len_min, <span class="keywordflow">return</span> 0); \</div>
<div class="line">        uint32_t matches_count = 0</div>
</div><!-- fragment --><p>Header for find functions. "return 0" indicates that zero matches were found. </p>

</div>
</div>
<a class="anchor" id="acbaeadaaa3485eaebf078fb5ed712a36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define header_skip</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">is_bt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len_min&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="lz__encoder__mf_8c.html#aafda9f47948ddd2342f44150a3489908">header</a>(is_bt, len_min, continue)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Header for a loop in a skip function. "continue" tells to skip the rest of the code in the loop. </p>

</div>
</div>
<a class="anchor" id="a0e7fce36bf4da7e7bd9651901d22eddb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define call_find</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">func, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len_best&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> { \</div>
<div class="line">        matches_count = func(len_limit, pos, cur, cur_match, mf-&gt;depth, \</div>
<div class="line">                                mf-&gt;son, mf-&gt;cyclic_pos, mf-&gt;cyclic_size, \</div>
<div class="line">                                matches + matches_count, len_best) \</div>
<div class="line">                        - matches; \</div>
<div class="line">        move_pos(mf); \</div>
<div class="line">        return matches_count; \</div>
<div class="line">} <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment --><p>Calls hc_find_func() or bt_find_func() and calculates the total number of matches found. Updates the dictionary position and returns the number of matches found. </p>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="a47b5a3f51e46b7ba5908fbf7150d3343"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lzma_mf_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__mf__s.html">lzma_mf</a> *&#160;</td>
          <td class="paramname"><em>mf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>count_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__match.html">lzma_match</a> *&#160;</td>
          <td class="paramname"><em>matches</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find matches starting from the current byte. </p>
<dl class="section return"><dt>Returns</dt><dd>The length of the longest match found </dd></dl>

<p>References <a class="el" href="structlzma__mf__s.html#a62dbb517d02d31c51feb24ca810c1fa5">lzma_mf_s::find</a>, <a class="el" href="structlzma__mf__s.html#a6fa8887a90423f6833506f298ae76a8d">lzma_mf_s::match_len_max</a>, <a class="el" href="lz__encoder_8h.html#a448bea3aca15ae451c69e197bb6720f9">mf_avail()</a>, <a class="el" href="lz__encoder_8h.html#a6e013d2ce6aa381e26fb6579cbd9ddae">mf_ptr()</a>, <a class="el" href="structlzma__mf__s.html#aa4291f4276c419e74a95cb8accdf1396">lzma_mf_s::nice_len</a>, and <a class="el" href="structlzma__mf__s.html#ab5d64d7200396c7cd612c1fe3a064f22">lzma_mf_s::read_ahead</a>.</p>

</div>
</div>
<a class="anchor" id="a648138094aea5aa00a259061633ab848"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void normalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__mf__s.html">lzma_mf</a> *&#160;</td>
          <td class="paramname"><em>mf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalizes hash values. </p>
<p>The hash arrays store positions of match candidates. The positions are relative to an arbitrary offset that is not the same as the absolute offset in the input stream. The relative position of the current byte is <a class="el" href="structlzma__mf__s.html#a2f61158f799c0c4e77e6316038757fee">lzma_mf.offset</a> + <a class="el" href="structlzma__mf__s.html#a2d75d309fc59e61e468fcd9e3a38c150">lzma_mf.read_pos</a>. The distances of the matches are the differences of the current read position and the position found from the hash.</p>
<p>To prevent integer overflows of the offsets stored in the hash arrays, we need to "normalize" the stored values now and then. During the normalization, we drop values that indicate distance greater than the dictionary size, thus making space for new values. </p>

<p>References <a class="el" href="lz__encoder__mf_8c.html#aa84dd0b4f5690a4f890f7be99792feeb">EMPTY_HASH_VALUE</a>, <a class="el" href="structlzma__mf__s.html#a148e0e2a9f52595b7d9d2dc93d04c50a">lzma_mf_s::hash_size_sum</a>, <a class="el" href="lz__encoder__mf_8c.html#a73a2d7ca0b7c574a5043d0236fec29c8">MUST_NORMALIZE_POS</a>, <a class="el" href="structlzma__mf__s.html#a2f61158f799c0c4e77e6316038757fee">lzma_mf_s::offset</a>, <a class="el" href="structlzma__mf__s.html#a2d75d309fc59e61e468fcd9e3a38c150">lzma_mf_s::read_pos</a>, and <a class="el" href="structlzma__mf__s.html#ad1e3c68f459903d161ed34a97ff43fdf">lzma_mf_s::sons_count</a>.</p>

<p>Referenced by <a class="el" href="lz__encoder__mf_8c.html#a664d6298d1e02fb4817f416382953f20">move_pos()</a>.</p>

</div>
</div>
<a class="anchor" id="a664d6298d1e02fb4817f416382953f20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void move_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__mf__s.html">lzma_mf</a> *&#160;</td>
          <td class="paramname"><em>mf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark the current byte as processed from point of view of the match finder. </p>

<p>References <a class="el" href="lz__encoder__mf_8c.html#a648138094aea5aa00a259061633ab848">normalize()</a>, <a class="el" href="structlzma__mf__s.html#a2f61158f799c0c4e77e6316038757fee">lzma_mf_s::offset</a>, <a class="el" href="structlzma__mf__s.html#a2d75d309fc59e61e468fcd9e3a38c150">lzma_mf_s::read_pos</a>, and <a class="el" href="structlzma__mf__s.html#afcc4a74eb85f8942d40a21d9155d948c">lzma_mf_s::write_pos</a>.</p>

</div>
</div>
<a class="anchor" id="a38834174a29ae811fbd2ee848f069866"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void move_pending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__mf__s.html">lzma_mf</a> *&#160;</td>
          <td class="paramname"><em>mf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When flushing, we cannot run the match finder unless there is nice_len bytes available in the dictionary. Instead, we skip running the match finder (indicating that no match was found), and count how many bytes we have ignored this way.</p>
<p>When new data is given after the flushing was completed, the match finder is restarted by rewinding mf-&gt;read_pos backwards by mf-&gt;pending. Then the missed bytes are added to the hash using the match finder's skip function (with small amount of input, it may start using mf-&gt;pending again if flushing).</p>
<p>Due to this rewinding, we don't touch cyclic_pos or test for normalization. It will be done when the match finder's skip function catches up after a flush. </p>

<p>References <a class="el" href="structlzma__mf__s.html#af6719fc22695f6e8569969009ba5a727">lzma_mf_s::pending</a>, <a class="el" href="structlzma__mf__s.html#a2d75d309fc59e61e468fcd9e3a38c150">lzma_mf_s::read_pos</a>, and <a class="el" href="structlzma__mf__s.html#afcc4a74eb85f8942d40a21d9155d948c">lzma_mf_s::write_pos</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jun 5 2014 14:24:09 for XZ Utils by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
