<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>XZ Utils: liblzma/common/index.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">XZ Utils
   &#160;<span id="projectnumber">5.1.0alpha</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2e0898c272e1f0f93c8ef15f5da2a912.html">liblzma</a></li><li class="navelem"><a class="el" href="dir_db777975f8e21a5de5f283e04473bf67.html">common</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">index.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Handling of .xz Indexes and some other Stream information.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;index.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="stream__flags__common_8h.html">stream_flags_common.h</a>&quot;</code><br/>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structindex__tree__node__s.html">index_tree_node_s</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structindex__tree.html">index_tree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AVL tree to hold <a class="el" href="structindex__stream.html">index_stream</a> or <a class="el" href="structindex__group.html">index_group</a> structures.  <a href="structindex__tree.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structindex__record.html">index_record</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structindex__group.html">index_group</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structindex__stream.html">index_stream</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__index__s.html">lzma_index_s</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structindex__cat__info.html">index_cat_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to pass info to <a class="el" href="index_8c.html#ae84b534588169c7490e8fe61c141b1d6">index_cat_helper()</a>  <a href="structindex__cat__info.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a5083e2e588a600088db6cea759e07437"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a5083e2e588a600088db6cea759e07437">INDEX_GROUP_SIZE</a>&#160;&#160;&#160;512</td></tr>
<tr class="memdesc:a5083e2e588a600088db6cea759e07437"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many Records to allocate at once.  <a href="#a5083e2e588a600088db6cea759e07437"></a><br/></td></tr>
<tr class="memitem:a5611619fba202b1641dca31ec9b8f716"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a5611619fba202b1641dca31ec9b8f716">PREALLOC_MAX</a>&#160;&#160;&#160;((SIZE_MAX - sizeof(<a class="el" href="structindex__group.html">index_group</a>)) / sizeof(<a class="el" href="structindex__record.html">index_record</a>))</td></tr>
<tr class="memdesc:a5611619fba202b1641dca31ec9b8f716"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many Records can be allocated at once at maximum.  <a href="#a5611619fba202b1641dca31ec9b8f716"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7d9c96f29c685f30b42c9abdd307d8a6"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structindex__tree__node__s.html">index_tree_node_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a7d9c96f29c685f30b42c9abdd307d8a6">index_tree_node</a></td></tr>
<tr class="memdesc:a7d9c96f29c685f30b42c9abdd307d8a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base structure for <a class="el" href="structindex__stream.html">index_stream</a> and <a class="el" href="structindex__group.html">index_group</a> structures.  <a href="#a7d9c96f29c685f30b42c9abdd307d8a6"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac36f475ca5b446f4fde4c9b90bec77c8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<b>ITER_INDEX</b>, 
<b>ITER_STREAM</b>, 
<b>ITER_GROUP</b>, 
<b>ITER_RECORD</b>, 
<br/>
&#160;&#160;<b>ITER_METHOD</b>
<br/>
 }</td></tr>
<tr class="memdesc:ac36f475ca5b446f4fde4c9b90bec77c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexing for lzma_index_iter.internal[].  <a href="index_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8">More...</a><br/></td></tr>
<tr class="memitem:a05589fbab0657f08285ebdfe93f5ec9e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>ITER_METHOD_NORMAL</b>, 
<b>ITER_METHOD_NEXT</b>, 
<b>ITER_METHOD_LEFTMOST</b>
 }</td></tr>
<tr class="memdesc:a05589fbab0657f08285ebdfe93f5ec9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values for lzma_index_iter.internal[ITER_METHOD].s.  <a href="index_8c.html#a05589fbab0657f08285ebdfe93f5ec9e">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a72d173b4e1d1247064e3b002acbd0da7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72d173b4e1d1247064e3b002acbd0da7"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>index_tree_init</b> (<a class="el" href="structindex__tree.html">index_tree</a> *tree)</td></tr>
<tr class="memitem:a18e034eee97f9732b884117e0234276d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a18e034eee97f9732b884117e0234276d">index_tree_node_end</a> (<a class="el" href="index_8c.html#a7d9c96f29c685f30b42c9abdd307d8a6">index_tree_node</a> *node, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator, void(*free_func)(void *node, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator))</td></tr>
<tr class="memdesc:a18e034eee97f9732b884117e0234276d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for <a class="el" href="index_8c.html#ad0843d99b4a243fbcd4b4a52f1758d8c">index_tree_end()</a>  <a href="#a18e034eee97f9732b884117e0234276d"></a><br/></td></tr>
<tr class="memitem:ad0843d99b4a243fbcd4b4a52f1758d8c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#ad0843d99b4a243fbcd4b4a52f1758d8c">index_tree_end</a> (<a class="el" href="structindex__tree.html">index_tree</a> *tree, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator, void(*free_func)(void *node, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator))</td></tr>
<tr class="memitem:a8a3b2b95c1953a8cf7f9fa88316081fc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a8a3b2b95c1953a8cf7f9fa88316081fc">index_tree_append</a> (<a class="el" href="structindex__tree.html">index_tree</a> *tree, <a class="el" href="index_8c.html#a7d9c96f29c685f30b42c9abdd307d8a6">index_tree_node</a> *node)</td></tr>
<tr class="memitem:a9043c7fea3feef371dd37abbc7db14ab"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a9043c7fea3feef371dd37abbc7db14ab">index_tree_next</a> (const <a class="el" href="index_8c.html#a7d9c96f29c685f30b42c9abdd307d8a6">index_tree_node</a> *node)</td></tr>
<tr class="memdesc:a9043c7fea3feef371dd37abbc7db14ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next node in the tree. Return NULL if there are no more nodes.  <a href="#a9043c7fea3feef371dd37abbc7db14ab"></a><br/></td></tr>
<tr class="memitem:ac6795607a0d3881e5fff569a82d01415"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#ac6795607a0d3881e5fff569a82d01415">index_tree_locate</a> (const <a class="el" href="structindex__tree.html">index_tree</a> *tree, <a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> target)</td></tr>
<tr class="memitem:a2735b9fc95daaac1420cd6ebae2a2fa8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structindex__stream.html">index_stream</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a2735b9fc95daaac1420cd6ebae2a2fa8">index_stream_init</a> (<a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> compressed_base, <a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> uncompressed_base, <a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> stream_number, <a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> block_number_base, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator)</td></tr>
<tr class="memdesc:a2735b9fc95daaac1420cd6ebae2a2fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a new Stream using the given base offsets.  <a href="#a2735b9fc95daaac1420cd6ebae2a2fa8"></a><br/></td></tr>
<tr class="memitem:a0cc239b8b51d743b420293025c167eed"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a0cc239b8b51d743b420293025c167eed">index_stream_end</a> (void *node, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator)</td></tr>
<tr class="memdesc:a0cc239b8b51d743b420293025c167eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the memory allocated for a Stream and its Record groups.  <a href="#a0cc239b8b51d743b420293025c167eed"></a><br/></td></tr>
<tr class="memitem:a38513522a71c4789582d59e303ede20c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38513522a71c4789582d59e303ede20c"></a>
static <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>index_init_plain</b> (<a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator)</td></tr>
<tr class="memitem:aa40bf2bf3abd7914e643cdb42edac896"><td class="memItemLeft" align="right" valign="top"><a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#aa40bf2bf3abd7914e643cdb42edac896">lzma_index_init</a> (<a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator)</td></tr>
<tr class="memdesc:aa40bf2bf3abd7914e643cdb42edac896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a new lzma_index structure.  <a href="#aa40bf2bf3abd7914e643cdb42edac896"></a><br/></td></tr>
<tr class="memitem:a7aade93273d56c5cf62e4fd02f10c791"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a7aade93273d56c5cf62e4fd02f10c791">lzma_index_end</a> (<a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator)</td></tr>
<tr class="memdesc:a7aade93273d56c5cf62e4fd02f10c791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate lzma_index.  <a href="#a7aade93273d56c5cf62e4fd02f10c791"></a><br/></td></tr>
<tr class="memitem:a017afdd81c6a8410f3148d82dca671c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a017afdd81c6a8410f3148d82dca671c2">lzma_index_prealloc</a> (<a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i, <a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> records)</td></tr>
<tr class="memitem:a520a04acfa6fedd5ea32ce8af29339ad"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a520a04acfa6fedd5ea32ce8af29339ad">lzma_index_memusage</a> (<a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> streams, <a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> blocks)</td></tr>
<tr class="memdesc:a520a04acfa6fedd5ea32ce8af29339ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate memory usage of lzma_index.  <a href="#a520a04acfa6fedd5ea32ce8af29339ad"></a><br/></td></tr>
<tr class="memitem:ae39293600748764d3b1ee02ebb65e947"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#ae39293600748764d3b1ee02ebb65e947">lzma_index_memused</a> (const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i)</td></tr>
<tr class="memdesc:ae39293600748764d3b1ee02ebb65e947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the memory usage of an existing lzma_index.  <a href="#ae39293600748764d3b1ee02ebb65e947"></a><br/></td></tr>
<tr class="memitem:aed1d3357be8dded98a7ec86733e86fc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#aed1d3357be8dded98a7ec86733e86fc5">lzma_index_block_count</a> (const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i)</td></tr>
<tr class="memdesc:aed1d3357be8dded98a7ec86733e86fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of Blocks.  <a href="#aed1d3357be8dded98a7ec86733e86fc5"></a><br/></td></tr>
<tr class="memitem:a265c5858f2a4a3c1da8ff4ab4e1ef373"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a265c5858f2a4a3c1da8ff4ab4e1ef373">lzma_index_stream_count</a> (const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i)</td></tr>
<tr class="memdesc:a265c5858f2a4a3c1da8ff4ab4e1ef373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of Streams.  <a href="#a265c5858f2a4a3c1da8ff4ab4e1ef373"></a><br/></td></tr>
<tr class="memitem:a64bd8a338f577f0aca7b79c57e4ec23a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a64bd8a338f577f0aca7b79c57e4ec23a">lzma_index_size</a> (const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i)</td></tr>
<tr class="memdesc:a64bd8a338f577f0aca7b79c57e4ec23a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the Index field as bytes.  <a href="#a64bd8a338f577f0aca7b79c57e4ec23a"></a><br/></td></tr>
<tr class="memitem:a4a82baf907d73223d2bd2c7e75ef7b73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a4a82baf907d73223d2bd2c7e75ef7b73">lzma_index_total_size</a> (const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i)</td></tr>
<tr class="memdesc:a4a82baf907d73223d2bd2c7e75ef7b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total size of the Blocks.  <a href="#a4a82baf907d73223d2bd2c7e75ef7b73"></a><br/></td></tr>
<tr class="memitem:aeb6ff3d3757d20496d866b531f0d92b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#aeb6ff3d3757d20496d866b531f0d92b4">lzma_index_stream_size</a> (const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i)</td></tr>
<tr class="memdesc:aeb6ff3d3757d20496d866b531f0d92b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total size of the Stream.  <a href="#aeb6ff3d3757d20496d866b531f0d92b4"></a><br/></td></tr>
<tr class="memitem:a29e41708c74af647158c72c58c35c44a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29e41708c74af647158c72c58c35c44a"></a>
static <a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td><td class="memItemRight" valign="bottom"><b>index_file_size</b> (<a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> compressed_base, <a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> unpadded_sum, <a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> record_count, <a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> index_list_size, <a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> stream_padding)</td></tr>
<tr class="memitem:ad4d3746aadd411799d806a3dd5cbe7b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#ad4d3746aadd411799d806a3dd5cbe7b2">lzma_index_file_size</a> (const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i)</td></tr>
<tr class="memdesc:ad4d3746aadd411799d806a3dd5cbe7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total size of the file.  <a href="#ad4d3746aadd411799d806a3dd5cbe7b2"></a><br/></td></tr>
<tr class="memitem:a3d993c8e6e73717fbb2b415820f8c712"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a3d993c8e6e73717fbb2b415820f8c712">lzma_index_uncompressed_size</a> (const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i)</td></tr>
<tr class="memdesc:a3d993c8e6e73717fbb2b415820f8c712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the uncompressed size of the file.  <a href="#a3d993c8e6e73717fbb2b415820f8c712"></a><br/></td></tr>
<tr class="memitem:abc4e1a0927e07f5580c9f66dbcec3bc2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#abc4e1a0927e07f5580c9f66dbcec3bc2">lzma_index_checks</a> (const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i)</td></tr>
<tr class="memdesc:abc4e1a0927e07f5580c9f66dbcec3bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the types of integrity Checks.  <a href="#abc4e1a0927e07f5580c9f66dbcec3bc2"></a><br/></td></tr>
<tr class="memitem:ab88435af7c81e25208df2d831fcf5b6f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#ab88435af7c81e25208df2d831fcf5b6f">lzma_index_padding_size</a> (const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i)</td></tr>
<tr class="memitem:ad427e6894af982f7443c677bfbe4b856"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#ad427e6894af982f7443c677bfbe4b856">lzma_index_stream_flags</a> (<a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i, const <a class="el" href="structlzma__stream__flags.html">lzma_stream_flags</a> *stream_flags)</td></tr>
<tr class="memdesc:ad427e6894af982f7443c677bfbe4b856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Stream Flags.  <a href="#ad427e6894af982f7443c677bfbe4b856"></a><br/></td></tr>
<tr class="memitem:ad1de7c81bb1f94177dd0d1240e1ed652"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#ad1de7c81bb1f94177dd0d1240e1ed652">lzma_index_stream_padding</a> (<a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i, <a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> stream_padding)</td></tr>
<tr class="memdesc:ad1de7c81bb1f94177dd0d1240e1ed652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the amount of Stream Padding.  <a href="#ad1de7c81bb1f94177dd0d1240e1ed652"></a><br/></td></tr>
<tr class="memitem:a37a3414069a2bcf3cae1baa52c455441"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a37a3414069a2bcf3cae1baa52c455441">lzma_index_append</a> (<a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator, <a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> unpadded_size, <a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> uncompressed_size)</td></tr>
<tr class="memdesc:a37a3414069a2bcf3cae1baa52c455441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new Block to lzma_index.  <a href="#a37a3414069a2bcf3cae1baa52c455441"></a><br/></td></tr>
<tr class="memitem:ae84b534588169c7490e8fe61c141b1d6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#ae84b534588169c7490e8fe61c141b1d6">index_cat_helper</a> (const <a class="el" href="structindex__cat__info.html">index_cat_info</a> *info, <a class="el" href="structindex__stream.html">index_stream</a> *this)</td></tr>
<tr class="memitem:a9bbe4243896bcca83ee9c0aa6becb67e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bbe4243896bcca83ee9c0aa6becb67e"></a>
<a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lzma_index_cat</b> (<a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *restrict dest, <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *restrict src, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator)</td></tr>
<tr class="memitem:a2db488e0703ae8bb890202d505b1d82d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structindex__stream.html">index_stream</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a2db488e0703ae8bb890202d505b1d82d">index_dup_stream</a> (const <a class="el" href="structindex__stream.html">index_stream</a> *src, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator)</td></tr>
<tr class="memdesc:a2db488e0703ae8bb890202d505b1d82d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate an <a class="el" href="structindex__stream.html">index_stream</a>.  <a href="#a2db488e0703ae8bb890202d505b1d82d"></a><br/></td></tr>
<tr class="memitem:a8ac8a428e781dc92e6839cb15f7a458d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a8ac8a428e781dc92e6839cb15f7a458d">lzma_index_dup</a> (const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *src, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator)</td></tr>
<tr class="memdesc:a8ac8a428e781dc92e6839cb15f7a458d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate lzma_index.  <a href="#a8ac8a428e781dc92e6839cb15f7a458d"></a><br/></td></tr>
<tr class="memitem:a3de1fd80cdf1acff1b75c27b7c62f1b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3de1fd80cdf1acff1b75c27b7c62f1b0"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>iter_set_info</b> (<a class="el" href="structlzma__index__iter.html">lzma_index_iter</a> *iter)</td></tr>
<tr class="memitem:a206339df8447737452aa6870d101065b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a206339df8447737452aa6870d101065b">lzma_index_iter_init</a> (<a class="el" href="structlzma__index__iter.html">lzma_index_iter</a> *iter, const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i)</td></tr>
<tr class="memdesc:a206339df8447737452aa6870d101065b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an iterator.  <a href="#a206339df8447737452aa6870d101065b"></a><br/></td></tr>
<tr class="memitem:aed644650074bf3ee087f4f2b31b8aacd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#aed644650074bf3ee087f4f2b31b8aacd">lzma_index_iter_rewind</a> (<a class="el" href="structlzma__index__iter.html">lzma_index_iter</a> *iter)</td></tr>
<tr class="memdesc:aed644650074bf3ee087f4f2b31b8aacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewind the iterator.  <a href="#aed644650074bf3ee087f4f2b31b8aacd"></a><br/></td></tr>
<tr class="memitem:a994bd6d74fc850b3a9c4154157b6e5d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#abbc819c74b484c846825ae1388a50a59">lzma_bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a994bd6d74fc850b3a9c4154157b6e5d4">lzma_index_iter_next</a> (<a class="el" href="structlzma__index__iter.html">lzma_index_iter</a> *iter, <a class="el" href="api_2lzma_2index_8h.html#a712b43192d944bf2f767711343cd9ca8">lzma_index_iter_mode</a> mode)</td></tr>
<tr class="memdesc:a994bd6d74fc850b3a9c4154157b6e5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next Block or Stream.  <a href="#a994bd6d74fc850b3a9c4154157b6e5d4"></a><br/></td></tr>
<tr class="memitem:acd683a56b01af334964addb246f78349"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#abbc819c74b484c846825ae1388a50a59">lzma_bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#acd683a56b01af334964addb246f78349">lzma_index_iter_locate</a> (<a class="el" href="structlzma__index__iter.html">lzma_index_iter</a> *iter, <a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> target)</td></tr>
<tr class="memdesc:acd683a56b01af334964addb246f78349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locate a Block.  <a href="#acd683a56b01af334964addb246f78349"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Handling of .xz Indexes and some other Stream information. </p>
</div><h2>Macro Definition Documentation</h2>
<a class="anchor" id="a5083e2e588a600088db6cea759e07437"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INDEX_GROUP_SIZE&#160;&#160;&#160;512</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How many Records to allocate at once. </p>
<p>This should be big enough to avoid making lots of tiny allocations but small enough to avoid too much unused memory at once. </p>

<p>Referenced by <a class="el" href="index_8c.html#a37a3414069a2bcf3cae1baa52c455441">lzma_index_append()</a>, and <a class="el" href="index_8c.html#a520a04acfa6fedd5ea32ce8af29339ad">lzma_index_memusage()</a>.</p>

</div>
</div>
<a class="anchor" id="a5611619fba202b1641dca31ec9b8f716"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PREALLOC_MAX&#160;&#160;&#160;((SIZE_MAX - sizeof(<a class="el" href="structindex__group.html">index_group</a>)) / sizeof(<a class="el" href="structindex__record.html">index_record</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How many Records can be allocated at once at maximum. </p>

<p>Referenced by <a class="el" href="index_8c.html#a2db488e0703ae8bb890202d505b1d82d">index_dup_stream()</a>, and <a class="el" href="index_8c.html#a017afdd81c6a8410f3148d82dca671c2">lzma_index_prealloc()</a>.</p>

</div>
</div>
<h2>Typedef Documentation</h2>
<a class="anchor" id="a7d9c96f29c685f30b42c9abdd307d8a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structindex__tree__node__s.html">index_tree_node_s</a> <a class="el" href="index_8c.html#a7d9c96f29c685f30b42c9abdd307d8a6">index_tree_node</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base structure for <a class="el" href="structindex__stream.html">index_stream</a> and <a class="el" href="structindex__group.html">index_group</a> structures. </p>

</div>
</div>
<h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ac36f475ca5b446f4fde4c9b90bec77c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indexing for lzma_index_iter.internal[]. </p>

</div>
</div>
<a class="anchor" id="a05589fbab0657f08285ebdfe93f5ec9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Values for lzma_index_iter.internal[ITER_METHOD].s. </p>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="a18e034eee97f9732b884117e0234276d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void index_tree_node_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="index_8c.html#a7d9c96f29c685f30b42c9abdd307d8a6">index_tree_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *node, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator)&#160;</td>
          <td class="paramname"><em>free_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for <a class="el" href="index_8c.html#ad0843d99b4a243fbcd4b4a52f1758d8c">index_tree_end()</a> </p>

<p>Referenced by <a class="el" href="index_8c.html#ad0843d99b4a243fbcd4b4a52f1758d8c">index_tree_end()</a>.</p>

</div>
</div>
<a class="anchor" id="ad0843d99b4a243fbcd4b4a52f1758d8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void index_tree_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structindex__tree.html">index_tree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *node, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator)&#160;</td>
          <td class="paramname"><em>free_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Free the meory allocated for a tree. If free_func is not NULL, it is called on each node before freeing the node. This is used to free the Record groups from each <a class="el" href="structindex__stream.html">index_stream</a> before freeing the <a class="el" href="structindex__stream.html">index_stream</a> itself. </p>

<p>References <a class="el" href="index_8c.html#a18e034eee97f9732b884117e0234276d">index_tree_node_end()</a>, and <a class="el" href="structindex__tree.html#ab2ae1f4d920234d6c9e458707c79cfb4">index_tree::root</a>.</p>

<p>Referenced by <a class="el" href="index_8c.html#a0cc239b8b51d743b420293025c167eed">index_stream_end()</a>, and <a class="el" href="index_8c.html#a7aade93273d56c5cf62e4fd02f10c791">lzma_index_end()</a>.</p>

</div>
</div>
<a class="anchor" id="a8a3b2b95c1953a8cf7f9fa88316081fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void index_tree_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structindex__tree.html">index_tree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="index_8c.html#a7d9c96f29c685f30b42c9abdd307d8a6">index_tree_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a new node to the tree. node-&gt;uncompressed_base and node-&gt;compressed_base must have been set by the caller already. </p>

<p>References <a class="el" href="structindex__tree__node__s.html#a9d6408ee6c8682141d1ebff3ec17865d">index_tree_node_s::compressed_base</a>, <a class="el" href="structindex__tree.html#a2d179c6d1bd9b27954ec9deef213e3a4">index_tree::count</a>, <a class="el" href="structindex__tree.html#a89caf3c87135b5b5643e97e7d3725e21">index_tree::leftmost</a>, <a class="el" href="structindex__tree.html#a05f2ab2260c8b193e122f2be4b0298d4">index_tree::rightmost</a>, <a class="el" href="structindex__tree.html#ab2ae1f4d920234d6c9e458707c79cfb4">index_tree::root</a>, and <a class="el" href="structindex__tree__node__s.html#a16b23fdd5d86576ba3c8b0be7e693f0e">index_tree_node_s::uncompressed_base</a>.</p>

<p>Referenced by <a class="el" href="index_8c.html#ae84b534588169c7490e8fe61c141b1d6">index_cat_helper()</a>, <a class="el" href="index_8c.html#a2db488e0703ae8bb890202d505b1d82d">index_dup_stream()</a>, <a class="el" href="index_8c.html#a37a3414069a2bcf3cae1baa52c455441">lzma_index_append()</a>, <a class="el" href="index_8c.html#a8ac8a428e781dc92e6839cb15f7a458d">lzma_index_dup()</a>, and <a class="el" href="index_8c.html#aa40bf2bf3abd7914e643cdb42edac896">lzma_index_init()</a>.</p>

</div>
</div>
<a class="anchor" id="a9043c7fea3feef371dd37abbc7db14ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* index_tree_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="index_8c.html#a7d9c96f29c685f30b42c9abdd307d8a6">index_tree_node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the next node in the tree. Return NULL if there are no more nodes. </p>

<p>Referenced by <a class="el" href="index_8c.html#a2db488e0703ae8bb890202d505b1d82d">index_dup_stream()</a>, <a class="el" href="index_8c.html#a8ac8a428e781dc92e6839cb15f7a458d">lzma_index_dup()</a>, and <a class="el" href="index_8c.html#a994bd6d74fc850b3a9c4154157b6e5d4">lzma_index_iter_next()</a>.</p>

</div>
</div>
<a class="anchor" id="ac6795607a0d3881e5fff569a82d01415"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* index_tree_locate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structindex__tree.html">index_tree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Locate a node that contains the given uncompressed offset. It is caller's job to check that target is not bigger than the uncompressed size of the tree (the last node would be returned in that case still). </p>

<p>References <a class="el" href="structindex__tree.html#a89caf3c87135b5b5643e97e7d3725e21">index_tree::leftmost</a>, <a class="el" href="structindex__tree.html#ab2ae1f4d920234d6c9e458707c79cfb4">index_tree::root</a>, and <a class="el" href="structindex__tree__node__s.html#a16b23fdd5d86576ba3c8b0be7e693f0e">index_tree_node_s::uncompressed_base</a>.</p>

<p>Referenced by <a class="el" href="index_8c.html#acd683a56b01af334964addb246f78349">lzma_index_iter_locate()</a>.</p>

</div>
</div>
<a class="anchor" id="a2735b9fc95daaac1420cd6ebae2a2fa8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structindex__stream.html">index_stream</a>* index_stream_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td>
          <td class="paramname"><em>compressed_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td>
          <td class="paramname"><em>uncompressed_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td>
          <td class="paramname"><em>stream_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td>
          <td class="paramname"><em>block_number_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate and initialize a new Stream using the given base offsets. </p>

<p>References <a class="el" href="structindex__stream.html#a7cd8ca2b0ebfaee95e02065eda6fd38b">index_stream::block_number_base</a>, <a class="el" href="structindex__tree__node__s.html#a9d6408ee6c8682141d1ebff3ec17865d">index_tree_node_s::compressed_base</a>, <a class="el" href="structindex__stream.html#a9e6b322459a5b7b8806154ac9170d1c8">index_stream::groups</a>, <a class="el" href="structindex__stream.html#a631ced838a2c6389d920e57dc1edd016">index_stream::index_list_size</a>, <a class="el" href="common_8h.html#ac58f96267a4f66bb15db736968b98008">lzma_alloc()</a>, <a class="el" href="structindex__stream.html#a641dcc01e11966039a512b83dccdcd3c">index_stream::node</a>, <a class="el" href="structindex__stream.html#a6430d10f4bc8ebd6a90bf0ecc93b9431">index_stream::number</a>, <a class="el" href="structindex__stream.html#aef7ff4cbade21b89bf2b5c58dc46acf9">index_stream::record_count</a>, <a class="el" href="structindex__stream.html#ac6af5abc8801131038c79fbde165e064">index_stream::stream_flags</a>, <a class="el" href="structindex__stream.html#aedd50053d69a45984cd5470eecc736a2">index_stream::stream_padding</a>, <a class="el" href="structindex__tree__node__s.html#a16b23fdd5d86576ba3c8b0be7e693f0e">index_tree_node_s::uncompressed_base</a>, and <a class="el" href="structlzma__stream__flags.html#a61e9151869d5b77c868aaa4958e74d10">lzma_stream_flags::version</a>.</p>

<p>Referenced by <a class="el" href="index_8c.html#a2db488e0703ae8bb890202d505b1d82d">index_dup_stream()</a>, and <a class="el" href="index_8c.html#aa40bf2bf3abd7914e643cdb42edac896">lzma_index_init()</a>.</p>

</div>
</div>
<a class="anchor" id="a0cc239b8b51d743b420293025c167eed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void index_stream_end </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free the memory allocated for a Stream and its Record groups. </p>

<p>References <a class="el" href="structindex__stream.html#a9e6b322459a5b7b8806154ac9170d1c8">index_stream::groups</a>, and <a class="el" href="index_8c.html#ad0843d99b4a243fbcd4b4a52f1758d8c">index_tree_end()</a>.</p>

<p>Referenced by <a class="el" href="index_8c.html#a2db488e0703ae8bb890202d505b1d82d">index_dup_stream()</a>, and <a class="el" href="index_8c.html#a7aade93273d56c5cf62e4fd02f10c791">lzma_index_end()</a>.</p>

</div>
</div>
<a class="anchor" id="aa40bf2bf3abd7914e643cdb42edac896"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a>* lzma_index_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize a new lzma_index structure. </p>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to an empty initialized lzma_index is returned. If allocation fails, NULL is returned. </dd></dl>

<p>References <a class="el" href="index_8c.html#a2735b9fc95daaac1420cd6ebae2a2fa8">index_stream_init()</a>, <a class="el" href="index_8c.html#a8a3b2b95c1953a8cf7f9fa88316081fc">index_tree_append()</a>, <a class="el" href="structindex__stream.html#a641dcc01e11966039a512b83dccdcd3c">index_stream::node</a>, and <a class="el" href="structlzma__index__s.html#a4dbed779040f4a7bad495a629d27e919">lzma_index_s::streams</a>.</p>

<p>Referenced by <a class="el" href="stream__buffer__encoder_8c.html#a932a602de4f44d8525687698e51ce93d">lzma_stream_buffer_encode()</a>.</p>

</div>
</div>
<a class="anchor" id="a7aade93273d56c5cf62e4fd02f10c791"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lzma_index_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate lzma_index. </p>
<p>If i is NULL, this does nothing. </p>

<p>References <a class="el" href="index_8c.html#a0cc239b8b51d743b420293025c167eed">index_stream_end()</a>, and <a class="el" href="index_8c.html#ad0843d99b4a243fbcd4b4a52f1758d8c">index_tree_end()</a>.</p>

<p>Referenced by <a class="el" href="list_8h.html#a2b9bdcc3cdcc48e99a29e178df9d4899">list_file()</a>, <a class="el" href="index__decoder_8c.html#a81533a8f0a676b67380e6bd0a255f9df">lzma_index_buffer_decode()</a>, <a class="el" href="index_8c.html#a8ac8a428e781dc92e6839cb15f7a458d">lzma_index_dup()</a>, <a class="el" href="stream__buffer__encoder_8c.html#a932a602de4f44d8525687698e51ce93d">lzma_stream_buffer_encode()</a>, and <a class="el" href="list_8c.html#ada243f83a8540051b161d0a114ef8f24">parse_indexes()</a>.</p>

</div>
</div>
<a class="anchor" id="a017afdd81c6a8410f3148d82dca671c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lzma_index_prealloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td>
          <td class="paramname"><em>records</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set for how many Records to allocate memory the next time <a class="el" href="api_2lzma_2index_8h.html#aad24f1d4784b7c665b27ae91b52d3bd1" title="Add a new Block to lzma_index.">lzma_index_append()</a> needs to allocate space for a new Record. This is used only by the Index decoder. </p>

<p>References <a class="el" href="structlzma__index__s.html#abf85208d42ea5923a68dc120c0620baf">lzma_index_s::prealloc</a>, and <a class="el" href="index_8c.html#a5611619fba202b1641dca31ec9b8f716">PREALLOC_MAX</a>.</p>

</div>
</div>
<a class="anchor" id="a520a04acfa6fedd5ea32ce8af29339ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lzma_index_memusage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td>
          <td class="paramname"><em>streams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td>
          <td class="paramname"><em>blocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate memory usage of lzma_index. </p>
<p>On disk, the size of the Index field depends on both the number of Records stored and how big values the Records store (due to variable-length integer encoding). When the Index is kept in lzma_index structure, the memory usage depends only on the number of Records/Blocks stored in the Index(es), and in case of concatenated lzma_indexes, the number of Streams. The size in RAM is almost always significantly bigger than in the encoded form on disk.</p>
<p>This function calculates an approximate amount of memory needed hold the given number of Streams and Blocks in lzma_index structure. This value may vary between CPU architectures and also between liblzma versions if the internal implementation is modified. </p>

<p>References <a class="el" href="index_8c.html#a5083e2e588a600088db6cea759e07437">INDEX_GROUP_SIZE</a>, and <a class="el" href="vli_8h.html#a7b782528bd1934db7c020adbedb20ec9">LZMA_VLI_MAX</a>.</p>

<p>Referenced by <a class="el" href="index__decoder_8c.html#a81533a8f0a676b67380e6bd0a255f9df">lzma_index_buffer_decode()</a>, and <a class="el" href="index_8c.html#ae39293600748764d3b1ee02ebb65e947">lzma_index_memused()</a>.</p>

</div>
</div>
<a class="anchor" id="ae39293600748764d3b1ee02ebb65e947"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lzma_index_memused </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the memory usage of an existing lzma_index. </p>
<p>This is a shorthand for lzma_index_memusage(lzma_index_stream_count(i), lzma_index_block_count(i)). </p>

<p>References <a class="el" href="api_2lzma_2index_8h.html#a880def3727ecdd7f242807083d228fc5">lzma_index_memusage()</a>.</p>

<p>Referenced by <a class="el" href="list_8c.html#ada243f83a8540051b161d0a114ef8f24">parse_indexes()</a>.</p>

</div>
</div>
<a class="anchor" id="aed1d3357be8dded98a7ec86733e86fc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> lzma_index_block_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of Blocks. </p>
<p>This returns the total number of Blocks in lzma_index. To get number of Blocks in individual Streams, use <a class="el" href="structlzma__index__iter.html" title="Iterator to get information about Blocks and Streams.">lzma_index_iter</a>. </p>

</div>
</div>
<a class="anchor" id="a265c5858f2a4a3c1da8ff4ab4e1ef373"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> lzma_index_stream_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of Streams. </p>

</div>
</div>
<a class="anchor" id="a64bd8a338f577f0aca7b79c57e4ec23a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> lzma_index_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of the Index field as bytes. </p>
<p>This is needed to verify the Backward Size field in the Stream Footer. </p>

<p>Referenced by <a class="el" href="index__encoder_8c.html#a9a6a4b09464a3edc101ff4f4b1f49917">lzma_index_buffer_encode()</a>, and <a class="el" href="stream__buffer__encoder_8c.html#a932a602de4f44d8525687698e51ce93d">lzma_stream_buffer_encode()</a>.</p>

</div>
</div>
<a class="anchor" id="a4a82baf907d73223d2bd2c7e75ef7b73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> lzma_index_total_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total size of the Blocks. </p>
<p>This doesn't include the Stream Header, Stream Footer, Stream Padding, or Index fields. </p>

<p>Referenced by <a class="el" href="list_8c.html#ada243f83a8540051b161d0a114ef8f24">parse_indexes()</a>.</p>

</div>
</div>
<a class="anchor" id="aeb6ff3d3757d20496d866b531f0d92b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> lzma_index_stream_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total size of the Stream. </p>
<p>If multiple lzma_indexes have been combined, this works as if the Blocks were in a single Stream. This is useful if you are going to combine Blocks from multiple Streams into a single new Stream. </p>

<p>References <a class="el" href="stream__flags_8h.html#ada7e0a4f5e7146f547962cb9e9ef08ee">LZMA_STREAM_HEADER_SIZE</a>.</p>

</div>
</div>
<a class="anchor" id="ad4d3746aadd411799d806a3dd5cbe7b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> lzma_index_file_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total size of the file. </p>
<p>When no lzma_indexes have been combined with <a class="el" href="api_2lzma_2index_8h.html#a13f17bbd42eb4702985d035336ea11d6" title="Concatenate lzma_indexes.">lzma_index_cat()</a> and there is no Stream Padding, this function is identical to <a class="el" href="api_2lzma_2index_8h.html#af3630369b43c9ccc906065d759b49663" title="Get the total size of the Stream.">lzma_index_stream_size()</a>. If multiple lzma_indexes have been combined, this includes also the headers of each separate Stream and the possible Stream Padding fields. </p>

<p>References <a class="el" href="structindex__tree__node__s.html#a9d6408ee6c8682141d1ebff3ec17865d">index_tree_node_s::compressed_base</a>, <a class="el" href="structindex__stream.html#a9e6b322459a5b7b8806154ac9170d1c8">index_stream::groups</a>, <a class="el" href="structindex__stream.html#a631ced838a2c6389d920e57dc1edd016">index_stream::index_list_size</a>, <a class="el" href="structindex__group.html#a72f07e1a884c09ee2818671e5ca32222">index_group::last</a>, <a class="el" href="structindex__stream.html#a641dcc01e11966039a512b83dccdcd3c">index_stream::node</a>, <a class="el" href="structindex__stream.html#aef7ff4cbade21b89bf2b5c58dc46acf9">index_stream::record_count</a>, <a class="el" href="structindex__group.html#af0e6e330aff607120ff7ffd2467c2c70">index_group::records</a>, <a class="el" href="structindex__tree.html#a05f2ab2260c8b193e122f2be4b0298d4">index_tree::rightmost</a>, and <a class="el" href="structindex__stream.html#aedd50053d69a45984cd5470eecc736a2">index_stream::stream_padding</a>.</p>

<p>Referenced by <a class="el" href="index_8c.html#ad1de7c81bb1f94177dd0d1240e1ed652">lzma_index_stream_padding()</a>.</p>

</div>
</div>
<a class="anchor" id="a3d993c8e6e73717fbb2b415820f8c712"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> lzma_index_uncompressed_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the uncompressed size of the file. </p>

</div>
</div>
<a class="anchor" id="abc4e1a0927e07f5580c9f66dbcec3bc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lzma_index_checks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the types of integrity Checks. </p>
<p>If <a class="el" href="api_2lzma_2index_8h.html#a79a19669237f19f0b11c9f3be80a62b4" title="Set the Stream Flags.">lzma_index_stream_flags()</a> is used to set the Stream Flags for every Stream, <a class="el" href="api_2lzma_2index_8h.html#af8d6528a04241841bd0a4322b0c57eaa" title="Get the types of integrity Checks.">lzma_index_checks()</a> can be used to get a bitmask to indicate which Check types have been used. It can be useful e.g. if showing the Check types to the user.</p>
<p>The bitmask is 1 &lt;&lt; check_id, e.g. CRC32 is 1 &lt;&lt; 1 and SHA-256 is 1 &lt;&lt; 10. </p>

<p>References <a class="el" href="structlzma__stream__flags.html#ab1052ea7047c8d67f127f33278166647">lzma_stream_flags::check</a>, <a class="el" href="structindex__stream.html#ac6af5abc8801131038c79fbde165e064">index_stream::stream_flags</a>, and <a class="el" href="structlzma__stream__flags.html#a61e9151869d5b77c868aaa4958e74d10">lzma_stream_flags::version</a>.</p>

</div>
</div>
<a class="anchor" id="ab88435af7c81e25208df2d831fcf5b6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lzma_index_padding_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the size of the Index Padding field. This is needed by Index encoder and decoder, but applications should have no use for this. </p>

<p>References <a class="el" href="structlzma__index__s.html#a69f2a4f80181ffce53aeb73cc135a923">lzma_index_s::index_list_size</a>, <a class="el" href="vli_8h.html#a2d8bf5322898bfa11945848420585881">LZMA_VLI_C</a>, and <a class="el" href="structlzma__index__s.html#a94bbe86623f812d8742da7e545ed5d88">lzma_index_s::record_count</a>.</p>

</div>
</div>
<a class="anchor" id="ad427e6894af982f7443c677bfbe4b856"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_index_stream_flags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlzma__stream__flags.html">lzma_stream_flags</a> *&#160;</td>
          <td class="paramname"><em>stream_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Stream Flags. </p>
<p>Set the Stream Flags of the last (and typically the only) Stream in lzma_index. This can be useful when reading information from the lzma_index, because to decode Blocks, knowing the integrity check type is needed.</p>
<p>The given Stream Flags are copied into internal preallocated structure in the lzma_index, thus the caller doesn't need to keep the *stream_flags available after calling this function.</p>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK<ul>
<li>LZMA_OPTIONS_ERROR: Unsupported stream_flags-&gt;version.</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

<p>References <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea2dac8d451cb38da8550653d0d7be4ec2">LZMA_PROG_ERROR</a>, <a class="el" href="stream__flags_8h.html#a3e25ca4205021302882a696283d45263">lzma_stream_flags_compare()</a>, <a class="el" href="common_8h.html#a3e1bf9f33b917e883b886b8a10458d66">return_if_error</a>, and <a class="el" href="structindex__stream.html#ac6af5abc8801131038c79fbde165e064">index_stream::stream_flags</a>.</p>

<p>Referenced by <a class="el" href="list_8c.html#ada243f83a8540051b161d0a114ef8f24">parse_indexes()</a>.</p>

</div>
</div>
<a class="anchor" id="ad1de7c81bb1f94177dd0d1240e1ed652"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_index_stream_padding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td>
          <td class="paramname"><em>stream_padding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the amount of Stream Padding. </p>
<p>Set the amount of Stream Padding of the last (and typically the only) Stream in the lzma_index. This is needed when planning to do random-access reading within multiple concatenated Streams.</p>
<p>By default, the amount of Stream Padding is assumed to be zero bytes.</p>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK<ul>
<li>LZMA_DATA_ERROR: The file size would grow too big.</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

<p>References <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea3aa72729a844790e39b4e1101a731dfb">LZMA_DATA_ERROR</a>, <a class="el" href="api_2lzma_2index_8h.html#ac875ed47d35385e5dac461b25c5ea1c9">lzma_index_file_size()</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea2dac8d451cb38da8550653d0d7be4ec2">LZMA_PROG_ERROR</a>, <a class="el" href="vli_8h.html#a7b782528bd1934db7c020adbedb20ec9">LZMA_VLI_MAX</a>, and <a class="el" href="structindex__stream.html#aedd50053d69a45984cd5470eecc736a2">index_stream::stream_padding</a>.</p>

<p>Referenced by <a class="el" href="list_8c.html#ada243f83a8540051b161d0a114ef8f24">parse_indexes()</a>.</p>

</div>
</div>
<a class="anchor" id="a37a3414069a2bcf3cae1baa52c455441"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_index_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td>
          <td class="paramname"><em>unpadded_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td>
          <td class="paramname"><em>uncompressed_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new Block to lzma_index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to a lzma_index structure </td></tr>
    <tr><td class="paramname">allocator</td><td>Pointer to <a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a>, or NULL to use malloc() </td></tr>
    <tr><td class="paramname">unpadded_size</td><td>Unpadded Size of a Block. This can be calculated with <a class="el" href="block_8h.html#a412d5605280fa29befae1b89e344bf30" title="Calculate Unpadded Size.">lzma_block_unpadded_size()</a> after encoding or decoding the Block. </td></tr>
    <tr><td class="paramname">uncompressed_size</td><td>Uncompressed Size of a Block. This can be taken directly from <a class="el" href="structlzma__block.html" title="Options for the Block and Block Header encoders and decoders.">lzma_block</a> structure after encoding or decoding the Block.</td></tr>
  </table>
  </dd>
</dl>
<p>Appending a new Block does not invalidate iterators. For example, if an iterator was pointing to the end of the lzma_index, after <a class="el" href="api_2lzma_2index_8h.html#aad24f1d4784b7c665b27ae91b52d3bd1" title="Add a new Block to lzma_index.">lzma_index_append()</a> it is possible to read the next Block with an existing iterator.</p>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK<ul>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_DATA_ERROR: Compressed or uncompressed size of the Stream or size of the Index field would grow too big.</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

<p>References <a class="el" href="structindex__group.html#ab741e763843d5492a307bfb71cb82ff6">index_group::allocated</a>, <a class="el" href="structindex__tree__node__s.html#a9d6408ee6c8682141d1ebff3ec17865d">index_tree_node_s::compressed_base</a>, <a class="el" href="structindex__stream.html#a9e6b322459a5b7b8806154ac9170d1c8">index_stream::groups</a>, <a class="el" href="index_8c.html#a5083e2e588a600088db6cea759e07437">INDEX_GROUP_SIZE</a>, <a class="el" href="structindex__stream.html#a631ced838a2c6389d920e57dc1edd016">index_stream::index_list_size</a>, <a class="el" href="index_8c.html#a8a3b2b95c1953a8cf7f9fa88316081fc">index_tree_append()</a>, <a class="el" href="structindex__group.html#a72f07e1a884c09ee2818671e5ca32222">index_group::last</a>, <a class="el" href="common_8h.html#ac58f96267a4f66bb15db736968b98008">lzma_alloc()</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea3aa72729a844790e39b4e1101a731dfb">LZMA_DATA_ERROR</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea567e1464feca03900a5425fb45b2f5b6">LZMA_MEM_ERROR</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea2dac8d451cb38da8550653d0d7be4ec2">LZMA_PROG_ERROR</a>, <a class="el" href="vli_8h.html#a7b782528bd1934db7c020adbedb20ec9">LZMA_VLI_MAX</a>, <a class="el" href="vli_8h.html#a8d53e0b69934b43da8721fa6f1e8cc4f">lzma_vli_size()</a>, <a class="el" href="vli_8h.html#a5a4b28254a30c859018b896ed371d69a">LZMA_VLI_UNKNOWN</a>, <a class="el" href="structindex__group.html#ad684ad25ae558b53a3c77d56489b7009">index_group::node</a>, <a class="el" href="structindex__stream.html#a641dcc01e11966039a512b83dccdcd3c">index_stream::node</a>, <a class="el" href="structindex__group.html#a8b7eba508bb2cf92b23e8aefb7ad0cd9">index_group::number_base</a>, <a class="el" href="structindex__stream.html#aef7ff4cbade21b89bf2b5c58dc46acf9">index_stream::record_count</a>, <a class="el" href="structindex__group.html#af0e6e330aff607120ff7ffd2467c2c70">index_group::records</a>, <a class="el" href="structindex__tree.html#a05f2ab2260c8b193e122f2be4b0298d4">index_tree::rightmost</a>, <a class="el" href="structindex__stream.html#aedd50053d69a45984cd5470eecc736a2">index_stream::stream_padding</a>, and <a class="el" href="structindex__tree__node__s.html#a16b23fdd5d86576ba3c8b0be7e693f0e">index_tree_node_s::uncompressed_base</a>.</p>

<p>Referenced by <a class="el" href="stream__buffer__encoder_8c.html#a932a602de4f44d8525687698e51ce93d">lzma_stream_buffer_encode()</a>.</p>

</div>
</div>
<a class="anchor" id="ae84b534588169c7490e8fe61c141b1d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void index_cat_helper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structindex__cat__info.html">index_cat_info</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structindex__stream.html">index_stream</a> *&#160;</td>
          <td class="paramname"><em>this</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add the Stream nodes from the source index to dest using recursion. Simplest iterative traversal of the source tree wouldn't work, because we update the pointers in nodes when moving them to the destination tree. </p>

<p>References <a class="el" href="structindex__cat__info.html#a38ecede14d155c2dc5573996148dbc5c">index_cat_info::block_number_add</a>, <a class="el" href="structindex__tree__node__s.html#a9d6408ee6c8682141d1ebff3ec17865d">index_tree_node_s::compressed_base</a>, <a class="el" href="structindex__cat__info.html#a20eb62c8cea344df17c73fa3caa43464">index_cat_info::file_size</a>, <a class="el" href="index_8c.html#a8a3b2b95c1953a8cf7f9fa88316081fc">index_tree_append()</a>, <a class="el" href="structindex__cat__info.html#a770ca8ec4b86841be5112ab040ea7f52">index_cat_info::stream_number_add</a>, <a class="el" href="structindex__cat__info.html#a1770333e66d324649acc671813c97a71">index_cat_info::streams</a>, <a class="el" href="structindex__tree__node__s.html#a16b23fdd5d86576ba3c8b0be7e693f0e">index_tree_node_s::uncompressed_base</a>, and <a class="el" href="structindex__cat__info.html#a94d35c197825ad1522a017dd7c21e164">index_cat_info::uncompressed_size</a>.</p>

</div>
</div>
<a class="anchor" id="a2db488e0703ae8bb890202d505b1d82d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structindex__stream.html">index_stream</a>* index_dup_stream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structindex__stream.html">index_stream</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Duplicate an <a class="el" href="structindex__stream.html">index_stream</a>. </p>

<p>References <a class="el" href="structindex__group.html#ab741e763843d5492a307bfb71cb82ff6">index_group::allocated</a>, <a class="el" href="structindex__stream.html#a7cd8ca2b0ebfaee95e02065eda6fd38b">index_stream::block_number_base</a>, <a class="el" href="structindex__tree__node__s.html#a9d6408ee6c8682141d1ebff3ec17865d">index_tree_node_s::compressed_base</a>, <a class="el" href="structindex__stream.html#a9e6b322459a5b7b8806154ac9170d1c8">index_stream::groups</a>, <a class="el" href="structindex__stream.html#a631ced838a2c6389d920e57dc1edd016">index_stream::index_list_size</a>, <a class="el" href="index_8c.html#a0cc239b8b51d743b420293025c167eed">index_stream_end()</a>, <a class="el" href="index_8c.html#a2735b9fc95daaac1420cd6ebae2a2fa8">index_stream_init()</a>, <a class="el" href="index_8c.html#a8a3b2b95c1953a8cf7f9fa88316081fc">index_tree_append()</a>, <a class="el" href="index_8c.html#a9043c7fea3feef371dd37abbc7db14ab">index_tree_next()</a>, <a class="el" href="structindex__group.html#a72f07e1a884c09ee2818671e5ca32222">index_group::last</a>, <a class="el" href="structindex__tree.html#a89caf3c87135b5b5643e97e7d3725e21">index_tree::leftmost</a>, <a class="el" href="common_8h.html#ac58f96267a4f66bb15db736968b98008">lzma_alloc()</a>, <a class="el" href="structindex__group.html#ad684ad25ae558b53a3c77d56489b7009">index_group::node</a>, <a class="el" href="structindex__stream.html#a641dcc01e11966039a512b83dccdcd3c">index_stream::node</a>, <a class="el" href="structindex__stream.html#a6430d10f4bc8ebd6a90bf0ecc93b9431">index_stream::number</a>, <a class="el" href="structindex__group.html#a8b7eba508bb2cf92b23e8aefb7ad0cd9">index_group::number_base</a>, <a class="el" href="index_8c.html#a5611619fba202b1641dca31ec9b8f716">PREALLOC_MAX</a>, <a class="el" href="structindex__stream.html#aef7ff4cbade21b89bf2b5c58dc46acf9">index_stream::record_count</a>, <a class="el" href="structindex__group.html#af0e6e330aff607120ff7ffd2467c2c70">index_group::records</a>, <a class="el" href="structindex__stream.html#ac6af5abc8801131038c79fbde165e064">index_stream::stream_flags</a>, <a class="el" href="structindex__stream.html#aedd50053d69a45984cd5470eecc736a2">index_stream::stream_padding</a>, and <a class="el" href="structindex__tree__node__s.html#a16b23fdd5d86576ba3c8b0be7e693f0e">index_tree_node_s::uncompressed_base</a>.</p>

<p>Referenced by <a class="el" href="index_8c.html#a8ac8a428e781dc92e6839cb15f7a458d">lzma_index_dup()</a>.</p>

</div>
</div>
<a class="anchor" id="a8ac8a428e781dc92e6839cb15f7a458d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a>* lzma_index_dup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate lzma_index. </p>
<dl class="section return"><dt>Returns</dt><dd>A copy of the lzma_index, or NULL if memory allocation failed. </dd></dl>

<p>References <a class="el" href="index_8c.html#a2db488e0703ae8bb890202d505b1d82d">index_dup_stream()</a>, <a class="el" href="structlzma__index__s.html#a69f2a4f80181ffce53aeb73cc135a923">lzma_index_s::index_list_size</a>, <a class="el" href="index_8c.html#a8a3b2b95c1953a8cf7f9fa88316081fc">index_tree_append()</a>, <a class="el" href="index_8c.html#a9043c7fea3feef371dd37abbc7db14ab">index_tree_next()</a>, <a class="el" href="api_2lzma_2index_8h.html#a469f89689529ea250969bb64f80ab874">lzma_index_end()</a>, <a class="el" href="structindex__stream.html#a641dcc01e11966039a512b83dccdcd3c">index_stream::node</a>, <a class="el" href="structlzma__index__s.html#a94bbe86623f812d8742da7e545ed5d88">lzma_index_s::record_count</a>, <a class="el" href="structlzma__index__s.html#a4dbed779040f4a7bad495a629d27e919">lzma_index_s::streams</a>, <a class="el" href="structlzma__index__s.html#a1e3767d5bad6704d797c5b447467ec75">lzma_index_s::total_size</a>, and <a class="el" href="structlzma__index__s.html#ac26ac10364bd7861c8e2afecd024c4ba">lzma_index_s::uncompressed_size</a>.</p>

</div>
</div>
<a class="anchor" id="a206339df8447737452aa6870d101065b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lzma_index_iter_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__index__iter.html">lzma_index_iter</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>Pointer to a <a class="el" href="structlzma__index__iter.html" title="Iterator to get information about Blocks and Streams.">lzma_index_iter</a> structure </td></tr>
    <tr><td class="paramname">i</td><td>lzma_index to which the iterator will be associated</td></tr>
  </table>
  </dd>
</dl>
<p>This function associates the iterator with the given lzma_index, and calls <a class="el" href="api_2lzma_2index_8h.html#ae81438be8deff4894b104e65d8acdd24" title="Rewind the iterator.">lzma_index_iter_rewind()</a> on the iterator.</p>
<p>This function doesn't allocate any memory, thus there is no lzma_index_iter_end(). The iterator is valid as long as the associated lzma_index is valid, that is, until <a class="el" href="api_2lzma_2index_8h.html#a469f89689529ea250969bb64f80ab874" title="Deallocate lzma_index.">lzma_index_end()</a> or using it as source in <a class="el" href="api_2lzma_2index_8h.html#a13f17bbd42eb4702985d035336ea11d6" title="Concatenate lzma_indexes.">lzma_index_cat()</a>. Specifically, lzma_index doesn't become invalid if new Blocks are added to it with <a class="el" href="api_2lzma_2index_8h.html#aad24f1d4784b7c665b27ae91b52d3bd1" title="Add a new Block to lzma_index.">lzma_index_append()</a> or if it is used as the destination in <a class="el" href="api_2lzma_2index_8h.html#a13f17bbd42eb4702985d035336ea11d6" title="Concatenate lzma_indexes.">lzma_index_cat()</a>.</p>
<p>It is safe to make copies of an initialized <a class="el" href="structlzma__index__iter.html" title="Iterator to get information about Blocks and Streams.">lzma_index_iter</a>, for example, to easily restart reading at some particular position. </p>

<p>References <a class="el" href="api_2lzma_2index_8h.html#ae81438be8deff4894b104e65d8acdd24">lzma_index_iter_rewind()</a>.</p>

</div>
</div>
<a class="anchor" id="aed644650074bf3ee087f4f2b31b8aacd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lzma_index_iter_rewind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__index__iter.html">lzma_index_iter</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewind the iterator. </p>
<p>Rewind the iterator so that next call to <a class="el" href="api_2lzma_2index_8h.html#af428522e1b3eef137c65c5a01f766e0e" title="Get the next Block or Stream.">lzma_index_iter_next()</a> will return the first Block or Stream. </p>

<p>Referenced by <a class="el" href="index_8c.html#a206339df8447737452aa6870d101065b">lzma_index_iter_init()</a>.</p>

</div>
</div>
<a class="anchor" id="a994bd6d74fc850b3a9c4154157b6e5d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#abbc819c74b484c846825ae1388a50a59">lzma_bool</a> lzma_index_iter_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__index__iter.html">lzma_index_iter</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2lzma_2index_8h.html#a712b43192d944bf2f767711343cd9ca8">lzma_index_iter_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next Block or Stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>Iterator initialized with <a class="el" href="api_2lzma_2index_8h.html#aa78f02f18ed29d289a6ef37b8ea98a21" title="Initialize an iterator.">lzma_index_iter_init()</a> </td></tr>
    <tr><td class="paramname">mode</td><td>Specify what kind of information the caller wants to get. See lzma_index_iter_mode for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If next Block or Stream matching the mode was found, *iter is updated and this function returns false. If no Block or Stream matching the mode is found, *iter is not modified and this function returns true. If mode is set to an unknown value, *iter is not modified and this function returns true. </dd></dl>

<p>References <a class="el" href="structindex__stream.html#a9e6b322459a5b7b8806154ac9170d1c8">index_stream::groups</a>, <a class="el" href="index_8c.html#a9043c7fea3feef371dd37abbc7db14ab">index_tree_next()</a>, <a class="el" href="structindex__tree.html#a89caf3c87135b5b5643e97e7d3725e21">index_tree::leftmost</a>, <a class="el" href="api_2lzma_2index_8h.html#a712b43192d944bf2f767711343cd9ca8a2702617d60d6fc15138a749e06ef3414">LZMA_INDEX_ITER_BLOCK</a>, <a class="el" href="api_2lzma_2index_8h.html#a712b43192d944bf2f767711343cd9ca8aa49bf4d561d8f2c61d300edbb6c282c7">LZMA_INDEX_ITER_NONEMPTY_BLOCK</a>, <a class="el" href="api_2lzma_2index_8h.html#a712b43192d944bf2f767711343cd9ca8a5b31d985de1c823151acdd7e4a966fc9">LZMA_INDEX_ITER_STREAM</a>, <a class="el" href="structindex__group.html#ad684ad25ae558b53a3c77d56489b7009">index_group::node</a>, <a class="el" href="structindex__stream.html#a641dcc01e11966039a512b83dccdcd3c">index_stream::node</a>, <a class="el" href="structindex__group.html#af0e6e330aff607120ff7ffd2467c2c70">index_group::records</a>, <a class="el" href="structlzma__index__s.html#a4dbed779040f4a7bad495a629d27e919">lzma_index_s::streams</a>, and <a class="el" href="structindex__tree__node__s.html#a16b23fdd5d86576ba3c8b0be7e693f0e">index_tree_node_s::uncompressed_base</a>.</p>

</div>
</div>
<a class="anchor" id="acd683a56b01af334964addb246f78349"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#abbc819c74b484c846825ae1388a50a59">lzma_bool</a> lzma_index_iter_locate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__index__iter.html">lzma_index_iter</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locate a Block. </p>
<p>If it is possible to seek in the .xz file, it is possible to parse the Index field(s) and use <a class="el" href="api_2lzma_2index_8h.html#ac4f56df9d210712e5d7add5502c9eb93" title="Locate a Block.">lzma_index_iter_locate()</a> to do random-access reading with granularity of Block size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>Iterator that was earlier initialized with <a class="el" href="api_2lzma_2index_8h.html#aa78f02f18ed29d289a6ef37b8ea98a21" title="Initialize an iterator.">lzma_index_iter_init()</a>. </td></tr>
    <tr><td class="paramname">target</td><td>Uncompressed target offset which the caller would like to locate from the Stream</td></tr>
  </table>
  </dd>
</dl>
<p>If the target is smaller than the uncompressed size of the Stream (can be checked with <a class="el" href="api_2lzma_2index_8h.html#a620fe6317f1f9d7af9cc27c748bf07d6" title="Get the uncompressed size of the file.">lzma_index_uncompressed_size()</a>):</p>
<ul>
<li>Information about the Stream and Block containing the requested uncompressed offset is stored into *iter.</li>
<li>Internal state of the iterator is adjusted so that <a class="el" href="api_2lzma_2index_8h.html#af428522e1b3eef137c65c5a01f766e0e" title="Get the next Block or Stream.">lzma_index_iter_next()</a> can be used to read subsequent Blocks or Streams.</li>
<li>This function returns false.</li>
</ul>
<p>If target is greater than the uncompressed size of the Stream, *iter is not modified, and this function returns true. </p>

<p>References <a class="el" href="structindex__stream.html#a9e6b322459a5b7b8806154ac9170d1c8">index_stream::groups</a>, <a class="el" href="index_8c.html#ac6795607a0d3881e5fff569a82d01415">index_tree_locate()</a>, <a class="el" href="structindex__group.html#a72f07e1a884c09ee2818671e5ca32222">index_group::last</a>, <a class="el" href="structindex__stream.html#a641dcc01e11966039a512b83dccdcd3c">index_stream::node</a>, <a class="el" href="structindex__group.html#af0e6e330aff607120ff7ffd2467c2c70">index_group::records</a>, <a class="el" href="structlzma__index__s.html#a4dbed779040f4a7bad495a629d27e919">lzma_index_s::streams</a>, <a class="el" href="structindex__tree__node__s.html#a16b23fdd5d86576ba3c8b0be7e693f0e">index_tree_node_s::uncompressed_base</a>, and <a class="el" href="structlzma__index__s.html#ac26ac10364bd7861c8e2afecd024c4ba">lzma_index_s::uncompressed_size</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jun 5 2014 14:19:04 for XZ Utils by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
