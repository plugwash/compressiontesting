<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>XZ Utils: liblzma/api/lzma/index.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">XZ Utils
   &#160;<span id="projectnumber">5.1.0alpha</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2e0898c272e1f0f93c8ef15f5da2a912.html">liblzma</a></li><li class="navelem"><a class="el" href="dir_3c7592c36b11e0fd373edb6a27c72b1d.html">api</a></li><li class="navelem"><a class="el" href="dir_48cf7e51417fe935412ca5117cfff3c4.html">lzma</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">index.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Handling of .xz Index and related information.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__index__iter.html">lzma_index_iter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to get information about Blocks and Streams.  <a href="structlzma__index__iter.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:afc18c1443b3b9aa0d146b44e8755b62e"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structlzma__index__s.html">lzma_index_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a></td></tr>
<tr class="memdesc:afc18c1443b3b9aa0d146b44e8755b62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque data type to hold the Index(es) and other information.  <a href="#afc18c1443b3b9aa0d146b44e8755b62e"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a712b43192d944bf2f767711343cd9ca8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2lzma_2index_8h.html#a712b43192d944bf2f767711343cd9ca8">lzma_index_iter_mode</a> { <a class="el" href="api_2lzma_2index_8h.html#a712b43192d944bf2f767711343cd9ca8af46f6e5c414471c7c96586f380e48315">LZMA_INDEX_ITER_ANY</a> =  0, 
<a class="el" href="api_2lzma_2index_8h.html#a712b43192d944bf2f767711343cd9ca8a5b31d985de1c823151acdd7e4a966fc9">LZMA_INDEX_ITER_STREAM</a> =  1, 
<a class="el" href="api_2lzma_2index_8h.html#a712b43192d944bf2f767711343cd9ca8a2702617d60d6fc15138a749e06ef3414">LZMA_INDEX_ITER_BLOCK</a> =  2, 
<a class="el" href="api_2lzma_2index_8h.html#a712b43192d944bf2f767711343cd9ca8aa49bf4d561d8f2c61d300edbb6c282c7">LZMA_INDEX_ITER_NONEMPTY_BLOCK</a> =  3
 }</td></tr>
<tr class="memdesc:a712b43192d944bf2f767711343cd9ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation mode for <a class="el" href="api_2lzma_2index_8h.html#af428522e1b3eef137c65c5a01f766e0e" title="Get the next Block or Stream.">lzma_index_iter_next()</a>  <a href="api_2lzma_2index_8h.html#a712b43192d944bf2f767711343cd9ca8">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a880def3727ecdd7f242807083d228fc5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2lzma_2index_8h.html#a880def3727ecdd7f242807083d228fc5">lzma_index_memusage</a> (<a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> streams, <a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> blocks) lzma_nothrow</td></tr>
<tr class="memdesc:a880def3727ecdd7f242807083d228fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate memory usage of lzma_index.  <a href="#a880def3727ecdd7f242807083d228fc5"></a><br/></td></tr>
<tr class="memitem:a4118805ac7be6618aca6d6d7e5e4dde7"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2lzma_2index_8h.html#a4118805ac7be6618aca6d6d7e5e4dde7">lzma_index_memused</a> (const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i) lzma_nothrow</td></tr>
<tr class="memdesc:a4118805ac7be6618aca6d6d7e5e4dde7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the memory usage of an existing lzma_index.  <a href="#a4118805ac7be6618aca6d6d7e5e4dde7"></a><br/></td></tr>
<tr class="memitem:ad17c5c45cd2692cc296261a91a4690f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2lzma_2index_8h.html#ad17c5c45cd2692cc296261a91a4690f1">lzma_index_init</a> (<a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator) lzma_nothrow</td></tr>
<tr class="memdesc:ad17c5c45cd2692cc296261a91a4690f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a new lzma_index structure.  <a href="#ad17c5c45cd2692cc296261a91a4690f1"></a><br/></td></tr>
<tr class="memitem:a469f89689529ea250969bb64f80ab874"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2lzma_2index_8h.html#a469f89689529ea250969bb64f80ab874">lzma_index_end</a> (<a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator) lzma_nothrow</td></tr>
<tr class="memdesc:a469f89689529ea250969bb64f80ab874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate lzma_index.  <a href="#a469f89689529ea250969bb64f80ab874"></a><br/></td></tr>
<tr class="memitem:aad24f1d4784b7c665b27ae91b52d3bd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2lzma_2index_8h.html#aad24f1d4784b7c665b27ae91b52d3bd1">lzma_index_append</a> (<a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator, <a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> unpadded_size, <a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> uncompressed_size) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:aad24f1d4784b7c665b27ae91b52d3bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new Block to lzma_index.  <a href="#aad24f1d4784b7c665b27ae91b52d3bd1"></a><br/></td></tr>
<tr class="memitem:a79a19669237f19f0b11c9f3be80a62b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2lzma_2index_8h.html#a79a19669237f19f0b11c9f3be80a62b4">lzma_index_stream_flags</a> (<a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i, const <a class="el" href="structlzma__stream__flags.html">lzma_stream_flags</a> *stream_flags) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:a79a19669237f19f0b11c9f3be80a62b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Stream Flags.  <a href="#a79a19669237f19f0b11c9f3be80a62b4"></a><br/></td></tr>
<tr class="memitem:af8d6528a04241841bd0a4322b0c57eaa"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2lzma_2index_8h.html#af8d6528a04241841bd0a4322b0c57eaa">lzma_index_checks</a> (const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i) lzma_nothrow lzma_attr_pure</td></tr>
<tr class="memdesc:af8d6528a04241841bd0a4322b0c57eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the types of integrity Checks.  <a href="#af8d6528a04241841bd0a4322b0c57eaa"></a><br/></td></tr>
<tr class="memitem:a3ed82f96c688f3c953f6509b6f4e2ef3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2lzma_2index_8h.html#a3ed82f96c688f3c953f6509b6f4e2ef3">lzma_index_stream_padding</a> (<a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i, <a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> stream_padding) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:a3ed82f96c688f3c953f6509b6f4e2ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the amount of Stream Padding.  <a href="#a3ed82f96c688f3c953f6509b6f4e2ef3"></a><br/></td></tr>
<tr class="memitem:afd159a765b09b0cf79186069a848d07e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2lzma_2index_8h.html#afd159a765b09b0cf79186069a848d07e">lzma_index_stream_count</a> (const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i) lzma_nothrow lzma_attr_pure</td></tr>
<tr class="memdesc:afd159a765b09b0cf79186069a848d07e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of Streams.  <a href="#afd159a765b09b0cf79186069a848d07e"></a><br/></td></tr>
<tr class="memitem:add1a8c506f67dbc19cae6747107e3bec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2lzma_2index_8h.html#add1a8c506f67dbc19cae6747107e3bec">lzma_index_block_count</a> (const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i) lzma_nothrow lzma_attr_pure</td></tr>
<tr class="memdesc:add1a8c506f67dbc19cae6747107e3bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of Blocks.  <a href="#add1a8c506f67dbc19cae6747107e3bec"></a><br/></td></tr>
<tr class="memitem:a669ed1a82b1941217cfbb07e7826afc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2lzma_2index_8h.html#a669ed1a82b1941217cfbb07e7826afc2">lzma_index_size</a> (const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i) lzma_nothrow lzma_attr_pure</td></tr>
<tr class="memdesc:a669ed1a82b1941217cfbb07e7826afc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the Index field as bytes.  <a href="#a669ed1a82b1941217cfbb07e7826afc2"></a><br/></td></tr>
<tr class="memitem:af3630369b43c9ccc906065d759b49663"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2lzma_2index_8h.html#af3630369b43c9ccc906065d759b49663">lzma_index_stream_size</a> (const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i) lzma_nothrow lzma_attr_pure</td></tr>
<tr class="memdesc:af3630369b43c9ccc906065d759b49663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total size of the Stream.  <a href="#af3630369b43c9ccc906065d759b49663"></a><br/></td></tr>
<tr class="memitem:a7829942b83ee1fa5b6443cc248b81041"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2lzma_2index_8h.html#a7829942b83ee1fa5b6443cc248b81041">lzma_index_total_size</a> (const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i) lzma_nothrow lzma_attr_pure</td></tr>
<tr class="memdesc:a7829942b83ee1fa5b6443cc248b81041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total size of the Blocks.  <a href="#a7829942b83ee1fa5b6443cc248b81041"></a><br/></td></tr>
<tr class="memitem:ac875ed47d35385e5dac461b25c5ea1c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2lzma_2index_8h.html#ac875ed47d35385e5dac461b25c5ea1c9">lzma_index_file_size</a> (const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i) lzma_nothrow lzma_attr_pure</td></tr>
<tr class="memdesc:ac875ed47d35385e5dac461b25c5ea1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total size of the file.  <a href="#ac875ed47d35385e5dac461b25c5ea1c9"></a><br/></td></tr>
<tr class="memitem:a620fe6317f1f9d7af9cc27c748bf07d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2lzma_2index_8h.html#a620fe6317f1f9d7af9cc27c748bf07d6">lzma_index_uncompressed_size</a> (const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i) lzma_nothrow lzma_attr_pure</td></tr>
<tr class="memdesc:a620fe6317f1f9d7af9cc27c748bf07d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the uncompressed size of the file.  <a href="#a620fe6317f1f9d7af9cc27c748bf07d6"></a><br/></td></tr>
<tr class="memitem:aa78f02f18ed29d289a6ef37b8ea98a21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2lzma_2index_8h.html#aa78f02f18ed29d289a6ef37b8ea98a21">lzma_index_iter_init</a> (<a class="el" href="structlzma__index__iter.html">lzma_index_iter</a> *iter, const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i) lzma_nothrow</td></tr>
<tr class="memdesc:aa78f02f18ed29d289a6ef37b8ea98a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an iterator.  <a href="#aa78f02f18ed29d289a6ef37b8ea98a21"></a><br/></td></tr>
<tr class="memitem:ae81438be8deff4894b104e65d8acdd24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2lzma_2index_8h.html#ae81438be8deff4894b104e65d8acdd24">lzma_index_iter_rewind</a> (<a class="el" href="structlzma__index__iter.html">lzma_index_iter</a> *iter) lzma_nothrow</td></tr>
<tr class="memdesc:ae81438be8deff4894b104e65d8acdd24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewind the iterator.  <a href="#ae81438be8deff4894b104e65d8acdd24"></a><br/></td></tr>
<tr class="memitem:af428522e1b3eef137c65c5a01f766e0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#abbc819c74b484c846825ae1388a50a59">lzma_bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2lzma_2index_8h.html#af428522e1b3eef137c65c5a01f766e0e">lzma_index_iter_next</a> (<a class="el" href="structlzma__index__iter.html">lzma_index_iter</a> *iter, <a class="el" href="api_2lzma_2index_8h.html#a712b43192d944bf2f767711343cd9ca8">lzma_index_iter_mode</a> mode) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:af428522e1b3eef137c65c5a01f766e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next Block or Stream.  <a href="#af428522e1b3eef137c65c5a01f766e0e"></a><br/></td></tr>
<tr class="memitem:ac4f56df9d210712e5d7add5502c9eb93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#abbc819c74b484c846825ae1388a50a59">lzma_bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2lzma_2index_8h.html#ac4f56df9d210712e5d7add5502c9eb93">lzma_index_iter_locate</a> (<a class="el" href="structlzma__index__iter.html">lzma_index_iter</a> *iter, <a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> target) lzma_nothrow</td></tr>
<tr class="memdesc:ac4f56df9d210712e5d7add5502c9eb93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locate a Block.  <a href="#ac4f56df9d210712e5d7add5502c9eb93"></a><br/></td></tr>
<tr class="memitem:a13f17bbd42eb4702985d035336ea11d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2lzma_2index_8h.html#a13f17bbd42eb4702985d035336ea11d6">lzma_index_cat</a> (<a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *dest, <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *src, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:a13f17bbd42eb4702985d035336ea11d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate lzma_indexes.  <a href="#a13f17bbd42eb4702985d035336ea11d6"></a><br/></td></tr>
<tr class="memitem:a4d01e9345278c12e426bc6f0ef52a2ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2lzma_2index_8h.html#a4d01e9345278c12e426bc6f0ef52a2ac">lzma_index_dup</a> (const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:a4d01e9345278c12e426bc6f0ef52a2ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate lzma_index.  <a href="#a4d01e9345278c12e426bc6f0ef52a2ac"></a><br/></td></tr>
<tr class="memitem:a6800d70f3b2afca085496460cd03211d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2lzma_2index_8h.html#a6800d70f3b2afca085496460cd03211d">lzma_index_encoder</a> (<a class="el" href="structlzma__stream.html">lzma_stream</a> *<a class="el" href="coder_8c.html#a048a6ae6a7da50de565b15d52ea9fafe">strm</a>, const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:a6800d70f3b2afca085496460cd03211d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize .xz Index encoder.  <a href="#a6800d70f3b2afca085496460cd03211d"></a><br/></td></tr>
<tr class="memitem:abb56fd1d5914f8900ece7b88b78e5e23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2lzma_2index_8h.html#abb56fd1d5914f8900ece7b88b78e5e23">lzma_index_decoder</a> (<a class="el" href="structlzma__stream.html">lzma_stream</a> *<a class="el" href="coder_8c.html#a048a6ae6a7da50de565b15d52ea9fafe">strm</a>, <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> **i, uint64_t memlimit) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:abb56fd1d5914f8900ece7b88b78e5e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize .xz Index decoder.  <a href="#abb56fd1d5914f8900ece7b88b78e5e23"></a><br/></td></tr>
<tr class="memitem:add1ef06dec8a26d08ae8651cff0fd8d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2lzma_2index_8h.html#add1ef06dec8a26d08ae8651cff0fd8d6">lzma_index_buffer_encode</a> (const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i, uint8_t *out, size_t *out_pos, size_t out_size) lzma_nothrow</td></tr>
<tr class="memdesc:add1ef06dec8a26d08ae8651cff0fd8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-call .xz Index encoder.  <a href="#add1ef06dec8a26d08ae8651cff0fd8d6"></a><br/></td></tr>
<tr class="memitem:ad03db3de1cd02b43dac80692b5a731ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_2lzma_2index_8h.html#ad03db3de1cd02b43dac80692b5a731ea">lzma_index_buffer_decode</a> (<a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> **i, uint64_t *memlimit, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator, const uint8_t *in, size_t *in_pos, size_t in_size) lzma_nothrow</td></tr>
<tr class="memdesc:ad03db3de1cd02b43dac80692b5a731ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-call .xz Index decoder.  <a href="#ad03db3de1cd02b43dac80692b5a731ea"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Handling of .xz Index and related information. </p>
</div><h2>Typedef Documentation</h2>
<a class="anchor" id="afc18c1443b3b9aa0d146b44e8755b62e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlzma__index__s.html">lzma_index_s</a> <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opaque data type to hold the Index(es) and other information. </p>
<p>lzma_index often holds just one .xz Index and possibly the Stream Flags of the same Stream and size of the Stream Padding field. However, multiple lzma_indexes can be concatenated with <a class="el" href="api_2lzma_2index_8h.html#a13f17bbd42eb4702985d035336ea11d6" title="Concatenate lzma_indexes.">lzma_index_cat()</a> and then there may be information about multiple Streams in the same lzma_index.</p>
<p>Notes about thread safety: Only one thread may modify lzma_index at a time. All functions that take non-const pointer to lzma_index modify it. As long as no thread is modifying the lzma_index, getting information from the same lzma_index can be done from multiple threads at the same time with functions that take a const pointer to lzma_index or use <a class="el" href="structlzma__index__iter.html" title="Iterator to get information about Blocks and Streams.">lzma_index_iter</a>. The same iterator must be used only by one thread at a time, of course, but there can be as many iterators for the same lzma_index as needed. </p>

</div>
</div>
<h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a712b43192d944bf2f767711343cd9ca8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="api_2lzma_2index_8h.html#a712b43192d944bf2f767711343cd9ca8">lzma_index_iter_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operation mode for <a class="el" href="api_2lzma_2index_8h.html#af428522e1b3eef137c65c5a01f766e0e" title="Get the next Block or Stream.">lzma_index_iter_next()</a> </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a712b43192d944bf2f767711343cd9ca8af46f6e5c414471c7c96586f380e48315"></a>LZMA_INDEX_ITER_ANY</em>&nbsp;</td><td>
<p>Get the next Block or Stream. </p>
<p>Go to the next Block if the current Stream has at least one Block left. Otherwise go to the next Stream even if it has no Blocks. If the Stream has no Blocks (lzma_index_iter.stream.block_count == 0), lzma_index_iter.block will have undefined values. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a712b43192d944bf2f767711343cd9ca8a5b31d985de1c823151acdd7e4a966fc9"></a>LZMA_INDEX_ITER_STREAM</em>&nbsp;</td><td>
<p>Get the next Stream. </p>
<p>Go to the next Stream even if the current Stream has unread Blocks left. If the next Stream has at least one Block, the iterator will point to the first Block. If there are no Blocks, lzma_index_iter.block will have undefined values. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a712b43192d944bf2f767711343cd9ca8a2702617d60d6fc15138a749e06ef3414"></a>LZMA_INDEX_ITER_BLOCK</em>&nbsp;</td><td>
<p>Get the next Block. </p>
<p>Go to the next Block if the current Stream has at least one Block left. If the current Stream has no Blocks left, the next Stream with at least one Block is located and the iterator will be made to point to the first Block of that Stream. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a712b43192d944bf2f767711343cd9ca8aa49bf4d561d8f2c61d300edbb6c282c7"></a>LZMA_INDEX_ITER_NONEMPTY_BLOCK</em>&nbsp;</td><td>
<p>Get the next non-empty Block. </p>
<p>This is like LZMA_INDEX_ITER_BLOCK except that it will skip Blocks whose Uncompressed Size is zero. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="a880def3727ecdd7f242807083d228fc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lzma_index_memusage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td>
          <td class="paramname"><em>streams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td>
          <td class="paramname"><em>blocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate memory usage of lzma_index. </p>
<p>On disk, the size of the Index field depends on both the number of Records stored and how big values the Records store (due to variable-length integer encoding). When the Index is kept in lzma_index structure, the memory usage depends only on the number of Records/Blocks stored in the Index(es), and in case of concatenated lzma_indexes, the number of Streams. The size in RAM is almost always significantly bigger than in the encoded form on disk.</p>
<p>This function calculates an approximate amount of memory needed hold the given number of Streams and Blocks in lzma_index structure. This value may vary between CPU architectures and also between liblzma versions if the internal implementation is modified. </p>

<p>References <a class="el" href="index_8c.html#a5083e2e588a600088db6cea759e07437">INDEX_GROUP_SIZE</a>, and <a class="el" href="vli_8h.html#a7b782528bd1934db7c020adbedb20ec9">LZMA_VLI_MAX</a>.</p>

<p>Referenced by <a class="el" href="index__decoder_8c.html#a81533a8f0a676b67380e6bd0a255f9df">lzma_index_buffer_decode()</a>, and <a class="el" href="index_8c.html#ae39293600748764d3b1ee02ebb65e947">lzma_index_memused()</a>.</p>

</div>
</div>
<a class="anchor" id="a4118805ac7be6618aca6d6d7e5e4dde7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lzma_index_memused </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the memory usage of an existing lzma_index. </p>
<p>This is a shorthand for lzma_index_memusage(lzma_index_stream_count(i), lzma_index_block_count(i)). </p>

<p>References <a class="el" href="api_2lzma_2index_8h.html#a880def3727ecdd7f242807083d228fc5">lzma_index_memusage()</a>.</p>

<p>Referenced by <a class="el" href="list_8c.html#ada243f83a8540051b161d0a114ef8f24">parse_indexes()</a>.</p>

</div>
</div>
<a class="anchor" id="ad17c5c45cd2692cc296261a91a4690f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a>* lzma_index_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize a new lzma_index structure. </p>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to an empty initialized lzma_index is returned. If allocation fails, NULL is returned. </dd></dl>

<p>References <a class="el" href="index_8c.html#a2735b9fc95daaac1420cd6ebae2a2fa8">index_stream_init()</a>, <a class="el" href="index_8c.html#a8a3b2b95c1953a8cf7f9fa88316081fc">index_tree_append()</a>, <a class="el" href="structindex__stream.html#a641dcc01e11966039a512b83dccdcd3c">index_stream::node</a>, and <a class="el" href="structlzma__index__s.html#a4dbed779040f4a7bad495a629d27e919">lzma_index_s::streams</a>.</p>

<p>Referenced by <a class="el" href="stream__buffer__encoder_8c.html#a932a602de4f44d8525687698e51ce93d">lzma_stream_buffer_encode()</a>.</p>

</div>
</div>
<a class="anchor" id="a469f89689529ea250969bb64f80ab874"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lzma_index_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate lzma_index. </p>
<p>If i is NULL, this does nothing. </p>

<p>References <a class="el" href="index_8c.html#a0cc239b8b51d743b420293025c167eed">index_stream_end()</a>, and <a class="el" href="index_8c.html#ad0843d99b4a243fbcd4b4a52f1758d8c">index_tree_end()</a>.</p>

<p>Referenced by <a class="el" href="list_8h.html#a2b9bdcc3cdcc48e99a29e178df9d4899">list_file()</a>, <a class="el" href="index__decoder_8c.html#a81533a8f0a676b67380e6bd0a255f9df">lzma_index_buffer_decode()</a>, <a class="el" href="index_8c.html#a8ac8a428e781dc92e6839cb15f7a458d">lzma_index_dup()</a>, <a class="el" href="stream__buffer__encoder_8c.html#a932a602de4f44d8525687698e51ce93d">lzma_stream_buffer_encode()</a>, and <a class="el" href="list_8c.html#ada243f83a8540051b161d0a114ef8f24">parse_indexes()</a>.</p>

</div>
</div>
<a class="anchor" id="aad24f1d4784b7c665b27ae91b52d3bd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_index_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td>
          <td class="paramname"><em>unpadded_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td>
          <td class="paramname"><em>uncompressed_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new Block to lzma_index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to a lzma_index structure </td></tr>
    <tr><td class="paramname">allocator</td><td>Pointer to <a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a>, or NULL to use malloc() </td></tr>
    <tr><td class="paramname">unpadded_size</td><td>Unpadded Size of a Block. This can be calculated with <a class="el" href="block_8h.html#a412d5605280fa29befae1b89e344bf30" title="Calculate Unpadded Size.">lzma_block_unpadded_size()</a> after encoding or decoding the Block. </td></tr>
    <tr><td class="paramname">uncompressed_size</td><td>Uncompressed Size of a Block. This can be taken directly from <a class="el" href="structlzma__block.html" title="Options for the Block and Block Header encoders and decoders.">lzma_block</a> structure after encoding or decoding the Block.</td></tr>
  </table>
  </dd>
</dl>
<p>Appending a new Block does not invalidate iterators. For example, if an iterator was pointing to the end of the lzma_index, after <a class="el" href="api_2lzma_2index_8h.html#aad24f1d4784b7c665b27ae91b52d3bd1" title="Add a new Block to lzma_index.">lzma_index_append()</a> it is possible to read the next Block with an existing iterator.</p>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK<ul>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_DATA_ERROR: Compressed or uncompressed size of the Stream or size of the Index field would grow too big.</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

<p>References <a class="el" href="structindex__group.html#ab741e763843d5492a307bfb71cb82ff6">index_group::allocated</a>, <a class="el" href="structindex__tree__node__s.html#a9d6408ee6c8682141d1ebff3ec17865d">index_tree_node_s::compressed_base</a>, <a class="el" href="structindex__stream.html#a9e6b322459a5b7b8806154ac9170d1c8">index_stream::groups</a>, <a class="el" href="index_8c.html#a5083e2e588a600088db6cea759e07437">INDEX_GROUP_SIZE</a>, <a class="el" href="structindex__stream.html#a631ced838a2c6389d920e57dc1edd016">index_stream::index_list_size</a>, <a class="el" href="index_8c.html#a8a3b2b95c1953a8cf7f9fa88316081fc">index_tree_append()</a>, <a class="el" href="structindex__group.html#a72f07e1a884c09ee2818671e5ca32222">index_group::last</a>, <a class="el" href="common_8h.html#ac58f96267a4f66bb15db736968b98008">lzma_alloc()</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea3aa72729a844790e39b4e1101a731dfb">LZMA_DATA_ERROR</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea567e1464feca03900a5425fb45b2f5b6">LZMA_MEM_ERROR</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea2dac8d451cb38da8550653d0d7be4ec2">LZMA_PROG_ERROR</a>, <a class="el" href="vli_8h.html#a7b782528bd1934db7c020adbedb20ec9">LZMA_VLI_MAX</a>, <a class="el" href="vli_8h.html#a8d53e0b69934b43da8721fa6f1e8cc4f">lzma_vli_size()</a>, <a class="el" href="vli_8h.html#a5a4b28254a30c859018b896ed371d69a">LZMA_VLI_UNKNOWN</a>, <a class="el" href="structindex__group.html#ad684ad25ae558b53a3c77d56489b7009">index_group::node</a>, <a class="el" href="structindex__stream.html#a641dcc01e11966039a512b83dccdcd3c">index_stream::node</a>, <a class="el" href="structindex__group.html#a8b7eba508bb2cf92b23e8aefb7ad0cd9">index_group::number_base</a>, <a class="el" href="structindex__stream.html#aef7ff4cbade21b89bf2b5c58dc46acf9">index_stream::record_count</a>, <a class="el" href="structindex__group.html#af0e6e330aff607120ff7ffd2467c2c70">index_group::records</a>, <a class="el" href="structindex__tree.html#a05f2ab2260c8b193e122f2be4b0298d4">index_tree::rightmost</a>, <a class="el" href="structindex__stream.html#aedd50053d69a45984cd5470eecc736a2">index_stream::stream_padding</a>, and <a class="el" href="structindex__tree__node__s.html#a16b23fdd5d86576ba3c8b0be7e693f0e">index_tree_node_s::uncompressed_base</a>.</p>

<p>Referenced by <a class="el" href="stream__buffer__encoder_8c.html#a932a602de4f44d8525687698e51ce93d">lzma_stream_buffer_encode()</a>.</p>

</div>
</div>
<a class="anchor" id="a79a19669237f19f0b11c9f3be80a62b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_index_stream_flags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlzma__stream__flags.html">lzma_stream_flags</a> *&#160;</td>
          <td class="paramname"><em>stream_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Stream Flags. </p>
<p>Set the Stream Flags of the last (and typically the only) Stream in lzma_index. This can be useful when reading information from the lzma_index, because to decode Blocks, knowing the integrity check type is needed.</p>
<p>The given Stream Flags are copied into internal preallocated structure in the lzma_index, thus the caller doesn't need to keep the *stream_flags available after calling this function.</p>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK<ul>
<li>LZMA_OPTIONS_ERROR: Unsupported stream_flags-&gt;version.</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

<p>References <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea2dac8d451cb38da8550653d0d7be4ec2">LZMA_PROG_ERROR</a>, <a class="el" href="stream__flags_8h.html#a3e25ca4205021302882a696283d45263">lzma_stream_flags_compare()</a>, <a class="el" href="common_8h.html#a3e1bf9f33b917e883b886b8a10458d66">return_if_error</a>, and <a class="el" href="structindex__stream.html#ac6af5abc8801131038c79fbde165e064">index_stream::stream_flags</a>.</p>

<p>Referenced by <a class="el" href="list_8c.html#ada243f83a8540051b161d0a114ef8f24">parse_indexes()</a>.</p>

</div>
</div>
<a class="anchor" id="af8d6528a04241841bd0a4322b0c57eaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lzma_index_checks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the types of integrity Checks. </p>
<p>If <a class="el" href="api_2lzma_2index_8h.html#a79a19669237f19f0b11c9f3be80a62b4" title="Set the Stream Flags.">lzma_index_stream_flags()</a> is used to set the Stream Flags for every Stream, <a class="el" href="api_2lzma_2index_8h.html#af8d6528a04241841bd0a4322b0c57eaa" title="Get the types of integrity Checks.">lzma_index_checks()</a> can be used to get a bitmask to indicate which Check types have been used. It can be useful e.g. if showing the Check types to the user.</p>
<p>The bitmask is 1 &lt;&lt; check_id, e.g. CRC32 is 1 &lt;&lt; 1 and SHA-256 is 1 &lt;&lt; 10. </p>

<p>References <a class="el" href="structlzma__stream__flags.html#ab1052ea7047c8d67f127f33278166647">lzma_stream_flags::check</a>, <a class="el" href="structindex__stream.html#ac6af5abc8801131038c79fbde165e064">index_stream::stream_flags</a>, and <a class="el" href="structlzma__stream__flags.html#a61e9151869d5b77c868aaa4958e74d10">lzma_stream_flags::version</a>.</p>

</div>
</div>
<a class="anchor" id="a3ed82f96c688f3c953f6509b6f4e2ef3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_index_stream_padding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td>
          <td class="paramname"><em>stream_padding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the amount of Stream Padding. </p>
<p>Set the amount of Stream Padding of the last (and typically the only) Stream in the lzma_index. This is needed when planning to do random-access reading within multiple concatenated Streams.</p>
<p>By default, the amount of Stream Padding is assumed to be zero bytes.</p>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK<ul>
<li>LZMA_DATA_ERROR: The file size would grow too big.</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

<p>References <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea3aa72729a844790e39b4e1101a731dfb">LZMA_DATA_ERROR</a>, <a class="el" href="api_2lzma_2index_8h.html#ac875ed47d35385e5dac461b25c5ea1c9">lzma_index_file_size()</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea2dac8d451cb38da8550653d0d7be4ec2">LZMA_PROG_ERROR</a>, <a class="el" href="vli_8h.html#a7b782528bd1934db7c020adbedb20ec9">LZMA_VLI_MAX</a>, and <a class="el" href="structindex__stream.html#aedd50053d69a45984cd5470eecc736a2">index_stream::stream_padding</a>.</p>

<p>Referenced by <a class="el" href="list_8c.html#ada243f83a8540051b161d0a114ef8f24">parse_indexes()</a>.</p>

</div>
</div>
<a class="anchor" id="afd159a765b09b0cf79186069a848d07e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> lzma_index_stream_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of Streams. </p>

</div>
</div>
<a class="anchor" id="add1a8c506f67dbc19cae6747107e3bec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> lzma_index_block_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of Blocks. </p>
<p>This returns the total number of Blocks in lzma_index. To get number of Blocks in individual Streams, use <a class="el" href="structlzma__index__iter.html" title="Iterator to get information about Blocks and Streams.">lzma_index_iter</a>. </p>

</div>
</div>
<a class="anchor" id="a669ed1a82b1941217cfbb07e7826afc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> lzma_index_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of the Index field as bytes. </p>
<p>This is needed to verify the Backward Size field in the Stream Footer. </p>

<p>Referenced by <a class="el" href="index__encoder_8c.html#a9a6a4b09464a3edc101ff4f4b1f49917">lzma_index_buffer_encode()</a>, and <a class="el" href="stream__buffer__encoder_8c.html#a932a602de4f44d8525687698e51ce93d">lzma_stream_buffer_encode()</a>.</p>

</div>
</div>
<a class="anchor" id="af3630369b43c9ccc906065d759b49663"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> lzma_index_stream_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total size of the Stream. </p>
<p>If multiple lzma_indexes have been combined, this works as if the Blocks were in a single Stream. This is useful if you are going to combine Blocks from multiple Streams into a single new Stream. </p>

<p>References <a class="el" href="stream__flags_8h.html#ada7e0a4f5e7146f547962cb9e9ef08ee">LZMA_STREAM_HEADER_SIZE</a>.</p>

</div>
</div>
<a class="anchor" id="a7829942b83ee1fa5b6443cc248b81041"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> lzma_index_total_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total size of the Blocks. </p>
<p>This doesn't include the Stream Header, Stream Footer, Stream Padding, or Index fields. </p>

<p>Referenced by <a class="el" href="list_8c.html#ada243f83a8540051b161d0a114ef8f24">parse_indexes()</a>.</p>

</div>
</div>
<a class="anchor" id="ac875ed47d35385e5dac461b25c5ea1c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> lzma_index_file_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total size of the file. </p>
<p>When no lzma_indexes have been combined with <a class="el" href="api_2lzma_2index_8h.html#a13f17bbd42eb4702985d035336ea11d6" title="Concatenate lzma_indexes.">lzma_index_cat()</a> and there is no Stream Padding, this function is identical to <a class="el" href="api_2lzma_2index_8h.html#af3630369b43c9ccc906065d759b49663" title="Get the total size of the Stream.">lzma_index_stream_size()</a>. If multiple lzma_indexes have been combined, this includes also the headers of each separate Stream and the possible Stream Padding fields. </p>

<p>References <a class="el" href="structindex__tree__node__s.html#a9d6408ee6c8682141d1ebff3ec17865d">index_tree_node_s::compressed_base</a>, <a class="el" href="structindex__stream.html#a9e6b322459a5b7b8806154ac9170d1c8">index_stream::groups</a>, <a class="el" href="structindex__stream.html#a631ced838a2c6389d920e57dc1edd016">index_stream::index_list_size</a>, <a class="el" href="structindex__group.html#a72f07e1a884c09ee2818671e5ca32222">index_group::last</a>, <a class="el" href="structindex__stream.html#a641dcc01e11966039a512b83dccdcd3c">index_stream::node</a>, <a class="el" href="structindex__stream.html#aef7ff4cbade21b89bf2b5c58dc46acf9">index_stream::record_count</a>, <a class="el" href="structindex__group.html#af0e6e330aff607120ff7ffd2467c2c70">index_group::records</a>, <a class="el" href="structindex__tree.html#a05f2ab2260c8b193e122f2be4b0298d4">index_tree::rightmost</a>, and <a class="el" href="structindex__stream.html#aedd50053d69a45984cd5470eecc736a2">index_stream::stream_padding</a>.</p>

<p>Referenced by <a class="el" href="index_8c.html#ad1de7c81bb1f94177dd0d1240e1ed652">lzma_index_stream_padding()</a>.</p>

</div>
</div>
<a class="anchor" id="a620fe6317f1f9d7af9cc27c748bf07d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> lzma_index_uncompressed_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the uncompressed size of the file. </p>

</div>
</div>
<a class="anchor" id="aa78f02f18ed29d289a6ef37b8ea98a21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lzma_index_iter_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__index__iter.html">lzma_index_iter</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>Pointer to a <a class="el" href="structlzma__index__iter.html" title="Iterator to get information about Blocks and Streams.">lzma_index_iter</a> structure </td></tr>
    <tr><td class="paramname">i</td><td>lzma_index to which the iterator will be associated</td></tr>
  </table>
  </dd>
</dl>
<p>This function associates the iterator with the given lzma_index, and calls <a class="el" href="api_2lzma_2index_8h.html#ae81438be8deff4894b104e65d8acdd24" title="Rewind the iterator.">lzma_index_iter_rewind()</a> on the iterator.</p>
<p>This function doesn't allocate any memory, thus there is no lzma_index_iter_end(). The iterator is valid as long as the associated lzma_index is valid, that is, until <a class="el" href="api_2lzma_2index_8h.html#a469f89689529ea250969bb64f80ab874" title="Deallocate lzma_index.">lzma_index_end()</a> or using it as source in <a class="el" href="api_2lzma_2index_8h.html#a13f17bbd42eb4702985d035336ea11d6" title="Concatenate lzma_indexes.">lzma_index_cat()</a>. Specifically, lzma_index doesn't become invalid if new Blocks are added to it with <a class="el" href="api_2lzma_2index_8h.html#aad24f1d4784b7c665b27ae91b52d3bd1" title="Add a new Block to lzma_index.">lzma_index_append()</a> or if it is used as the destination in <a class="el" href="api_2lzma_2index_8h.html#a13f17bbd42eb4702985d035336ea11d6" title="Concatenate lzma_indexes.">lzma_index_cat()</a>.</p>
<p>It is safe to make copies of an initialized <a class="el" href="structlzma__index__iter.html" title="Iterator to get information about Blocks and Streams.">lzma_index_iter</a>, for example, to easily restart reading at some particular position. </p>

<p>References <a class="el" href="api_2lzma_2index_8h.html#ae81438be8deff4894b104e65d8acdd24">lzma_index_iter_rewind()</a>.</p>

</div>
</div>
<a class="anchor" id="ae81438be8deff4894b104e65d8acdd24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lzma_index_iter_rewind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__index__iter.html">lzma_index_iter</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewind the iterator. </p>
<p>Rewind the iterator so that next call to <a class="el" href="api_2lzma_2index_8h.html#af428522e1b3eef137c65c5a01f766e0e" title="Get the next Block or Stream.">lzma_index_iter_next()</a> will return the first Block or Stream. </p>

<p>Referenced by <a class="el" href="index_8c.html#a206339df8447737452aa6870d101065b">lzma_index_iter_init()</a>.</p>

</div>
</div>
<a class="anchor" id="af428522e1b3eef137c65c5a01f766e0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#abbc819c74b484c846825ae1388a50a59">lzma_bool</a> lzma_index_iter_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__index__iter.html">lzma_index_iter</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2lzma_2index_8h.html#a712b43192d944bf2f767711343cd9ca8">lzma_index_iter_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next Block or Stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>Iterator initialized with <a class="el" href="api_2lzma_2index_8h.html#aa78f02f18ed29d289a6ef37b8ea98a21" title="Initialize an iterator.">lzma_index_iter_init()</a> </td></tr>
    <tr><td class="paramname">mode</td><td>Specify what kind of information the caller wants to get. See lzma_index_iter_mode for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If next Block or Stream matching the mode was found, *iter is updated and this function returns false. If no Block or Stream matching the mode is found, *iter is not modified and this function returns true. If mode is set to an unknown value, *iter is not modified and this function returns true. </dd></dl>

<p>References <a class="el" href="structindex__stream.html#a9e6b322459a5b7b8806154ac9170d1c8">index_stream::groups</a>, <a class="el" href="index_8c.html#a9043c7fea3feef371dd37abbc7db14ab">index_tree_next()</a>, <a class="el" href="structindex__tree.html#a89caf3c87135b5b5643e97e7d3725e21">index_tree::leftmost</a>, <a class="el" href="api_2lzma_2index_8h.html#a712b43192d944bf2f767711343cd9ca8a2702617d60d6fc15138a749e06ef3414">LZMA_INDEX_ITER_BLOCK</a>, <a class="el" href="api_2lzma_2index_8h.html#a712b43192d944bf2f767711343cd9ca8aa49bf4d561d8f2c61d300edbb6c282c7">LZMA_INDEX_ITER_NONEMPTY_BLOCK</a>, <a class="el" href="api_2lzma_2index_8h.html#a712b43192d944bf2f767711343cd9ca8a5b31d985de1c823151acdd7e4a966fc9">LZMA_INDEX_ITER_STREAM</a>, <a class="el" href="structindex__group.html#ad684ad25ae558b53a3c77d56489b7009">index_group::node</a>, <a class="el" href="structindex__stream.html#a641dcc01e11966039a512b83dccdcd3c">index_stream::node</a>, <a class="el" href="structindex__group.html#af0e6e330aff607120ff7ffd2467c2c70">index_group::records</a>, <a class="el" href="structlzma__index__s.html#a4dbed779040f4a7bad495a629d27e919">lzma_index_s::streams</a>, and <a class="el" href="structindex__tree__node__s.html#a16b23fdd5d86576ba3c8b0be7e693f0e">index_tree_node_s::uncompressed_base</a>.</p>

</div>
</div>
<a class="anchor" id="ac4f56df9d210712e5d7add5502c9eb93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#abbc819c74b484c846825ae1388a50a59">lzma_bool</a> lzma_index_iter_locate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__index__iter.html">lzma_index_iter</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locate a Block. </p>
<p>If it is possible to seek in the .xz file, it is possible to parse the Index field(s) and use <a class="el" href="api_2lzma_2index_8h.html#ac4f56df9d210712e5d7add5502c9eb93" title="Locate a Block.">lzma_index_iter_locate()</a> to do random-access reading with granularity of Block size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>Iterator that was earlier initialized with <a class="el" href="api_2lzma_2index_8h.html#aa78f02f18ed29d289a6ef37b8ea98a21" title="Initialize an iterator.">lzma_index_iter_init()</a>. </td></tr>
    <tr><td class="paramname">target</td><td>Uncompressed target offset which the caller would like to locate from the Stream</td></tr>
  </table>
  </dd>
</dl>
<p>If the target is smaller than the uncompressed size of the Stream (can be checked with <a class="el" href="api_2lzma_2index_8h.html#a620fe6317f1f9d7af9cc27c748bf07d6" title="Get the uncompressed size of the file.">lzma_index_uncompressed_size()</a>):</p>
<ul>
<li>Information about the Stream and Block containing the requested uncompressed offset is stored into *iter.</li>
<li>Internal state of the iterator is adjusted so that <a class="el" href="api_2lzma_2index_8h.html#af428522e1b3eef137c65c5a01f766e0e" title="Get the next Block or Stream.">lzma_index_iter_next()</a> can be used to read subsequent Blocks or Streams.</li>
<li>This function returns false.</li>
</ul>
<p>If target is greater than the uncompressed size of the Stream, *iter is not modified, and this function returns true. </p>

<p>References <a class="el" href="structindex__stream.html#a9e6b322459a5b7b8806154ac9170d1c8">index_stream::groups</a>, <a class="el" href="index_8c.html#ac6795607a0d3881e5fff569a82d01415">index_tree_locate()</a>, <a class="el" href="structindex__group.html#a72f07e1a884c09ee2818671e5ca32222">index_group::last</a>, <a class="el" href="structindex__stream.html#a641dcc01e11966039a512b83dccdcd3c">index_stream::node</a>, <a class="el" href="structindex__group.html#af0e6e330aff607120ff7ffd2467c2c70">index_group::records</a>, <a class="el" href="structlzma__index__s.html#a4dbed779040f4a7bad495a629d27e919">lzma_index_s::streams</a>, <a class="el" href="structindex__tree__node__s.html#a16b23fdd5d86576ba3c8b0be7e693f0e">index_tree_node_s::uncompressed_base</a>, and <a class="el" href="structlzma__index__s.html#ac26ac10364bd7861c8e2afecd024c4ba">lzma_index_s::uncompressed_size</a>.</p>

</div>
</div>
<a class="anchor" id="a13f17bbd42eb4702985d035336ea11d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_index_cat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate lzma_indexes. </p>
<p>Concatenating lzma_indexes is useful when doing random-access reading in multi-Stream .xz file, or when combining multiple Streams into single Stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>lzma_index after which src is appended </td></tr>
    <tr><td class="paramname">src</td><td>lzma_index to be appended after dest. If this function succeeds, the memory allocated for src is freed or moved to be part of dest, and all iterators pointing to src will become invalid. </td></tr>
    <tr><td class="paramname">allocator</td><td>Custom memory allocator; can be NULL to use malloc() and free().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK: lzma_indexes were concatenated successfully. src is now a dangling pointer.<ul>
<li>LZMA_DATA_ERROR: *dest would grow too big.</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

<p>Referenced by <a class="el" href="list_8c.html#ada243f83a8540051b161d0a114ef8f24">parse_indexes()</a>.</p>

</div>
</div>
<a class="anchor" id="a4d01e9345278c12e426bc6f0ef52a2ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a>* lzma_index_dup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate lzma_index. </p>
<dl class="section return"><dt>Returns</dt><dd>A copy of the lzma_index, or NULL if memory allocation failed. </dd></dl>

<p>References <a class="el" href="index_8c.html#a2db488e0703ae8bb890202d505b1d82d">index_dup_stream()</a>, <a class="el" href="structlzma__index__s.html#a69f2a4f80181ffce53aeb73cc135a923">lzma_index_s::index_list_size</a>, <a class="el" href="index_8c.html#a8a3b2b95c1953a8cf7f9fa88316081fc">index_tree_append()</a>, <a class="el" href="index_8c.html#a9043c7fea3feef371dd37abbc7db14ab">index_tree_next()</a>, <a class="el" href="api_2lzma_2index_8h.html#a469f89689529ea250969bb64f80ab874">lzma_index_end()</a>, <a class="el" href="structindex__stream.html#a641dcc01e11966039a512b83dccdcd3c">index_stream::node</a>, <a class="el" href="structlzma__index__s.html#a94bbe86623f812d8742da7e545ed5d88">lzma_index_s::record_count</a>, <a class="el" href="structlzma__index__s.html#a4dbed779040f4a7bad495a629d27e919">lzma_index_s::streams</a>, <a class="el" href="structlzma__index__s.html#a1e3767d5bad6704d797c5b447467ec75">lzma_index_s::total_size</a>, and <a class="el" href="structlzma__index__s.html#ac26ac10364bd7861c8e2afecd024c4ba">lzma_index_s::uncompressed_size</a>.</p>

</div>
</div>
<a class="anchor" id="a6800d70f3b2afca085496460cd03211d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_index_encoder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__stream.html">lzma_stream</a> *&#160;</td>
          <td class="paramname"><em>strm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize .xz Index encoder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to properly prepared <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> </td></tr>
    <tr><td class="paramname">i</td><td>Pointer to lzma_index which should be encoded.</td></tr>
  </table>
  </dd>
</dl>
<p>The valid `action' values for <a class="el" href="base_8h.html#a28cc09bc422d5ba1e0187c9f2af5d957" title="Encode or decode data.">lzma_code()</a> are LZMA_RUN and LZMA_FINISH. It is enough to use only one of them (you can choose freely; use LZMA_RUN to support liblzma versions older than 5.0.0).</p>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK: Initialization succeeded, continue with <a class="el" href="base_8h.html#a28cc09bc422d5ba1e0187c9f2af5d957" title="Encode or decode data.">lzma_code()</a>.<ul>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

<p>References <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea7d24fb3c6c144d13bcb091195b8ebec1">LZMA_FINISH</a>, <a class="el" href="common_8h.html#a844da62faaaf4c19a9a297129bc30a8c">lzma_next_strm_init</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, and <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea868472b76492afcaef54020a481890b1">LZMA_RUN</a>.</p>

</div>
</div>
<a class="anchor" id="abb56fd1d5914f8900ece7b88b78e5e23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_index_decoder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__stream.html">lzma_stream</a> *&#160;</td>
          <td class="paramname"><em>strm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> **&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>memlimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize .xz Index decoder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to properly prepared <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> </td></tr>
    <tr><td class="paramname">i</td><td>The decoded Index will be made available via this pointer. Initially this function will set *i to NULL (the old value is ignored). If decoding succeeds (<a class="el" href="base_8h.html#a28cc09bc422d5ba1e0187c9f2af5d957" title="Encode or decode data.">lzma_code()</a> returns LZMA_STREAM_END), *i will be set to point to a new lzma_index, which the application has to later free with <a class="el" href="api_2lzma_2index_8h.html#a469f89689529ea250969bb64f80ab874" title="Deallocate lzma_index.">lzma_index_end()</a>. </td></tr>
    <tr><td class="paramname">memlimit</td><td>How much memory the resulting lzma_index is allowed to require.</td></tr>
  </table>
  </dd>
</dl>
<p>The valid `action' values for <a class="el" href="base_8h.html#a28cc09bc422d5ba1e0187c9f2af5d957" title="Encode or decode data.">lzma_code()</a> are LZMA_RUN and LZMA_FINISH. It is enough to use only one of them (you can choose freely; use LZMA_RUN to support liblzma versions older than 5.0.0).</p>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK: Initialization succeeded, continue with <a class="el" href="base_8h.html#a28cc09bc422d5ba1e0187c9f2af5d957" title="Encode or decode data.">lzma_code()</a>.<ul>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_MEMLIMIT_ERROR</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

<p>References <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea7d24fb3c6c144d13bcb091195b8ebec1">LZMA_FINISH</a>, <a class="el" href="common_8h.html#a844da62faaaf4c19a9a297129bc30a8c">lzma_next_strm_init</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, and <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea868472b76492afcaef54020a481890b1">LZMA_RUN</a>.</p>

<p>Referenced by <a class="el" href="list_8c.html#ada243f83a8540051b161d0a114ef8f24">parse_indexes()</a>.</p>

</div>
</div>
<a class="anchor" id="add1ef06dec8a26d08ae8651cff0fd8d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_index_buffer_encode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>out_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>out_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-call .xz Index encoder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>lzma_index to be encoded </td></tr>
    <tr><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramname">out_pos</td><td>The next byte will be written to out[*out_pos]. *out_pos is updated only if encoding succeeds. </td></tr>
    <tr><td class="paramname">out_size</td><td>Size of the out buffer; the first byte into which no data is written to is out[out_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK: Encoding was successful.<ul>
<li>LZMA_BUF_ERROR: Output buffer is too small. Use <a class="el" href="api_2lzma_2index_8h.html#a669ed1a82b1941217cfbb07e7826afc2" title="Get the size of the Index field as bytes.">lzma_index_size()</a> to find out how much output space is needed.</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function doesn't take allocator argument since all the internal data is allocated on stack. </dd></dl>

<p>References <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea9ca0ecb62459bdc84d6af47d16b23ae5">LZMA_BUF_ERROR</a>, <a class="el" href="api_2lzma_2index_8h.html#a669ed1a82b1941217cfbb07e7826afc2">lzma_index_size()</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea2dac8d451cb38da8550653d0d7be4ec2">LZMA_PROG_ERROR</a>, <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea868472b76492afcaef54020a481890b1">LZMA_RUN</a>, and <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea91ecc6fab14c13ad36224afbcb4e55c4">LZMA_STREAM_END</a>.</p>

<p>Referenced by <a class="el" href="stream__buffer__encoder_8c.html#a932a602de4f44d8525687698e51ce93d">lzma_stream_buffer_encode()</a>.</p>

</div>
</div>
<a class="anchor" id="ad03db3de1cd02b43dac80692b5a731ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_index_buffer_decode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api_2lzma_2index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> **&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>memlimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>in_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>in_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-call .xz Index decoder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>If decoding succeeds, *i will point to a new lzma_index, which the application has to later free with <a class="el" href="api_2lzma_2index_8h.html#a469f89689529ea250969bb64f80ab874" title="Deallocate lzma_index.">lzma_index_end()</a>. If an error occurs, *i will be NULL. The old value of *i is always ignored and thus doesn't need to be initialized by the caller. </td></tr>
    <tr><td class="paramname">memlimit</td><td>Pointer to how much memory the resulting lzma_index is allowed to require. The value pointed by this pointer is modified if and only if LZMA_MEMLIMIT_ERROR is returned. </td></tr>
    <tr><td class="paramname">allocator</td><td>Pointer to <a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a>, or NULL to use malloc() </td></tr>
    <tr><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramname">in_pos</td><td>The next byte will be read from in[*in_pos]. *in_pos is updated only if decoding succeeds. </td></tr>
    <tr><td class="paramname">in_size</td><td>Size of the input buffer; the first byte that won't be read is in[in_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK: Decoding was successful.<ul>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_MEMLIMIT_ERROR: Memory usage limit was reached. The minimum required memlimit value was stored to *memlimit.</li>
<li>LZMA_DATA_ERROR</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

<p>References <a class="el" href="structlzma__coder__s.html#af8069bed41aaf41b3c381f12531df065">lzma_coder_s::count</a>, <a class="el" href="structlzma__coder__s.html#a70b88e1a79013879cc05a500da061bf5">lzma_coder_s::index</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea3aa72729a844790e39b4e1101a731dfb">LZMA_DATA_ERROR</a>, <a class="el" href="api_2lzma_2index_8h.html#a469f89689529ea250969bb64f80ab874">lzma_index_end()</a>, <a class="el" href="api_2lzma_2index_8h.html#a880def3727ecdd7f242807083d228fc5">lzma_index_memusage()</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea2dac8d451cb38da8550653d0d7be4ec2">LZMA_PROG_ERROR</a>, <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea868472b76492afcaef54020a481890b1">LZMA_RUN</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea91ecc6fab14c13ad36224afbcb4e55c4">LZMA_STREAM_END</a>, and <a class="el" href="common_8h.html#a3e1bf9f33b917e883b886b8a10458d66">return_if_error</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jun 5 2014 14:18:36 for XZ Utils by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
