<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>XZ Utils: liblzma/common/common.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">XZ Utils
   &#160;<span id="projectnumber">5.1.0alpha</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2e0898c272e1f0f93c8ef15f5da2a912.html">liblzma</a></li><li class="navelem"><a class="el" href="dir_db777975f8e21a5de5f283e04473bf67.html">common</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">common.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Common functions needed in many places in liblzma.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="sysdefs_8h.html">sysdefs.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="mythread_8h.html">mythread.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="tuklib__integer_8h.html">tuklib_integer.h</a>&quot;</code><br/>
<code>#include &quot;lzma.h&quot;</code><br/>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__filter__info__s.html">lzma_filter_info_s</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__next__coder__s.html">lzma_next_coder_s</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hold data and function pointers of the next filter in the chain.  <a href="structlzma__next__coder__s.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__internal__s.html">lzma_internal_s</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aea970a4daa1798994b600e03da8955d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea970a4daa1798994b600e03da8955d1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LZMA_API_EXPORT</b></td></tr>
<tr class="memitem:abfd99ac68c941953a426e005b4af82dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfd99ac68c941953a426e005b4af82dc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LZMA_API</b>(type)&#160;&#160;&#160;LZMA_API_EXPORT type LZMA_API_CALL</td></tr>
<tr class="memitem:aa0672ea7123854cc5f51902a06c473fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0672ea7123854cc5f51902a06c473fb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>likely</b>(expr)&#160;&#160;&#160;(expr)</td></tr>
<tr class="memitem:ad8700448546b3b5111404cc021061fd5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8700448546b3b5111404cc021061fd5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>unlikely</b>(expr)&#160;&#160;&#160;(expr)</td></tr>
<tr class="memitem:a1b621fc6aec40a92c6bcef56a7994ae7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="common_8h.html#a1b621fc6aec40a92c6bcef56a7994ae7">LZMA_BUFFER_SIZE</a>&#160;&#160;&#160;4096</td></tr>
<tr class="memdesc:a1b621fc6aec40a92c6bcef56a7994ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of temporary buffers needed in some filters.  <a href="#a1b621fc6aec40a92c6bcef56a7994ae7"></a><br/></td></tr>
<tr class="memitem:a3c4e3d305aea4ca9f30c5a05b3ad7570"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="common_8h.html#a3c4e3d305aea4ca9f30c5a05b3ad7570">LZMA_MEMUSAGE_BASE</a>&#160;&#160;&#160;(UINT64_C(1) &lt;&lt; 15)</td></tr>
<tr class="memitem:a50d12a2d492921171aab3404ca56a55c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="common_8h.html#a50d12a2d492921171aab3404ca56a55c">LZMA_FILTER_RESERVED_START</a>&#160;&#160;&#160;(<a class="el" href="vli_8h.html#a2d8bf5322898bfa11945848420585881">LZMA_VLI_C</a>(1) &lt;&lt; 62)</td></tr>
<tr class="memitem:a3469962f4605c82d5ccff2b1a8cd91a1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="common_8h.html#a3469962f4605c82d5ccff2b1a8cd91a1">LZMA_SUPPORTED_FLAGS</a></td></tr>
<tr class="memitem:a1fca27f3d292f89fffbf7162d34a5bc3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="common_8h.html#a1fca27f3d292f89fffbf7162d34a5bc3">LZMA_NEXT_CODER_INIT</a></td></tr>
<tr class="memdesc:a1fca27f3d292f89fffbf7162d34a5bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to initialize lzma_next_coder structure.  <a href="#a1fca27f3d292f89fffbf7162d34a5bc3"></a><br/></td></tr>
<tr class="memitem:a3e1bf9f33b917e883b886b8a10458d66"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="common_8h.html#a3e1bf9f33b917e883b886b8a10458d66">return_if_error</a>(expr)</td></tr>
<tr class="memdesc:a3e1bf9f33b917e883b886b8a10458d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if expression doesn't evaluate to LZMA_OK.  <a href="#a3e1bf9f33b917e883b886b8a10458d66"></a><br/></td></tr>
<tr class="memitem:a4e5a35bc05ca572acdae55a294c8cc89"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="common_8h.html#a4e5a35bc05ca572acdae55a294c8cc89">lzma_next_coder_init</a>(func, next, allocator)</td></tr>
<tr class="memitem:a844da62faaaf4c19a9a297129bc30a8c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="common_8h.html#a844da62faaaf4c19a9a297129bc30a8c">lzma_next_strm_init</a>(func, <a class="el" href="coder_8c.html#a048a6ae6a7da50de565b15d52ea9fafe">strm</a>,...)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4fd16c96358c705abab5da65940aa1b1"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structlzma__coder__s.html">lzma_coder_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="common_8h.html#a4fd16c96358c705abab5da65940aa1b1">lzma_coder</a></td></tr>
<tr class="memitem:a734a9065645913446bd51d3a276b2c94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a734a9065645913446bd51d3a276b2c94"></a>
typedef struct <a class="el" href="structlzma__next__coder__s.html">lzma_next_coder_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lzma_next_coder</b></td></tr>
<tr class="memitem:afce19774e821baaff5d300663dc9e8d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afce19774e821baaff5d300663dc9e8d0"></a>
typedef struct <a class="el" href="structlzma__filter__info__s.html">lzma_filter_info_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lzma_filter_info</b></td></tr>
<tr class="memitem:a2897729ce4e6af56b4412222bdc4280f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="common_8h.html#a2897729ce4e6af56b4412222bdc4280f">lzma_init_function</a> )(<a class="el" href="structlzma__next__coder__s.html">lzma_next_coder</a> *next, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator, const <a class="el" href="structlzma__filter__info__s.html">lzma_filter_info</a> *<a class="el" href="coder_8c.html#a9325236d5759d4eaadcba08a6bb5c96f">filters</a>)</td></tr>
<tr class="memdesc:a2897729ce4e6af56b4412222bdc4280f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a function used to initialize a filter encoder or decoder.  <a href="#a2897729ce4e6af56b4412222bdc4280f"></a><br/></td></tr>
<tr class="memitem:a31f6f422451d4b782091365d7f2ae29b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="common_8h.html#a31f6f422451d4b782091365d7f2ae29b">lzma_code_function</a> )(<a class="el" href="common_8h.html#a4fd16c96358c705abab5da65940aa1b1">lzma_coder</a> *coder, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator, const uint8_t *restrict in, size_t *restrict in_pos, size_t in_size, uint8_t *restrict out, size_t *restrict out_pos, size_t out_size, <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77e">lzma_action</a> action)</td></tr>
<tr class="memitem:a0aa97c452db5b3f4c5cb331337b5dbe6"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="common_8h.html#a0aa97c452db5b3f4c5cb331337b5dbe6">lzma_end_function</a> )(<a class="el" href="common_8h.html#a4fd16c96358c705abab5da65940aa1b1">lzma_coder</a> *coder, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator)</td></tr>
<tr class="memdesc:a0aa97c452db5b3f4c5cb331337b5dbe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a function to free the memory allocated for the coder.  <a href="#a0aa97c452db5b3f4c5cb331337b5dbe6"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac58f96267a4f66bb15db736968b98008"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="common_8h.html#ac58f96267a4f66bb15db736968b98008">lzma_alloc</a> (size_t size, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator) lzma_attribute((__malloc__)) lzma_attr_alloc_size(1)</td></tr>
<tr class="memdesc:ac58f96267a4f66bb15db736968b98008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory.  <a href="#ac58f96267a4f66bb15db736968b98008"></a><br/></td></tr>
<tr class="memitem:a11940cc6553c7274d0cc313bebd00e6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="common_8h.html#a11940cc6553c7274d0cc313bebd00e6a">lzma_free</a> (void *ptr, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator)</td></tr>
<tr class="memdesc:a11940cc6553c7274d0cc313bebd00e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory.  <a href="#a11940cc6553c7274d0cc313bebd00e6a"></a><br/></td></tr>
<tr class="memitem:a83455498798efe8409f8b9f11a77b2aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="common_8h.html#a83455498798efe8409f8b9f11a77b2aa">lzma_strm_init</a> (<a class="el" href="structlzma__stream.html">lzma_stream</a> *<a class="el" href="coder_8c.html#a048a6ae6a7da50de565b15d52ea9fafe">strm</a>)</td></tr>
<tr class="memitem:a083a413c43195aed33e19b1d2c043f88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="common_8h.html#a083a413c43195aed33e19b1d2c043f88">lzma_next_filter_init</a> (<a class="el" href="structlzma__next__coder__s.html">lzma_next_coder</a> *next, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator, const <a class="el" href="structlzma__filter__info__s.html">lzma_filter_info</a> *<a class="el" href="coder_8c.html#a9325236d5759d4eaadcba08a6bb5c96f">filters</a>)</td></tr>
<tr class="memitem:a751a67a126c4701bbac3eaa6042fe36b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="common_8h.html#a751a67a126c4701bbac3eaa6042fe36b">lzma_next_filter_update</a> (<a class="el" href="structlzma__next__coder__s.html">lzma_next_coder</a> *next, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator, const <a class="el" href="structlzma__filter.html">lzma_filter</a> *reversed_filters)</td></tr>
<tr class="memitem:a2ed13e809d1cd8253f04193820136e4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="common_8h.html#a2ed13e809d1cd8253f04193820136e4a">lzma_next_end</a> (<a class="el" href="structlzma__next__coder__s.html">lzma_next_coder</a> *next, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator)</td></tr>
<tr class="memitem:a9ffbf0181223d38d596508a3b47488b0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="common_8h.html#a9ffbf0181223d38d596508a3b47488b0">lzma_bufcpy</a> (const uint8_t *restrict in, size_t *restrict in_pos, size_t in_size, uint8_t *restrict out, size_t *restrict out_pos, size_t out_size)</td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Common functions needed in many places in liblzma. </p>
<p>Definitions common to the whole liblzma library.</p>
</div><h2>Macro Definition Documentation</h2>
<a class="anchor" id="a1b621fc6aec40a92c6bcef56a7994ae7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_BUFFER_SIZE&#160;&#160;&#160;4096</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of temporary buffers needed in some filters. </p>

</div>
</div>
<a class="anchor" id="a3c4e3d305aea4ca9f30c5a05b3ad7570"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_MEMUSAGE_BASE&#160;&#160;&#160;(UINT64_C(1) &lt;&lt; 15)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting value for memory usage estimates. Instead of calculating size of <em>every</em> structure and taking into account malloc() overhead etc., we add a base size to all memory usage estimates. It's not very accurate but should be easily good enough. </p>

<p>Referenced by <a class="el" href="base_8h.html#afc49d4cf75b73128a167df3407505f7b">lzma_memlimit_set()</a>.</p>

</div>
</div>
<a class="anchor" id="a50d12a2d492921171aab3404ca56a55c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_FILTER_RESERVED_START&#160;&#160;&#160;(<a class="el" href="vli_8h.html#a2d8bf5322898bfa11945848420585881">LZMA_VLI_C</a>(1) &lt;&lt; 62)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start of internal Filter ID space. These IDs must never be used in Streams. </p>

<p>Referenced by <a class="el" href="filter__flags__decoder_8c.html#a9a1158f867c66ffa35a9b38c830c083c">lzma_filter_flags_decode()</a>, <a class="el" href="filter__flags__encoder_8c.html#a7015967aa324750a66c788b1987aa6a5">lzma_filter_flags_encode()</a>, and <a class="el" href="filter__flags__encoder_8c.html#a23a84602614b62ba2c9241149fd89087">lzma_filter_flags_size()</a>.</p>

</div>
</div>
<a class="anchor" id="a3469962f4605c82d5ccff2b1a8cd91a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_SUPPORTED_FLAGS</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( <a class="code" href="container_8h.html#ada9cd20febb28b5ed6656de9184a86e9">LZMA_TELL_NO_CHECK</a> \</div>
<div class="line">        | <a class="code" href="container_8h.html#ae21fb746037c82735d40d428c462e078">LZMA_TELL_UNSUPPORTED_CHECK</a> \</div>
<div class="line">        | <a class="code" href="container_8h.html#a0bdde702a77ff42b90a99c0bf4147b6b">LZMA_TELL_ANY_CHECK</a> \</div>
<div class="line">        | <a class="code" href="container_8h.html#a563c84b5f368b3dd00d92ea903c5c33d">LZMA_CONCATENATED</a> )</div>
</div><!-- fragment --><p>Supported flags that can be passed to <a class="el" href="container_8h.html#a02b7683ef98d8049788961370a8b28c0" title="Initialize .xz Stream decoder.">lzma_stream_decoder()</a> or <a class="el" href="container_8h.html#a21cbebf2771617bb1e956385cfb353e3" title="Decode .xz Streams and .lzma files with autodetection.">lzma_auto_decoder()</a>. </p>

</div>
</div>
<a class="anchor" id="a1fca27f3d292f89fffbf7162d34a5bc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_NEXT_CODER_INIT</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code" href="structlzma__next__coder__s.html" title="Hold data and function pointers of the next filter in the chain.">lzma_next_coder</a>){ \</div>
<div class="line">                .coder = NULL, \</div>
<div class="line">                .init = (uintptr_t)(NULL), \</div>
<div class="line">                .id = <a class="code" href="vli_8h.html#a5a4b28254a30c859018b896ed371d69a" title="VLI value to denote that the value is unknown.">LZMA_VLI_UNKNOWN</a>, \</div>
<div class="line">                .code = NULL, \</div>
<div class="line">                .end = NULL, \</div>
<div class="line">                .get_check = NULL, \</div>
<div class="line">                .memconfig = NULL, \</div>
<div class="line">                .update = NULL, \</div>
<div class="line">        }</div>
</div><!-- fragment -->
<p>Macro to initialize lzma_next_coder structure. </p>

<p>Referenced by <a class="el" href="block__buffer__decoder_8c.html#a160b1204057a9359c70e707b5c2b05a6">lzma_block_buffer_decode()</a>, <a class="el" href="common_8h.html#a2ed13e809d1cd8253f04193820136e4a">lzma_next_end()</a>, <a class="el" href="filter__buffer__decoder_8c.html#a87a76e6e8ad7a3127260373811a18ddf">lzma_raw_buffer_decode()</a>, <a class="el" href="filter__buffer__encoder_8c.html#a31527db1862063420cf8b8e67404da27">lzma_raw_buffer_encode()</a>, <a class="el" href="stream__buffer__decoder_8c.html#a9182bc9549f9d1d93c5ac6e546149ca5">lzma_stream_buffer_decode()</a>, and <a class="el" href="common_8h.html#a83455498798efe8409f8b9f11a77b2aa">lzma_strm_init()</a>.</p>

</div>
</div>
<a class="anchor" id="a3e1bf9f33b917e883b886b8a10458d66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define return_if_error</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">expr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> { \</div>
<div class="line">        const <a class="code" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e" title="Return values used by several functions in liblzma.">lzma_ret</a> ret_ = (expr); \</div>
<div class="line">        if (ret_ != <a class="code" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe" title="Operation completed successfully.">LZMA_OK</a>) \</div>
<div class="line">                return ret_; \</div>
<div class="line">} <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
<p>Return if expression doesn't evaluate to LZMA_OK. </p>
<p>There are several situations where we want to return immediately with the value of expr if it isn't LZMA_OK. This macro shortens the code a little. </p>

<p>Referenced by <a class="el" href="block__buffer__encoder_8c.html#a635b4b6ab2edce064de64dbfeba9f5f5">lzma_block_buffer_encode()</a>, <a class="el" href="block__header__decoder_8c.html#ac85bbf9df6709081a8112c8826b4997b">lzma_block_header_decode()</a>, <a class="el" href="block__header__encoder_8c.html#a01a1e06f40b56d8ca61ac577e77a4fec">lzma_block_header_encode()</a>, <a class="el" href="block__header__encoder_8c.html#a7d60c35cba687af87e3c3a83639b2f6d">lzma_block_header_size()</a>, <a class="el" href="lzma__decoder_8c.html#ade97427138afb2587187e091e6230f24">lzma_decoder_init()</a>, <a class="el" href="filter__flags__decoder_8c.html#a9a1158f867c66ffa35a9b38c830c083c">lzma_filter_flags_decode()</a>, <a class="el" href="filter__flags__encoder_8c.html#a7015967aa324750a66c788b1987aa6a5">lzma_filter_flags_encode()</a>, <a class="el" href="filter__flags__encoder_8c.html#a23a84602614b62ba2c9241149fd89087">lzma_filter_flags_size()</a>, <a class="el" href="index__decoder_8c.html#a81533a8f0a676b67380e6bd0a255f9df">lzma_index_buffer_decode()</a>, <a class="el" href="index__hash_8c.html#a29b6194063af60c27dab0309b793598a">lzma_index_hash_append()</a>, <a class="el" href="index__hash_8c.html#aedf75aefbcc0b3263898afbb9cab3ef5">lzma_index_hash_decode()</a>, <a class="el" href="index_8c.html#ad427e6894af982f7443c677bfbe4b856">lzma_index_stream_flags()</a>, <a class="el" href="filter__buffer__decoder_8c.html#a87a76e6e8ad7a3127260373811a18ddf">lzma_raw_buffer_decode()</a>, <a class="el" href="filter__buffer__encoder_8c.html#a31527db1862063420cf8b8e67404da27">lzma_raw_buffer_encode()</a>, and <a class="el" href="stream__buffer__encoder_8c.html#a932a602de4f44d8525687698e51ce93d">lzma_stream_buffer_encode()</a>.</p>

</div>
</div>
<a class="anchor" id="a4e5a35bc05ca572acdae55a294c8cc89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lzma_next_coder_init</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">func, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">next, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">allocator&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> { \</div>
<div class="line">        if ((uintptr_t)(func) != (next)-&gt;init) \</div>
<div class="line">                lzma_next_end(next, allocator); \</div>
<div class="line">        (next)-&gt;init = (uintptr_t)(func); \</div>
<div class="line">} <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment --><p>If next isn't already initialized, free the previous coder. Then mark that next is <em>possibly</em> initialized for the coder using this macro. "Possibly" means that if e.g. allocation of next-&gt;coder fails, the structure isn't actually initialized for this coder, but leaving next-&gt;init to func is still OK. </p>

<p>Referenced by <a class="el" href="common_8h.html#a083a413c43195aed33e19b1d2c043f88">lzma_next_filter_init()</a>.</p>

</div>
</div>
<a class="anchor" id="a844da62faaaf4c19a9a297129bc30a8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lzma_next_strm_init</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">func, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="coder_8c.html#a048a6ae6a7da50de565b15d52ea9fafe">strm</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> { \</div>
<div class="line">        return_if_error(lzma_strm_init(<a class="code" href="coder_8c.html#a048a6ae6a7da50de565b15d52ea9fafe" title="Stream used to communicate with liblzma.">strm</a>)); \</div>
<div class="line">        const <a class="code" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e" title="Return values used by several functions in liblzma.">lzma_ret</a> ret_ = func(&amp;(<a class="code" href="coder_8c.html#a048a6ae6a7da50de565b15d52ea9fafe" title="Stream used to communicate with liblzma.">strm</a>)-&gt;internal-&gt;next, \</div>
<div class="line">                        (<a class="code" href="coder_8c.html#a048a6ae6a7da50de565b15d52ea9fafe" title="Stream used to communicate with liblzma.">strm</a>)-&gt;allocator, __VA_ARGS__); \</div>
<div class="line">        if (ret_ != <a class="code" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe" title="Operation completed successfully.">LZMA_OK</a>) { \</div>
<div class="line">                lzma_end(<a class="code" href="coder_8c.html#a048a6ae6a7da50de565b15d52ea9fafe" title="Stream used to communicate with liblzma.">strm</a>); \</div>
<div class="line">                return ret_; \</div>
<div class="line">        } \</div>
<div class="line">} <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment --><p>Initializes lzma_strm and calls func() to initialize strm-&gt;internal-&gt;next. (The function being called will use <a class="el" href="common_8h.html#a4e5a35bc05ca572acdae55a294c8cc89">lzma_next_coder_init()</a>). If initialization fails, memory that wasn't freed by func() is freed along strm-&gt;internal. </p>

<p>Referenced by <a class="el" href="alone__decoder_8c.html#a557f24c908c5a192dc55f5f9e7674536">lzma_alone_decoder()</a>, <a class="el" href="container_8h.html#a26fcc5bccdf3f862caa4c992d01e1a72">lzma_alone_encoder()</a>, <a class="el" href="auto__decoder_8c.html#a9e11aae50c8b28fdff631a16af8dbfc7">lzma_auto_decoder()</a>, <a class="el" href="block__decoder_8c.html#a2a1807b69c59fc4bd87744647700eb2d">lzma_block_decoder()</a>, <a class="el" href="block__encoder_8c.html#a933285cbceb03c0e2507f8e0bb737a79">lzma_block_encoder()</a>, <a class="el" href="index__decoder_8c.html#a8a43bb2ce4b3d5165db980fcdaa0a5ce">lzma_index_decoder()</a>, <a class="el" href="index__encoder_8c.html#ad1398e64633414d8f50e6ae5432958e2">lzma_index_encoder()</a>, <a class="el" href="filter__decoder_8c.html#a387ecaa6c881a89021cf577d719490bb">lzma_raw_decoder()</a>, <a class="el" href="filter__encoder_8c.html#aed21808fcea4df30f742c5369627f731">lzma_raw_encoder()</a>, <a class="el" href="stream__decoder_8c.html#aa251bc5b49846a1096f934d774157250">lzma_stream_decoder()</a>, and <a class="el" href="stream__encoder_8c.html#a19acfa3822b05132cd81edc010fe2272">lzma_stream_encoder()</a>.</p>

</div>
</div>
<h2>Typedef Documentation</h2>
<a class="anchor" id="a4fd16c96358c705abab5da65940aa1b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlzma__coder__s.html">lzma_coder_s</a> <a class="el" href="common_8h.html#a4fd16c96358c705abab5da65940aa1b1">lzma_coder</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of encoder/decoder specific data; the actual structure is defined differently in different coders. </p>

</div>
</div>
<a class="anchor" id="a2897729ce4e6af56b4412222bdc4280f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>(* lzma_init_function)(<a class="el" href="structlzma__next__coder__s.html">lzma_next_coder</a> *next, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator, const <a class="el" href="structlzma__filter__info__s.html">lzma_filter_info</a> *<a class="el" href="coder_8c.html#a9325236d5759d4eaadcba08a6bb5c96f">filters</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of a function used to initialize a filter encoder or decoder. </p>

</div>
</div>
<a class="anchor" id="a31f6f422451d4b782091365d7f2ae29b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>(* lzma_code_function)(<a class="el" href="common_8h.html#a4fd16c96358c705abab5da65940aa1b1">lzma_coder</a> *coder, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator, const uint8_t *restrict in, size_t *restrict in_pos, size_t in_size, uint8_t *restrict out, size_t *restrict out_pos, size_t out_size, <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77e">lzma_action</a> action)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of a function to do some kind of coding work (filters, Stream, Block encoders/decoders etc.). Some special coders use don't use both input and output buffers, but for simplicity they still use this same function prototype. </p>

</div>
</div>
<a class="anchor" id="a0aa97c452db5b3f4c5cb331337b5dbe6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* lzma_end_function)(<a class="el" href="common_8h.html#a4fd16c96358c705abab5da65940aa1b1">lzma_coder</a> *coder, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of a function to free the memory allocated for the coder. </p>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="ac58f96267a4f66bb15db736968b98008"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* lzma_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory. </p>

<p>Referenced by <a class="el" href="index_8c.html#a2db488e0703ae8bb890202d505b1d82d">index_dup_stream()</a>, <a class="el" href="index_8c.html#a2735b9fc95daaac1420cd6ebae2a2fa8">index_stream_init()</a>, <a class="el" href="filter__common_8c.html#a81cd5593eb33e5e62a0fd5112e87d831">lzma_filters_copy()</a>, <a class="el" href="index_8c.html#a37a3414069a2bcf3cae1baa52c455441">lzma_index_append()</a>, <a class="el" href="index__hash_8c.html#a3aeca7881f96d38353480997d579ba23">lzma_index_hash_init()</a>, and <a class="el" href="common_8h.html#a83455498798efe8409f8b9f11a77b2aa">lzma_strm_init()</a>.</p>

</div>
</div>
<a class="anchor" id="a11940cc6553c7274d0cc313bebd00e6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lzma_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory. </p>

<p>References <a class="el" href="structlzma__allocator.html#a4fe2dc8c939119a3ecdfee14a47c3de2">lzma_allocator::free</a>, and <a class="el" href="structlzma__allocator.html#aab293a5007a93299cc97ee8b5fb81268">lzma_allocator::opaque</a>.</p>

</div>
</div>
<a class="anchor" id="a83455498798efe8409f8b9f11a77b2aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_strm_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__stream.html">lzma_stream</a> *&#160;</td>
          <td class="paramname"><em>strm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates strm-&gt;internal if it is NULL, and initializes *strm and strm-&gt;internal. This function is only called via lzma_next_strm_init macro. </p>

<p>References <a class="el" href="structlzma__stream.html#a8caccb93bac010e5f87bbd9d5f18af27">lzma_stream::allocator</a>, <a class="el" href="structlzma__internal__s.html#aba6238182edce9baab1a9b3af63e073b">lzma_internal_s::allow_buf_error</a>, <a class="el" href="structlzma__stream.html#a209da54c2fb5dea40ad011c8408300d0">lzma_stream::internal</a>, <a class="el" href="common_8h.html#ac58f96267a4f66bb15db736968b98008">lzma_alloc()</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea567e1464feca03900a5425fb45b2f5b6">LZMA_MEM_ERROR</a>, <a class="el" href="common_8h.html#a1fca27f3d292f89fffbf7162d34a5bc3">LZMA_NEXT_CODER_INIT</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea2dac8d451cb38da8550653d0d7be4ec2">LZMA_PROG_ERROR</a>, <a class="el" href="structlzma__internal__s.html#a5bdb142bf9982fbbc7f5c29156ccab43">lzma_internal_s::next</a>, <a class="el" href="structlzma__internal__s.html#a5cabfc95cdd0bf68f3b5de76ce44170e">lzma_internal_s::sequence</a>, <a class="el" href="structlzma__internal__s.html#a439e9d7a00f163303f3b40fcef66f955">lzma_internal_s::supported_actions</a>, <a class="el" href="structlzma__stream.html#a1a411e1755d6185756caefabc3932c7b">lzma_stream::total_in</a>, and <a class="el" href="structlzma__stream.html#a80d703ffdfd7661e344fe7b61ff737fa">lzma_stream::total_out</a>.</p>

</div>
</div>
<a class="anchor" id="a083a413c43195aed33e19b1d2c043f88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_next_filter_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__next__coder__s.html">lzma_next_coder</a> *&#160;</td>
          <td class="paramname"><em>next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlzma__filter__info__s.html">lzma_filter_info</a> *&#160;</td>
          <td class="paramname"><em>filters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the next filter in the chain, if any. This takes care of freeing the memory of previously initialized filter if it is different than the filter being initialized now. This way the actual filter initialization functions don't need to use lzma_next_coder_init macro. </p>

<p>References <a class="el" href="structlzma__filter__info__s.html#a748331bd1a36a9bf3cc57af69582a173">lzma_filter_info_s::id</a>, <a class="el" href="structlzma__next__coder__s.html#a5d536a495df657dd90415a4dad1860a8">lzma_next_coder_s::id</a>, <a class="el" href="structlzma__filter__info__s.html#ac5e483e8fcaa10f1c0a1111b36db1bac">lzma_filter_info_s::init</a>, <a class="el" href="common_8h.html#a4e5a35bc05ca572acdae55a294c8cc89">lzma_next_coder_init</a>, and <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>.</p>

</div>
</div>
<a class="anchor" id="a751a67a126c4701bbac3eaa6042fe36b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_next_filter_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__next__coder__s.html">lzma_next_coder</a> *&#160;</td>
          <td class="paramname"><em>next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlzma__filter.html">lzma_filter</a> *&#160;</td>
          <td class="paramname"><em>reversed_filters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the next filter in the chain, if any. This checks that the application is not trying to change the Filter IDs. </p>

<p>References <a class="el" href="structlzma__next__coder__s.html#ac2064cebf4a0f2f9abb2e090348dae4a">lzma_next_coder_s::coder</a>, <a class="el" href="structlzma__next__coder__s.html#a5d536a495df657dd90415a4dad1860a8">lzma_next_coder_s::id</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea2dac8d451cb38da8550653d0d7be4ec2">LZMA_PROG_ERROR</a>, <a class="el" href="vli_8h.html#a5a4b28254a30c859018b896ed371d69a">LZMA_VLI_UNKNOWN</a>, and <a class="el" href="structlzma__next__coder__s.html#a4c39fc7a9b192010e4ac413bc17cb6d3">lzma_next_coder_s::update</a>.</p>

</div>
</div>
<a class="anchor" id="a2ed13e809d1cd8253f04193820136e4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lzma_next_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__next__coder__s.html">lzma_next_coder</a> *&#160;</td>
          <td class="paramname"><em>next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees the memory allocated for next-&gt;coder either using next-&gt;end or, if next-&gt;end is NULL, using lzma_free. </p>

<p>References <a class="el" href="structlzma__next__coder__s.html#ac2064cebf4a0f2f9abb2e090348dae4a">lzma_next_coder_s::coder</a>, <a class="el" href="structlzma__next__coder__s.html#a9c7f8bdf058d498a3de54730f1fa2ac1">lzma_next_coder_s::end</a>, <a class="el" href="structlzma__next__coder__s.html#a8de5f47b0ff5783c2ad24241e7d540d7">lzma_next_coder_s::init</a>, and <a class="el" href="common_8h.html#a1fca27f3d292f89fffbf7162d34a5bc3">LZMA_NEXT_CODER_INIT</a>.</p>

</div>
</div>
<a class="anchor" id="a9ffbf0181223d38d596508a3b47488b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t lzma_bufcpy </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *restrict&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *restrict&#160;</td>
          <td class="paramname"><em>in_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>in_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *restrict&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *restrict&#160;</td>
          <td class="paramname"><em>out_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>out_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy as much data as possible from in[] to out[] and update *in_pos and *out_pos accordingly. Returns the number of bytes copied. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jun 5 2014 14:29:27 for XZ Utils by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
