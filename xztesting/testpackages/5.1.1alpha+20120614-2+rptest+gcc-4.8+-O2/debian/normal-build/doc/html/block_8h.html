<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>XZ Utils: liblzma/api/lzma/block.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">XZ Utils
   &#160;<span id="projectnumber">5.1.0alpha</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2e0898c272e1f0f93c8ef15f5da2a912.html">liblzma</a></li><li class="navelem"><a class="el" href="dir_3c7592c36b11e0fd373edb6a27c72b1d.html">api</a></li><li class="navelem"><a class="el" href="dir_48cf7e51417fe935412ca5117cfff3c4.html">lzma</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">block.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>.xz Block handling  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__block.html">lzma_block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for the Block and Block Header encoders and decoders.  <a href="structlzma__block.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a9263c5b314592e658772e5eb83ffdd78"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9263c5b314592e658772e5eb83ffdd78"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LZMA_BLOCK_HEADER_SIZE_MIN</b>&#160;&#160;&#160;8</td></tr>
<tr class="memitem:af7a39189d0721c55313a401b63811e49"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7a39189d0721c55313a401b63811e49"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LZMA_BLOCK_HEADER_SIZE_MAX</b>&#160;&#160;&#160;1024</td></tr>
<tr class="memitem:ac025c940683a70f4c7f956bad814fd5f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block_8h.html#ac025c940683a70f4c7f956bad814fd5f">lzma_block_header_size_decode</a>(b)&#160;&#160;&#160;(((uint32_t)(b) + 1) * 4)</td></tr>
<tr class="memdesc:ac025c940683a70f4c7f956bad814fd5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the Block Header Size field.  <a href="#ac025c940683a70f4c7f956bad814fd5f"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae9b47abc872d0b02c2da9d3fa5a7dacd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block_8h.html#ae9b47abc872d0b02c2da9d3fa5a7dacd">lzma_block_header_size</a> (<a class="el" href="structlzma__block.html">lzma_block</a> *block) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:ae9b47abc872d0b02c2da9d3fa5a7dacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate Block Header Size.  <a href="#ae9b47abc872d0b02c2da9d3fa5a7dacd"></a><br/></td></tr>
<tr class="memitem:a0eedbd6331d5708ea963260e6f2a92d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block_8h.html#a0eedbd6331d5708ea963260e6f2a92d0">lzma_block_header_encode</a> (const <a class="el" href="structlzma__block.html">lzma_block</a> *block, uint8_t *out) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:a0eedbd6331d5708ea963260e6f2a92d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode Block Header.  <a href="#a0eedbd6331d5708ea963260e6f2a92d0"></a><br/></td></tr>
<tr class="memitem:a71ddd0bec506092018e407ed6f027f53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block_8h.html#a71ddd0bec506092018e407ed6f027f53">lzma_block_header_decode</a> (<a class="el" href="structlzma__block.html">lzma_block</a> *block, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator, const uint8_t *in) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:a71ddd0bec506092018e407ed6f027f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode Block Header.  <a href="#a71ddd0bec506092018e407ed6f027f53"></a><br/></td></tr>
<tr class="memitem:a6c3e102d76db06a07126a569abc6e2bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block_8h.html#a6c3e102d76db06a07126a569abc6e2bc">lzma_block_compressed_size</a> (<a class="el" href="structlzma__block.html">lzma_block</a> *block, <a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> unpadded_size) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:a6c3e102d76db06a07126a569abc6e2bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate and set Compressed Size according to Unpadded Size.  <a href="#a6c3e102d76db06a07126a569abc6e2bc"></a><br/></td></tr>
<tr class="memitem:a412d5605280fa29befae1b89e344bf30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block_8h.html#a412d5605280fa29befae1b89e344bf30">lzma_block_unpadded_size</a> (const <a class="el" href="structlzma__block.html">lzma_block</a> *block) lzma_nothrow lzma_attr_pure</td></tr>
<tr class="memdesc:a412d5605280fa29befae1b89e344bf30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate Unpadded Size.  <a href="#a412d5605280fa29befae1b89e344bf30"></a><br/></td></tr>
<tr class="memitem:a694424f9dfdd5151e01debac1c501fa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block_8h.html#a694424f9dfdd5151e01debac1c501fa9">lzma_block_total_size</a> (const <a class="el" href="structlzma__block.html">lzma_block</a> *block) lzma_nothrow lzma_attr_pure</td></tr>
<tr class="memdesc:a694424f9dfdd5151e01debac1c501fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the total encoded size of a Block.  <a href="#a694424f9dfdd5151e01debac1c501fa9"></a><br/></td></tr>
<tr class="memitem:a2218a49025a0b44f9a6f9d6d24359359"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block_8h.html#a2218a49025a0b44f9a6f9d6d24359359">lzma_block_encoder</a> (<a class="el" href="structlzma__stream.html">lzma_stream</a> *<a class="el" href="coder_8c.html#a048a6ae6a7da50de565b15d52ea9fafe">strm</a>, <a class="el" href="structlzma__block.html">lzma_block</a> *block) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:a2218a49025a0b44f9a6f9d6d24359359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize .xz Block encoder.  <a href="#a2218a49025a0b44f9a6f9d6d24359359"></a><br/></td></tr>
<tr class="memitem:aa92c73b2a228efe921fa2376aa7adc92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block_8h.html#aa92c73b2a228efe921fa2376aa7adc92">lzma_block_decoder</a> (<a class="el" href="structlzma__stream.html">lzma_stream</a> *<a class="el" href="coder_8c.html#a048a6ae6a7da50de565b15d52ea9fafe">strm</a>, <a class="el" href="structlzma__block.html">lzma_block</a> *block) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:aa92c73b2a228efe921fa2376aa7adc92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize .xz Block decoder.  <a href="#aa92c73b2a228efe921fa2376aa7adc92"></a><br/></td></tr>
<tr class="memitem:a58ff73e2572b529f48cc590bfffe5b4f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block_8h.html#a58ff73e2572b529f48cc590bfffe5b4f">lzma_block_buffer_bound</a> (size_t uncompressed_size) lzma_nothrow</td></tr>
<tr class="memdesc:a58ff73e2572b529f48cc590bfffe5b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate maximum output size for single-call Block encoding.  <a href="#a58ff73e2572b529f48cc590bfffe5b4f"></a><br/></td></tr>
<tr class="memitem:a41e080db33169819f985595d48a157bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block_8h.html#a41e080db33169819f985595d48a157bc">lzma_block_buffer_encode</a> (<a class="el" href="structlzma__block.html">lzma_block</a> *block, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator, const uint8_t *in, size_t in_size, uint8_t *out, size_t *out_pos, size_t out_size) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:a41e080db33169819f985595d48a157bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-call .xz Block encoder.  <a href="#a41e080db33169819f985595d48a157bc"></a><br/></td></tr>
<tr class="memitem:a2bdf26b5fb43880364991a1536d74346"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block_8h.html#a2bdf26b5fb43880364991a1536d74346">lzma_block_buffer_decode</a> (<a class="el" href="structlzma__block.html">lzma_block</a> *block, <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator, const uint8_t *in, size_t *in_pos, size_t in_size, uint8_t *out, size_t *out_pos, size_t out_size) lzma_nothrow</td></tr>
<tr class="memdesc:a2bdf26b5fb43880364991a1536d74346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-call .xz Block decoder.  <a href="#a2bdf26b5fb43880364991a1536d74346"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>.xz Block handling </p>
</div><h2>Macro Definition Documentation</h2>
<a class="anchor" id="ac025c940683a70f4c7f956bad814fd5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lzma_block_header_size_decode</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td>&#160;&#160;&#160;(((uint32_t)(b) + 1) * 4)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode the Block Header Size field. </p>
<p>To decode Block Header using <a class="el" href="block_8h.html#a71ddd0bec506092018e407ed6f027f53" title="Decode Block Header.">lzma_block_header_decode()</a>, the size of the Block Header has to be known and stored into <a class="el" href="structlzma__block.html#a6689c4f7524b2c05772a2d6151138610" title="Size of the Block Header field.">lzma_block.header_size</a>. The size can be calculated from the first byte of a Block using this macro. Note that if the first byte is 0x00, it indicates beginning of Index; use this macro only when the byte is not 0x00.</p>
<p>There is no encoding macro, because Block Header encoder is enough for that. </p>

<p>Referenced by <a class="el" href="block__header__decoder_8c.html#ac85bbf9df6709081a8112c8826b4997b">lzma_block_header_decode()</a>, and <a class="el" href="list_8c.html#ae8bf55be793e1ad58bc179ac19168c90">parse_block_header()</a>.</p>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="ae9b47abc872d0b02c2da9d3fa5a7dacd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_block_header_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__block.html">lzma_block</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate Block Header Size. </p>
<p>Calculate the minimum size needed for the Block Header field using the settings specified in the <a class="el" href="structlzma__block.html" title="Options for the Block and Block Header encoders and decoders.">lzma_block</a> structure. Note that it is OK to increase the calculated header_size value as long as it is a multiple of four and doesn't exceed LZMA_BLOCK_HEADER_SIZE_MAX. Increasing header_size just means that <a class="el" href="block_8h.html#a0eedbd6331d5708ea963260e6f2a92d0" title="Encode Block Header.">lzma_block_header_encode()</a> will add Header Padding.</p>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK: Size calculated successfully and stored to block-&gt;header_size.<ul>
<li>LZMA_OPTIONS_ERROR: Unsupported version, filters or filter options.</li>
<li>LZMA_PROG_ERROR: Invalid values like compressed_size == 0.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This doesn't check that all the options are valid i.e. this may return LZMA_OK even if <a class="el" href="block_8h.html#a0eedbd6331d5708ea963260e6f2a92d0" title="Encode Block Header.">lzma_block_header_encode()</a> or <a class="el" href="block_8h.html#a2218a49025a0b44f9a6f9d6d24359359" title="Initialize .xz Block encoder.">lzma_block_encoder()</a> would fail. If you want to validate the filter chain, consider using lzma_memlimit_encoder() which as a side-effect validates the filter chain. </dd></dl>

<p>References <a class="el" href="filter_8h.html#a996c9c21840ed54e37bd1f664a79d940">lzma_filter_flags_size()</a>, <a class="el" href="filter_8h.html#ab33c0cc1728bf390e5b84f8bce1928ba">LZMA_FILTERS_MAX</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eaa9ff6dfee36b7aba4fae60706d37425f">LZMA_OPTIONS_ERROR</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea2dac8d451cb38da8550653d0d7be4ec2">LZMA_PROG_ERROR</a>, <a class="el" href="vli_8h.html#a8d53e0b69934b43da8721fa6f1e8cc4f">lzma_vli_size()</a>, <a class="el" href="vli_8h.html#a5a4b28254a30c859018b896ed371d69a">LZMA_VLI_UNKNOWN</a>, and <a class="el" href="common_8h.html#a3e1bf9f33b917e883b886b8a10458d66">return_if_error</a>.</p>

</div>
</div>
<a class="anchor" id="a0eedbd6331d5708ea963260e6f2a92d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_block_header_encode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlzma__block.html">lzma_block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode Block Header. </p>
<p>The caller must have calculated the size of the Block Header already with <a class="el" href="block_8h.html#ae9b47abc872d0b02c2da9d3fa5a7dacd" title="Calculate Block Header Size.">lzma_block_header_size()</a>. If a value larger than the one calculated by <a class="el" href="block_8h.html#ae9b47abc872d0b02c2da9d3fa5a7dacd" title="Calculate Block Header Size.">lzma_block_header_size()</a> is used, the Block Header will be padded to the specified size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Beginning of the output buffer. This must be at least block-&gt;header_size bytes. </td></tr>
    <tr><td class="paramname">block</td><td>Block options to be encoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK: Encoding was successful. block-&gt;header_size bytes were written to output buffer.<ul>
<li>LZMA_OPTIONS_ERROR: Invalid or unsupported options.</li>
<li>LZMA_PROG_ERROR: Invalid arguments, for example block-&gt;header_size is invalid or block-&gt;filters is NULL. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="block_8h.html#a412d5605280fa29befae1b89e344bf30">lzma_block_unpadded_size()</a>, <a class="el" href="api_2lzma_2check_8h.html#a760b569cce91bdd01e4ce9d78823c96d">lzma_crc32()</a>, <a class="el" href="filter_8h.html#a96f23309bc21398fece18c00ebe7db98">lzma_filter_flags_encode()</a>, <a class="el" href="filter_8h.html#ab33c0cc1728bf390e5b84f8bce1928ba">LZMA_FILTERS_MAX</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea2dac8d451cb38da8550653d0d7be4ec2">LZMA_PROG_ERROR</a>, <a class="el" href="vli_8h.html#a50bbb77e9ec3b72c25586aa700c20970">lzma_vli_encode()</a>, <a class="el" href="vli_8h.html#a4f67ed698215d865a2b87a95ab1320dd">lzma_vli_is_valid</a>, <a class="el" href="vli_8h.html#a5a4b28254a30c859018b896ed371d69a">LZMA_VLI_UNKNOWN</a>, and <a class="el" href="common_8h.html#a3e1bf9f33b917e883b886b8a10458d66">return_if_error</a>.</p>

</div>
</div>
<a class="anchor" id="a71ddd0bec506092018e407ed6f027f53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_block_header_decode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__block.html">lzma_block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode Block Header. </p>
<p>block-&gt;version should be set to the highest value supported by the application; currently the only possible version is zero. This function will set version to the lowest value that still supports all the features required by the Block Header.</p>
<p>The size of the Block Header must have already been decoded with <a class="el" href="block_8h.html#ac025c940683a70f4c7f956bad814fd5f" title="Decode the Block Header Size field.">lzma_block_header_size_decode()</a> macro and stored to block-&gt;header_size.</p>
<p>block-&gt;filters must have been allocated, but they don't need to be initialized (possible existing filter options are not freed).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>Destination for Block options. </td></tr>
    <tr><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() (and also free() if an error occurs). </td></tr>
    <tr><td class="paramname">in</td><td>Beginning of the input buffer. This must be at least block-&gt;header_size bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK: Decoding was successful. block-&gt;header_size bytes were read from the input buffer.<ul>
<li>LZMA_OPTIONS_ERROR: The Block Header specifies some unsupported options such as unsupported filters. This can happen also if block-&gt;version was set to a too low value compared to what would be required to properly represent the information stored in the Block Header.</li>
<li>LZMA_DATA_ERROR: Block Header is corrupt, for example, the CRC32 doesn't match.</li>
<li>LZMA_PROG_ERROR: Invalid arguments, for example block-&gt;header_size is invalid or block-&gt;filters is NULL. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="block_8h.html#ac025c940683a70f4c7f956bad814fd5f">lzma_block_header_size_decode</a>, <a class="el" href="block_8h.html#a412d5605280fa29befae1b89e344bf30">lzma_block_unpadded_size()</a>, <a class="el" href="api_2lzma_2check_8h.html#acd221ababe30230d9647aab469ad80cb">LZMA_CHECK_ID_MAX</a>, <a class="el" href="api_2lzma_2check_8h.html#a760b569cce91bdd01e4ce9d78823c96d">lzma_crc32()</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea3aa72729a844790e39b4e1101a731dfb">LZMA_DATA_ERROR</a>, <a class="el" href="filter_8h.html#aadadfde2b6fd2d4b247a277423a67d32">lzma_filter_flags_decode()</a>, <a class="el" href="filter_8h.html#ab33c0cc1728bf390e5b84f8bce1928ba">LZMA_FILTERS_MAX</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eaa9ff6dfee36b7aba4fae60706d37425f">LZMA_OPTIONS_ERROR</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea2dac8d451cb38da8550653d0d7be4ec2">LZMA_PROG_ERROR</a>, <a class="el" href="vli_8h.html#a7b7d50e1074e0e2bcd81c29a5f7461c7">lzma_vli_decode()</a>, <a class="el" href="vli_8h.html#a5a4b28254a30c859018b896ed371d69a">LZMA_VLI_UNKNOWN</a>, and <a class="el" href="common_8h.html#a3e1bf9f33b917e883b886b8a10458d66">return_if_error</a>.</p>

<p>Referenced by <a class="el" href="list_8c.html#ae8bf55be793e1ad58bc179ac19168c90">parse_block_header()</a>.</p>

</div>
</div>
<a class="anchor" id="a6c3e102d76db06a07126a569abc6e2bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_block_compressed_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__block.html">lzma_block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td>
          <td class="paramname"><em>unpadded_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate and set Compressed Size according to Unpadded Size. </p>
<p>Block Header stores Compressed Size, but Index has Unpadded Size. If the application has already parsed the Index and is now decoding Blocks, it can calculate Compressed Size from Unpadded Size. This function does exactly that with error checking:</p>
<ul>
<li>Compressed Size calculated from Unpadded Size must be positive integer, that is, Unpadded Size must be big enough that after Block Header and Check fields there's still at least one byte for Compressed Size.</li>
</ul>
<ul>
<li>If Compressed Size was present in Block Header, the new value calculated from Unpadded Size is compared against the value from Block Header.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This function must be called <em>after</em> decoding the Block Header field so that it can properly validate Compressed Size if it was present in Block Header.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK: block-&gt;compressed_size was set successfully.<ul>
<li>LZMA_DATA_ERROR: unpadded_size is too small compared to block-&gt;header_size and lzma_check_size(block-&gt;check).</li>
<li>LZMA_PROG_ERROR: Some values are invalid. For example, block-&gt;header_size must be a multiple of four and between 8 and 1024 inclusive. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="block_8h.html#a412d5605280fa29befae1b89e344bf30">lzma_block_unpadded_size()</a>, <a class="el" href="api_2lzma_2check_8h.html#afd3fda19575d9d4f864c626c02b7cb48">lzma_check_size()</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea3aa72729a844790e39b4e1101a731dfb">LZMA_DATA_ERROR</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea2dac8d451cb38da8550653d0d7be4ec2">LZMA_PROG_ERROR</a>, and <a class="el" href="vli_8h.html#a5a4b28254a30c859018b896ed371d69a">LZMA_VLI_UNKNOWN</a>.</p>

<p>Referenced by <a class="el" href="list_8c.html#ae8bf55be793e1ad58bc179ac19168c90">parse_block_header()</a>.</p>

</div>
</div>
<a class="anchor" id="a412d5605280fa29befae1b89e344bf30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> lzma_block_unpadded_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlzma__block.html">lzma_block</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate Unpadded Size. </p>
<p>The Index field stores Unpadded Size and Uncompressed Size. The latter can be taken directly from the <a class="el" href="structlzma__block.html" title="Options for the Block and Block Header encoders and decoders.">lzma_block</a> structure after coding a Block, but Unpadded Size needs to be calculated from Block Header Size, Compressed Size, and size of the Check field. This is where this function is needed.</p>
<dl class="section return"><dt>Returns</dt><dd>Unpadded Size on success, or zero on error. </dd></dl>

<p>References <a class="el" href="api_2lzma_2check_8h.html#acd221ababe30230d9647aab469ad80cb">LZMA_CHECK_ID_MAX</a>, <a class="el" href="api_2lzma_2check_8h.html#afd3fda19575d9d4f864c626c02b7cb48">lzma_check_size()</a>, <a class="el" href="vli_8h.html#a4f67ed698215d865a2b87a95ab1320dd">lzma_vli_is_valid</a>, and <a class="el" href="vli_8h.html#a5a4b28254a30c859018b896ed371d69a">LZMA_VLI_UNKNOWN</a>.</p>

<p>Referenced by <a class="el" href="block_8h.html#a6c3e102d76db06a07126a569abc6e2bc">lzma_block_compressed_size()</a>, <a class="el" href="block__header__decoder_8c.html#ac85bbf9df6709081a8112c8826b4997b">lzma_block_header_decode()</a>, <a class="el" href="block__header__encoder_8c.html#a01a1e06f40b56d8ca61ac577e77a4fec">lzma_block_header_encode()</a>, <a class="el" href="block_8h.html#a694424f9dfdd5151e01debac1c501fa9">lzma_block_total_size()</a>, and <a class="el" href="stream__buffer__encoder_8c.html#a932a602de4f44d8525687698e51ce93d">lzma_stream_buffer_encode()</a>.</p>

</div>
</div>
<a class="anchor" id="a694424f9dfdd5151e01debac1c501fa9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> lzma_block_total_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlzma__block.html">lzma_block</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the total encoded size of a Block. </p>
<p>This is equivalent to <a class="el" href="block_8h.html#a412d5605280fa29befae1b89e344bf30" title="Calculate Unpadded Size.">lzma_block_unpadded_size()</a> except that the returned value includes the size of the Block Padding field.</p>
<dl class="section return"><dt>Returns</dt><dd>On success, total encoded size of the Block. On error, zero is returned. </dd></dl>

<p>References <a class="el" href="block_8h.html#a412d5605280fa29befae1b89e344bf30">lzma_block_unpadded_size()</a>, and <a class="el" href="vli_8h.html#a5a4b28254a30c859018b896ed371d69a">LZMA_VLI_UNKNOWN</a>.</p>

</div>
</div>
<a class="anchor" id="a2218a49025a0b44f9a6f9d6d24359359"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_block_encoder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__stream.html">lzma_stream</a> *&#160;</td>
          <td class="paramname"><em>strm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__block.html">lzma_block</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize .xz Block encoder. </p>
<p>Valid actions for <a class="el" href="base_8h.html#a28cc09bc422d5ba1e0187c9f2af5d957" title="Encode or decode data.">lzma_code()</a> are LZMA_RUN, LZMA_SYNC_FLUSH (only if the filter chain supports it), and LZMA_FINISH.</p>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK: All good, continue with <a class="el" href="base_8h.html#a28cc09bc422d5ba1e0187c9f2af5d957" title="Encode or decode data.">lzma_code()</a>.<ul>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_UNSUPPORTED_CHECK: block-&gt;check specifies a Check ID that is not supported by this buid of liblzma. Initializing the encoder failed.</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

<p>References <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea7d24fb3c6c144d13bcb091195b8ebec1">LZMA_FINISH</a>, <a class="el" href="common_8h.html#a844da62faaaf4c19a9a297129bc30a8c">lzma_next_strm_init</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, and <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea868472b76492afcaef54020a481890b1">LZMA_RUN</a>.</p>

</div>
</div>
<a class="anchor" id="aa92c73b2a228efe921fa2376aa7adc92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_block_decoder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__stream.html">lzma_stream</a> *&#160;</td>
          <td class="paramname"><em>strm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__block.html">lzma_block</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize .xz Block decoder. </p>
<p>Valid actions for <a class="el" href="base_8h.html#a28cc09bc422d5ba1e0187c9f2af5d957" title="Encode or decode data.">lzma_code()</a> are LZMA_RUN and LZMA_FINISH. Using LZMA_FINISH is not required. It is supported only for convenience.</p>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK: All good, continue with <a class="el" href="base_8h.html#a28cc09bc422d5ba1e0187c9f2af5d957" title="Encode or decode data.">lzma_code()</a>.<ul>
<li>LZMA_UNSUPPORTED_CHECK: Initialization was successful, but the given Check ID is not supported, thus Check will be ignored.</li>
<li>LZMA_PROG_ERROR</li>
<li>LZMA_MEM_ERROR </li>
</ul>
</dd></dl>

<p>References <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea7d24fb3c6c144d13bcb091195b8ebec1">LZMA_FINISH</a>, <a class="el" href="common_8h.html#a844da62faaaf4c19a9a297129bc30a8c">lzma_next_strm_init</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, and <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea868472b76492afcaef54020a481890b1">LZMA_RUN</a>.</p>

</div>
</div>
<a class="anchor" id="a58ff73e2572b529f48cc590bfffe5b4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t lzma_block_buffer_bound </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uncompressed_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate maximum output size for single-call Block encoding. </p>
<p>This is equivalent to <a class="el" href="container_8h.html#a66d4366a47b8332bff2a512f44f5c45e" title="Calculate output buffer size for single-call Stream encoder.">lzma_stream_buffer_bound()</a> but for .xz Blocks. See the documentation of <a class="el" href="container_8h.html#a66d4366a47b8332bff2a512f44f5c45e" title="Calculate output buffer size for single-call Stream encoder.">lzma_stream_buffer_bound()</a>. </p>

<p>References <a class="el" href="block__buffer__encoder_8c.html#a6cf3bc89aed406bb48c785dca58ae9da">HEADERS_BOUND</a>, and <a class="el" href="vli_8h.html#a2d8bf5322898bfa11945848420585881">LZMA_VLI_C</a>.</p>

<p>Referenced by <a class="el" href="stream__buffer__encoder_8c.html#a870286986caa1c0ac6ce6c4074284420">lzma_stream_buffer_bound()</a>.</p>

</div>
</div>
<a class="anchor" id="a41e080db33169819f985595d48a157bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_block_buffer_encode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__block.html">lzma_block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>in_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>out_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>out_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-call .xz Block encoder. </p>
<p>In contrast to the multi-call encoder initialized with <a class="el" href="block_8h.html#a2218a49025a0b44f9a6f9d6d24359359" title="Initialize .xz Block encoder.">lzma_block_encoder()</a>, this function encodes also the Block Header. This is required to make it possible to write appropriate Block Header also in case the data isn't compressible, and different filter chain has to be used to encode the data in uncompressed form using uncompressed chunks of the LZMA2 filter.</p>
<p>When the data isn't compressible, header_size, compressed_size, and uncompressed_size are set just like when the data was compressible, but it is possible that header_size is too small to hold the filter chain specified in block-&gt;filters, because that isn't necessarily the filter chain that was actually used to encode the data. <a class="el" href="block_8h.html#a412d5605280fa29befae1b89e344bf30" title="Calculate Unpadded Size.">lzma_block_unpadded_size()</a> still works normally, because it doesn't read the filters array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>Block options: block-&gt;version, block-&gt;check, and block-&gt;filters must have been initialized. </td></tr>
    <tr><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). </td></tr>
    <tr><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramname">in_size</td><td>Size of the input buffer </td></tr>
    <tr><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramname">out_pos</td><td>The next byte will be written to out[*out_pos]. *out_pos is updated only if encoding succeeds. </td></tr>
    <tr><td class="paramname">out_size</td><td>Size of the out buffer; the first byte into which no data is written to is out[out_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK: Encoding was successful.<ul>
<li>LZMA_BUF_ERROR: Not enough output buffer space.</li>
<li>LZMA_UNSUPPORTED_CHECK</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_DATA_ERROR</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

<p>References <a class="el" href="structlzma__check__state.html#a66d54715269b349088561ee800cd2356">lzma_check_state::buffer</a>, <a class="el" href="coder_8c.html#a5c94b0defea7996f245faec2693056cb">check</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea9ca0ecb62459bdc84d6af47d16b23ae5">LZMA_BUF_ERROR</a>, <a class="el" href="check_8c.html#a682bfef0e2be646de63dbcba0eb6a33e">lzma_check_finish()</a>, <a class="el" href="api_2lzma_2check_8h.html#acd221ababe30230d9647aab469ad80cb">LZMA_CHECK_ID_MAX</a>, <a class="el" href="check_8c.html#aeb14796081bbe051ca7a08952c7383e8">lzma_check_init()</a>, <a class="el" href="api_2lzma_2check_8h.html#ae9391ed2acfad0ce9357b68c608f07d8">lzma_check_is_supported()</a>, <a class="el" href="api_2lzma_2check_8h.html#afd3fda19575d9d4f864c626c02b7cb48">lzma_check_size()</a>, <a class="el" href="check_8c.html#aa5e9d54e127d31eda8e4f31cbe69e150">lzma_check_update()</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eaa9ff6dfee36b7aba4fae60706d37425f">LZMA_OPTIONS_ERROR</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea2dac8d451cb38da8550653d0d7be4ec2">LZMA_PROG_ERROR</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea989f393a1772d85bf545a9da48fc7ac2">LZMA_UNSUPPORTED_CHECK</a>, and <a class="el" href="common_8h.html#a3e1bf9f33b917e883b886b8a10458d66">return_if_error</a>.</p>

<p>Referenced by <a class="el" href="stream__buffer__encoder_8c.html#a932a602de4f44d8525687698e51ce93d">lzma_stream_buffer_encode()</a>.</p>

</div>
</div>
<a class="anchor" id="a2bdf26b5fb43880364991a1536d74346"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_block_buffer_decode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__block.html">lzma_block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>in_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>in_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>out_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>out_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-call .xz Block decoder. </p>
<p>This is single-call equivalent of <a class="el" href="block_8h.html#aa92c73b2a228efe921fa2376aa7adc92" title="Initialize .xz Block decoder.">lzma_block_decoder()</a>, and requires that the caller has already decoded Block Header and checked its memory usage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>Block options just like with <a class="el" href="block_8h.html#aa92c73b2a228efe921fa2376aa7adc92" title="Initialize .xz Block decoder.">lzma_block_decoder()</a>. </td></tr>
    <tr><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). </td></tr>
    <tr><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramname">in_pos</td><td>The next byte will be read from in[*in_pos]. *in_pos is updated only if decoding succeeds. </td></tr>
    <tr><td class="paramname">in_size</td><td>Size of the input buffer; the first byte that won't be read is in[in_size]. </td></tr>
    <tr><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramname">out_pos</td><td>The next byte will be written to out[*out_pos]. *out_pos is updated only if encoding succeeds. </td></tr>
    <tr><td class="paramname">out_size</td><td>Size of the out buffer; the first byte into which no data is written to is out[out_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK: Decoding was successful.<ul>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_DATA_ERROR</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_BUF_ERROR: Output buffer was too small.</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

<p>References <a class="el" href="structlzma__next__coder__s.html#a0d736e310d786b85d83f151f26b85440">lzma_next_coder_s::code</a>, <a class="el" href="structlzma__next__coder__s.html#ac2064cebf4a0f2f9abb2e090348dae4a">lzma_next_coder_s::coder</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea9ca0ecb62459bdc84d6af47d16b23ae5">LZMA_BUF_ERROR</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea3aa72729a844790e39b4e1101a731dfb">LZMA_DATA_ERROR</a>, <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea7d24fb3c6c144d13bcb091195b8ebec1">LZMA_FINISH</a>, <a class="el" href="common_8h.html#a1fca27f3d292f89fffbf7162d34a5bc3">LZMA_NEXT_CODER_INIT</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a>, <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea2dac8d451cb38da8550653d0d7be4ec2">LZMA_PROG_ERROR</a>, and <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea91ecc6fab14c13ad36224afbcb4e55c4">LZMA_STREAM_END</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jun 5 2014 14:34:56 for XZ Utils by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
