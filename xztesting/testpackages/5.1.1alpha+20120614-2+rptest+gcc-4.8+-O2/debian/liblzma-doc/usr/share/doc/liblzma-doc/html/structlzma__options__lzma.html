<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>XZ Utils: lzma_options_lzma Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">XZ Utils
   &#160;<span id="projectnumber">5.1.0alpha</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">lzma_options_lzma Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Options specific to the LZMA1 and LZMA2 filters.  
 <a href="structlzma__options__lzma.html#details">More...</a></p>

<p><code>#include &lt;lzma.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:aeb3f86002405a1191af86def46fca5ad"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__options__lzma.html#aeb3f86002405a1191af86def46fca5ad">dict_size</a></td></tr>
<tr class="memdesc:aeb3f86002405a1191af86def46fca5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dictionary size in bytes.  <a href="#aeb3f86002405a1191af86def46fca5ad"></a><br/></td></tr>
<tr class="memitem:a16a58c1ee3ec18c820d5cb03dde3739a"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__options__lzma.html#a16a58c1ee3ec18c820d5cb03dde3739a">preset_dict</a></td></tr>
<tr class="memdesc:a16a58c1ee3ec18c820d5cb03dde3739a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to an initial dictionary.  <a href="#a16a58c1ee3ec18c820d5cb03dde3739a"></a><br/></td></tr>
<tr class="memitem:a655ad4cce9e4dac9cf2a5c8daaa629e0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__options__lzma.html#a655ad4cce9e4dac9cf2a5c8daaa629e0">preset_dict_size</a></td></tr>
<tr class="memdesc:a655ad4cce9e4dac9cf2a5c8daaa629e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the preset dictionary.  <a href="#a655ad4cce9e4dac9cf2a5c8daaa629e0"></a><br/></td></tr>
<tr class="memitem:a95f6188e5b5f05c50ec463a315df3585"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__options__lzma.html#a95f6188e5b5f05c50ec463a315df3585">lc</a></td></tr>
<tr class="memdesc:a95f6188e5b5f05c50ec463a315df3585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of literal context bits.  <a href="#a95f6188e5b5f05c50ec463a315df3585"></a><br/></td></tr>
<tr class="memitem:a0fe9c54e808fce3090b6994d95fe41fe"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__options__lzma.html#a0fe9c54e808fce3090b6994d95fe41fe">lp</a></td></tr>
<tr class="memdesc:a0fe9c54e808fce3090b6994d95fe41fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of literal position bits.  <a href="#a0fe9c54e808fce3090b6994d95fe41fe"></a><br/></td></tr>
<tr class="memitem:acae107b3d3e9d0d4fe16103be22f4408"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__options__lzma.html#acae107b3d3e9d0d4fe16103be22f4408">pb</a></td></tr>
<tr class="memdesc:acae107b3d3e9d0d4fe16103be22f4408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of position bits.  <a href="#acae107b3d3e9d0d4fe16103be22f4408"></a><br/></td></tr>
<tr class="memitem:a1d711df9bda046fd3899abf21fa250d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lzma_2lzma_8h.html#a1032316e3075c2c8086fb17104b91866">lzma_mode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__options__lzma.html#a1d711df9bda046fd3899abf21fa250d5">mode</a></td></tr>
<tr class="memitem:a0352ea7f8b6a43b745a44f6cb4e2d263"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__options__lzma.html#a0352ea7f8b6a43b745a44f6cb4e2d263">nice_len</a></td></tr>
<tr class="memdesc:a0352ea7f8b6a43b745a44f6cb4e2d263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nice length of a match.  <a href="#a0352ea7f8b6a43b745a44f6cb4e2d263"></a><br/></td></tr>
<tr class="memitem:aa99612cd52259093007f33513882dcd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lzma_2lzma_8h.html#acf740075f86fa61dc408d6d0dbf8fa80">lzma_match_finder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__options__lzma.html#aa99612cd52259093007f33513882dcd0">mf</a></td></tr>
<tr class="memitem:a4226f686e8c9f6288595fe23d0e15713"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__options__lzma.html#a4226f686e8c9f6288595fe23d0e15713">depth</a></td></tr>
<tr class="memdesc:a4226f686e8c9f6288595fe23d0e15713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum search depth in the match finder.  <a href="#a4226f686e8c9f6288595fe23d0e15713"></a><br/></td></tr>
<tr class="memitem:a4b72e6b2f4d4797f83a98aca012f5dbe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b72e6b2f4d4797f83a98aca012f5dbe"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>reserved_int1</b></td></tr>
<tr class="memitem:a6137ed4e246c04096c482ee025d38040"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6137ed4e246c04096c482ee025d38040"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>reserved_int2</b></td></tr>
<tr class="memitem:a74beb2b17e576c874364e0058fa0e603"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74beb2b17e576c874364e0058fa0e603"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>reserved_int3</b></td></tr>
<tr class="memitem:ab0a9c3c5d5223a8fe11b4348539187ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0a9c3c5d5223a8fe11b4348539187ca"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>reserved_int4</b></td></tr>
<tr class="memitem:a6142648309696a5f7c93a7c5bdfc95ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6142648309696a5f7c93a7c5bdfc95ee"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>reserved_int5</b></td></tr>
<tr class="memitem:a0e98b6455879a7cd0dd14abdfd1eaee0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e98b6455879a7cd0dd14abdfd1eaee0"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>reserved_int6</b></td></tr>
<tr class="memitem:a678f10760b968d7c4ae4871449ecbb15"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a678f10760b968d7c4ae4871449ecbb15"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>reserved_int7</b></td></tr>
<tr class="memitem:abba53bf48e31050472d3eeb0c90eb438"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abba53bf48e31050472d3eeb0c90eb438"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>reserved_int8</b></td></tr>
<tr class="memitem:a284d6921883e4b94eb9f11a584b9fc28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a284d6921883e4b94eb9f11a584b9fc28"></a>
<a class="el" href="base_8h.html#a05805a07754b2aa22f7d443eb7ece41a">lzma_reserved_enum</a>&#160;</td><td class="memItemRight" valign="bottom"><b>reserved_enum1</b></td></tr>
<tr class="memitem:a60402127f2ab147d52f90d71adf9ce1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60402127f2ab147d52f90d71adf9ce1c"></a>
<a class="el" href="base_8h.html#a05805a07754b2aa22f7d443eb7ece41a">lzma_reserved_enum</a>&#160;</td><td class="memItemRight" valign="bottom"><b>reserved_enum2</b></td></tr>
<tr class="memitem:aceab85dcaa62850c0865d211430688c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aceab85dcaa62850c0865d211430688c9"></a>
<a class="el" href="base_8h.html#a05805a07754b2aa22f7d443eb7ece41a">lzma_reserved_enum</a>&#160;</td><td class="memItemRight" valign="bottom"><b>reserved_enum3</b></td></tr>
<tr class="memitem:a6744d98bfb2fa6f60220e29520d35ad0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6744d98bfb2fa6f60220e29520d35ad0"></a>
<a class="el" href="base_8h.html#a05805a07754b2aa22f7d443eb7ece41a">lzma_reserved_enum</a>&#160;</td><td class="memItemRight" valign="bottom"><b>reserved_enum4</b></td></tr>
<tr class="memitem:a68929590ab047b40a3fd53cf99b0ceb8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68929590ab047b40a3fd53cf99b0ceb8"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>reserved_ptr1</b></td></tr>
<tr class="memitem:ac8f6bbe31a15ea3782722f9508a467f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8f6bbe31a15ea3782722f9508a467f0"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>reserved_ptr2</b></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Options specific to the LZMA1 and LZMA2 filters. </p>
<p>Since LZMA1 and LZMA2 share most of the code, it's simplest to share the options structure too. For encoding, all but the reserved variables need to be initialized unless specifically mentioned otherwise. <a class="el" href="lzma_2lzma_8h.html#aa62c28944fe3575653a4c25780400d77" title="Set a compression preset to lzma_options_lzma structure.">lzma_lzma_preset()</a> can be used to get a good starting point.</p>
<p>For raw decoding, both LZMA1 and LZMA2 need dict_size, preset_dict, and preset_dict_size (if preset_dict != NULL). LZMA1 needs also lc, lp, and pb. </p>
</div><h2>Field Documentation</h2>
<a class="anchor" id="aeb3f86002405a1191af86def46fca5ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lzma_options_lzma::dict_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dictionary size in bytes. </p>
<p>Dictionary size indicates how many bytes of the recently processed uncompressed data is kept in memory. One method to reduce size of the uncompressed data is to store distance-length pairs, which indicate what data to repeat from the dictionary buffer. Thus, the bigger the dictionary, the better the compression ratio usually is.</p>
<p>Maximum size of the dictionary depends on multiple things:</p>
<ul>
<li>Memory usage limit</li>
<li>Available address space (not a problem on 64-bit systems)</li>
<li>Selected match finder (encoder only)</li>
</ul>
<p>Currently the maximum dictionary size for encoding is 1.5 GiB (i.e. (UINT32_C(1) &lt;&lt; 30) + (UINT32_C(1) &lt;&lt; 29)) even on 64-bit systems for certain match finder implementation reasons. In the future, there may be match finders that support bigger dictionaries.</p>
<p>Decoder already supports dictionaries up to 4 GiB - 1 B (i.e. UINT32_MAX), so increasing the maximum dictionary size of the encoder won't cause problems for old decoders.</p>
<p>Because extremely small dictionaries sizes would have unneeded overhead in the decoder, the minimum dictionary size is 4096 bytes.</p>
<dl class="section note"><dt>Note</dt><dd>When decoding, too big dictionary does no other harm than wasting memory. </dd></dl>

<p>Referenced by <a class="el" href="coder_8c.html#a15b6ce144220e53107c642b3baefe9bc">is_format_lzma()</a>, <a class="el" href="lzmainfo_8c.html#a76cfa2b4fc44ede3c371981dd4e66e11">lzmainfo()</a>, and <a class="el" href="message_8h.html#abb05c48d97be5905fe89b7b83b757c05">message_filters_to_str()</a>.</p>

</div>
</div>
<a class="anchor" id="a16a58c1ee3ec18c820d5cb03dde3739a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* lzma_options_lzma::preset_dict</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to an initial dictionary. </p>
<p>It is possible to initialize the LZ77 history window using a preset dictionary. It is useful when compressing many similar, relatively small chunks of data independently from each other. The preset dictionary should contain typical strings that occur in the files being compressed. The most probable strings should be near the end of the preset dictionary.</p>
<p>This feature should be used only in special situations. For now, it works correctly only with raw encoding and decoding. Currently none of the container formats supported by liblzma allow preset dictionary when decoding, thus if you create a .xz or .lzma file with preset dictionary, it cannot be decoded with the regular decoder functions. In the future, the .xz format will likely get support for preset dictionary though. </p>

</div>
</div>
<a class="anchor" id="a655ad4cce9e4dac9cf2a5c8daaa629e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lzma_options_lzma::preset_dict_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of the preset dictionary. </p>
<p>Specifies the size of the preset dictionary. If the size is bigger than dict_size, only the last dict_size bytes are processed.</p>
<p>This variable is read only when preset_dict is not NULL. If preset_dict is not NULL but preset_dict_size is zero, no preset dictionary is used (identical to only setting preset_dict to NULL). </p>

</div>
</div>
<a class="anchor" id="a95f6188e5b5f05c50ec463a315df3585"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lzma_options_lzma::lc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of literal context bits. </p>
<p>How many of the highest bits of the previous uncompressed eight-bit byte (also known as `literal') are taken into account when predicting the bits of the next literal.</p>
<p>E.g. in typical English text, an upper-case letter is often followed by a lower-case letter, and a lower-case letter is usually followed by another lower-case letter. In the US-ASCII character set, the highest three bits are 010 for upper-case letters and 011 for lower-case letters. When lc is at least 3, the literal coding can take advantage of this property in the uncompressed data.</p>
<p>There is a limit that applies to literal context bits and literal position bits together: lc + lp &lt;= 4. Without this limit the decoding could become very slow, which could have security related results in some cases like email servers doing virus scanning. This limit also simplifies the internal implementation in liblzma.</p>
<p>There may be LZMA1 streams that have lc + lp &gt; 4 (maximum possible lc would be 8). It is not possible to decode such streams with liblzma. </p>

<p>Referenced by <a class="el" href="lzma__common_8h.html#aedd478d0358af2297a6cac1d73540e85">is_lclppb_valid()</a>, <a class="el" href="lzma__decoder_8h.html#a4907f7d9047a0c9990bdaf943ae8a181">lzma_lzma_lclppb_decode()</a>, <a class="el" href="lzma__encoder_8h.html#a24e42d27f537c4382fe298c9909b1a52">lzma_lzma_lclppb_encode()</a>, <a class="el" href="lzmainfo_8c.html#a76cfa2b4fc44ede3c371981dd4e66e11">lzmainfo()</a>, <a class="el" href="message_8h.html#abb05c48d97be5905fe89b7b83b757c05">message_filters_to_str()</a>, and <a class="el" href="options_8h.html#a80e4a9dd89d3f2fab00c48c4feb75126">options_lzma()</a>.</p>

</div>
</div>
<a class="anchor" id="a0fe9c54e808fce3090b6994d95fe41fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lzma_options_lzma::lp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of literal position bits. </p>
<p>lp affects what kind of alignment in the uncompressed data is assumed when encoding literals. A literal is a single 8-bit byte. See pb below for more information about alignment. </p>

<p>Referenced by <a class="el" href="lzma__common_8h.html#aedd478d0358af2297a6cac1d73540e85">is_lclppb_valid()</a>, <a class="el" href="lzma__decoder_8h.html#a4907f7d9047a0c9990bdaf943ae8a181">lzma_lzma_lclppb_decode()</a>, <a class="el" href="lzma__encoder_8h.html#a24e42d27f537c4382fe298c9909b1a52">lzma_lzma_lclppb_encode()</a>, <a class="el" href="lzmainfo_8c.html#a76cfa2b4fc44ede3c371981dd4e66e11">lzmainfo()</a>, <a class="el" href="message_8h.html#abb05c48d97be5905fe89b7b83b757c05">message_filters_to_str()</a>, and <a class="el" href="options_8h.html#a80e4a9dd89d3f2fab00c48c4feb75126">options_lzma()</a>.</p>

</div>
</div>
<a class="anchor" id="acae107b3d3e9d0d4fe16103be22f4408"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lzma_options_lzma::pb</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of position bits. </p>
<p>pb affects what kind of alignment in the uncompressed data is assumed in general. The default means four-byte alignment (2^ pb =2^2=4), which is often a good choice when there's no better guess.</p>
<p>When the aligment is known, setting pb accordingly may reduce the file size a little. E.g. with text files having one-byte alignment (US-ASCII, ISO-8859-*, UTF-8), setting pb=0 can improve compression slightly. For UTF-16 text, pb=1 is a good choice. If the alignment is an odd number like 3 bytes, pb=0 might be the best choice.</p>
<p>Even though the assumed alignment can be adjusted with pb and lp, LZMA1 and LZMA2 still slightly favor 16-byte alignment. It might be worth taking into account when designing file formats that are likely to be often compressed with LZMA1 or LZMA2. </p>

<p>Referenced by <a class="el" href="lzma__common_8h.html#aedd478d0358af2297a6cac1d73540e85">is_lclppb_valid()</a>, <a class="el" href="lzma__decoder_8h.html#a4907f7d9047a0c9990bdaf943ae8a181">lzma_lzma_lclppb_decode()</a>, <a class="el" href="lzma__encoder_8h.html#a24e42d27f537c4382fe298c9909b1a52">lzma_lzma_lclppb_encode()</a>, <a class="el" href="lzmainfo_8c.html#a76cfa2b4fc44ede3c371981dd4e66e11">lzmainfo()</a>, and <a class="el" href="message_8h.html#abb05c48d97be5905fe89b7b83b757c05">message_filters_to_str()</a>.</p>

</div>
</div>
<a class="anchor" id="a1d711df9bda046fd3899abf21fa250d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lzma_2lzma_8h.html#a1032316e3075c2c8086fb17104b91866">lzma_mode</a> lzma_options_lzma::mode</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compression mode </p>

<p>Referenced by <a class="el" href="message_8h.html#abb05c48d97be5905fe89b7b83b757c05">message_filters_to_str()</a>.</p>

</div>
</div>
<a class="anchor" id="a0352ea7f8b6a43b745a44f6cb4e2d263"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lzma_options_lzma::nice_len</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nice length of a match. </p>
<p>This determines how many bytes the encoder compares from the match candidates when looking for the best match. Once a match of at least nice_len bytes long is found, the encoder stops looking for better candidates and encodes the match. (Naturally, if the found match is actually longer than nice_len, the actual length is encoded; it's not truncated to nice_len.)</p>
<p>Bigger values usually increase the compression ratio and compression time. For most files, 32 to 128 is a good value, which gives very good compression ratio at good speed.</p>
<p>The exact minimum value depends on the match finder. The maximum is 273, which is the maximum length of a match that LZMA1 and LZMA2 can encode. </p>

<p>Referenced by <a class="el" href="message_8h.html#abb05c48d97be5905fe89b7b83b757c05">message_filters_to_str()</a>, and <a class="el" href="options_8h.html#a80e4a9dd89d3f2fab00c48c4feb75126">options_lzma()</a>.</p>

</div>
</div>
<a class="anchor" id="aa99612cd52259093007f33513882dcd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lzma_2lzma_8h.html#acf740075f86fa61dc408d6d0dbf8fa80">lzma_match_finder</a> lzma_options_lzma::mf</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Match finder ID </p>

<p>Referenced by <a class="el" href="message_8h.html#abb05c48d97be5905fe89b7b83b757c05">message_filters_to_str()</a>, and <a class="el" href="options_8h.html#a80e4a9dd89d3f2fab00c48c4feb75126">options_lzma()</a>.</p>

</div>
</div>
<a class="anchor" id="a4226f686e8c9f6288595fe23d0e15713"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lzma_options_lzma::depth</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum search depth in the match finder. </p>
<p>For every input byte, match finder searches through the hash chain or binary tree in a loop, each iteration going one step deeper in the chain or tree. The searching stops if</p>
<ul>
<li>a match of at least nice_len bytes long is found;</li>
<li>all match candidates from the hash chain or binary tree have been checked; or</li>
<li>maximum search depth is reached.</li>
</ul>
<p>Maximum search depth is needed to prevent the match finder from wasting too much time in case there are lots of short match candidates. On the other hand, stopping the search before all candidates have been checked can reduce compression ratio.</p>
<p>Setting depth to zero tells liblzma to use an automatic default value, that depends on the selected match finder and nice_len. The default is in the range [4, 200] or so (it may vary between liblzma versions).</p>
<p>Using a bigger depth value than the default can increase compression ratio in some cases. There is no strict maximum value, but high values (thousands or millions) should be used with care: the encoder could remain fast enough with typical input, but malicious input could cause the match finder to slow down dramatically, possibly creating a denial of service attack. </p>

<p>Referenced by <a class="el" href="message_8h.html#abb05c48d97be5905fe89b7b83b757c05">message_filters_to_str()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>liblzma/api/lzma/<a class="el" href="lzma_2lzma_8h.html">lzma.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jun 5 2014 14:34:33 for XZ Utils by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
